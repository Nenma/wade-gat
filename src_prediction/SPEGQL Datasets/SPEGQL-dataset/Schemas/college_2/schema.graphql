schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "advisor"
"""
type advisor {
  i_id: String

  """An object relationship"""
  instructor: instructor
  s_id: String

  """An object relationship"""
  student: student
}

"""
aggregated selection of "advisor"
"""
type advisor_aggregate {
  aggregate: advisor_aggregate_fields
  nodes: [advisor!]!
}

"""
aggregate fields of "advisor"
"""
type advisor_aggregate_fields {
  count(columns: [advisor_select_column!], distinct: Boolean): Int
  max: advisor_max_fields
  min: advisor_min_fields
}

"""
order by aggregate values of table "advisor"
"""
input advisor_aggregate_order_by {
  count: order_by
  max: advisor_max_order_by
  min: advisor_min_order_by
}

"""
input type for inserting array relation for remote table "advisor"
"""
input advisor_arr_rel_insert_input {
  data: [advisor_insert_input!]!
  on_conflict: advisor_on_conflict
}

"""
Boolean expression to filter rows from the table "advisor". All fields are combined with a logical 'AND'.
"""
input advisor_bool_exp {
  _and: [advisor_bool_exp]
  _not: advisor_bool_exp
  _or: [advisor_bool_exp]
  i_id: String_comparison_exp
  instructor: instructor_bool_exp
  s_id: String_comparison_exp
  student: student_bool_exp
}

"""
unique or primary key constraints on table "advisor"
"""
enum advisor_constraint {
  """unique or primary key constraint"""
  idx_19933_sqlite_autoindex_advisor_1
}

"""
input type for inserting data into table "advisor"
"""
input advisor_insert_input {
  i_id: String
  instructor: instructor_obj_rel_insert_input
  s_id: String
  student: student_obj_rel_insert_input
}

"""aggregate max on columns"""
type advisor_max_fields {
  i_id: String
  s_id: String
}

"""
order by max() on columns of table "advisor"
"""
input advisor_max_order_by {
  i_id: order_by
  s_id: order_by
}

"""aggregate min on columns"""
type advisor_min_fields {
  i_id: String
  s_id: String
}

"""
order by min() on columns of table "advisor"
"""
input advisor_min_order_by {
  i_id: order_by
  s_id: order_by
}

"""
response of any mutation on the table "advisor"
"""
type advisor_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [advisor!]!
}

"""
input type for inserting object relation for remote table "advisor"
"""
input advisor_obj_rel_insert_input {
  data: advisor_insert_input!
  on_conflict: advisor_on_conflict
}

"""
on conflict condition type for table "advisor"
"""
input advisor_on_conflict {
  constraint: advisor_constraint!
  update_columns: [advisor_update_column!]!
  where: advisor_bool_exp
}

"""
ordering options when selecting data from "advisor"
"""
input advisor_order_by {
  i_id: order_by
  instructor: instructor_order_by
  s_id: order_by
  student: student_order_by
}

"""
select columns of table "advisor"
"""
enum advisor_select_column {
  """column name"""
  i_id

  """column name"""
  s_id
}

"""
input type for updating data in table "advisor"
"""
input advisor_set_input {
  i_id: String
  s_id: String
}

"""
update columns of table "advisor"
"""
enum advisor_update_column {
  """column name"""
  i_id

  """column name"""
  s_id
}

"""
columns and relationships of "classroom"
"""
type classroom {
  building: String!
  capacity: numeric
  room_number: String!

  """An array relationship"""
  sections(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): [section!]!

  """An aggregated array relationship"""
  sections_aggregate(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): section_aggregate!
}

"""
aggregated selection of "classroom"
"""
type classroom_aggregate {
  aggregate: classroom_aggregate_fields
  nodes: [classroom!]!
}

"""
aggregate fields of "classroom"
"""
type classroom_aggregate_fields {
  avg: classroom_avg_fields
  count(columns: [classroom_select_column!], distinct: Boolean): Int
  max: classroom_max_fields
  min: classroom_min_fields
  stddev: classroom_stddev_fields
  stddev_pop: classroom_stddev_pop_fields
  stddev_samp: classroom_stddev_samp_fields
  sum: classroom_sum_fields
  var_pop: classroom_var_pop_fields
  var_samp: classroom_var_samp_fields
  variance: classroom_variance_fields
}

"""
order by aggregate values of table "classroom"
"""
input classroom_aggregate_order_by {
  avg: classroom_avg_order_by
  count: order_by
  max: classroom_max_order_by
  min: classroom_min_order_by
  stddev: classroom_stddev_order_by
  stddev_pop: classroom_stddev_pop_order_by
  stddev_samp: classroom_stddev_samp_order_by
  sum: classroom_sum_order_by
  var_pop: classroom_var_pop_order_by
  var_samp: classroom_var_samp_order_by
  variance: classroom_variance_order_by
}

"""
input type for inserting array relation for remote table "classroom"
"""
input classroom_arr_rel_insert_input {
  data: [classroom_insert_input!]!
  on_conflict: classroom_on_conflict
}

"""aggregate avg on columns"""
type classroom_avg_fields {
  capacity: Float
}

"""
order by avg() on columns of table "classroom"
"""
input classroom_avg_order_by {
  capacity: order_by
}

"""
Boolean expression to filter rows from the table "classroom". All fields are combined with a logical 'AND'.
"""
input classroom_bool_exp {
  _and: [classroom_bool_exp]
  _not: classroom_bool_exp
  _or: [classroom_bool_exp]
  building: String_comparison_exp
  capacity: numeric_comparison_exp
  room_number: String_comparison_exp
  sections: section_bool_exp
}

"""
unique or primary key constraints on table "classroom"
"""
enum classroom_constraint {
  """unique or primary key constraint"""
  idx_19885_sqlite_autoindex_classroom_1
}

"""
input type for incrementing integer column in table "classroom"
"""
input classroom_inc_input {
  capacity: numeric
}

"""
input type for inserting data into table "classroom"
"""
input classroom_insert_input {
  building: String
  capacity: numeric
  room_number: String
  sections: section_arr_rel_insert_input
}

"""aggregate max on columns"""
type classroom_max_fields {
  building: String
  capacity: numeric
  room_number: String
}

"""
order by max() on columns of table "classroom"
"""
input classroom_max_order_by {
  building: order_by
  capacity: order_by
  room_number: order_by
}

"""aggregate min on columns"""
type classroom_min_fields {
  building: String
  capacity: numeric
  room_number: String
}

"""
order by min() on columns of table "classroom"
"""
input classroom_min_order_by {
  building: order_by
  capacity: order_by
  room_number: order_by
}

"""
response of any mutation on the table "classroom"
"""
type classroom_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [classroom!]!
}

"""
input type for inserting object relation for remote table "classroom"
"""
input classroom_obj_rel_insert_input {
  data: classroom_insert_input!
  on_conflict: classroom_on_conflict
}

"""
on conflict condition type for table "classroom"
"""
input classroom_on_conflict {
  constraint: classroom_constraint!
  update_columns: [classroom_update_column!]!
  where: classroom_bool_exp
}

"""
ordering options when selecting data from "classroom"
"""
input classroom_order_by {
  building: order_by
  capacity: order_by
  room_number: order_by
  sections_aggregate: section_aggregate_order_by
}

"""
primary key columns input for table: "classroom"
"""
input classroom_pk_columns_input {
  building: String!
  room_number: String!
}

"""
select columns of table "classroom"
"""
enum classroom_select_column {
  """column name"""
  building

  """column name"""
  capacity

  """column name"""
  room_number
}

"""
input type for updating data in table "classroom"
"""
input classroom_set_input {
  building: String
  capacity: numeric
  room_number: String
}

"""aggregate stddev on columns"""
type classroom_stddev_fields {
  capacity: Float
}

"""
order by stddev() on columns of table "classroom"
"""
input classroom_stddev_order_by {
  capacity: order_by
}

"""aggregate stddev_pop on columns"""
type classroom_stddev_pop_fields {
  capacity: Float
}

"""
order by stddev_pop() on columns of table "classroom"
"""
input classroom_stddev_pop_order_by {
  capacity: order_by
}

"""aggregate stddev_samp on columns"""
type classroom_stddev_samp_fields {
  capacity: Float
}

"""
order by stddev_samp() on columns of table "classroom"
"""
input classroom_stddev_samp_order_by {
  capacity: order_by
}

"""aggregate sum on columns"""
type classroom_sum_fields {
  capacity: numeric
}

"""
order by sum() on columns of table "classroom"
"""
input classroom_sum_order_by {
  capacity: order_by
}

"""
update columns of table "classroom"
"""
enum classroom_update_column {
  """column name"""
  building

  """column name"""
  capacity

  """column name"""
  room_number
}

"""aggregate var_pop on columns"""
type classroom_var_pop_fields {
  capacity: Float
}

"""
order by var_pop() on columns of table "classroom"
"""
input classroom_var_pop_order_by {
  capacity: order_by
}

"""aggregate var_samp on columns"""
type classroom_var_samp_fields {
  capacity: Float
}

"""
order by var_samp() on columns of table "classroom"
"""
input classroom_var_samp_order_by {
  capacity: order_by
}

"""aggregate variance on columns"""
type classroom_variance_fields {
  capacity: Float
}

"""
order by variance() on columns of table "classroom"
"""
input classroom_variance_order_by {
  capacity: order_by
}

"""
columns and relationships of "course"
"""
type course {
  course_id: String!
  credits: numeric

  """An object relationship"""
  department: department
  dept_name: String

  """An array relationship"""
  prereqs(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): [prereq!]!

  """An array relationship"""
  prereqsByCourseId(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): [prereq!]!

  """An aggregated array relationship"""
  prereqsByCourseId_aggregate(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): prereq_aggregate!

  """An aggregated array relationship"""
  prereqs_aggregate(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): prereq_aggregate!

  """An array relationship"""
  sections(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): [section!]!

  """An aggregated array relationship"""
  sections_aggregate(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): section_aggregate!

  """An array relationship"""
  takes(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): [takes!]!

  """An aggregated array relationship"""
  takes_aggregate(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): takes_aggregate!

  """An array relationship"""
  teaches(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): [teaches!]!

  """An aggregated array relationship"""
  teaches_aggregate(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): teaches_aggregate!
  title: String
}

"""
aggregated selection of "course"
"""
type course_aggregate {
  aggregate: course_aggregate_fields
  nodes: [course!]!
}

"""
aggregate fields of "course"
"""
type course_aggregate_fields {
  avg: course_avg_fields
  count(columns: [course_select_column!], distinct: Boolean): Int
  max: course_max_fields
  min: course_min_fields
  stddev: course_stddev_fields
  stddev_pop: course_stddev_pop_fields
  stddev_samp: course_stddev_samp_fields
  sum: course_sum_fields
  var_pop: course_var_pop_fields
  var_samp: course_var_samp_fields
  variance: course_variance_fields
}

"""
order by aggregate values of table "course"
"""
input course_aggregate_order_by {
  avg: course_avg_order_by
  count: order_by
  max: course_max_order_by
  min: course_min_order_by
  stddev: course_stddev_order_by
  stddev_pop: course_stddev_pop_order_by
  stddev_samp: course_stddev_samp_order_by
  sum: course_sum_order_by
  var_pop: course_var_pop_order_by
  var_samp: course_var_samp_order_by
  variance: course_variance_order_by
}

"""
input type for inserting array relation for remote table "course"
"""
input course_arr_rel_insert_input {
  data: [course_insert_input!]!
  on_conflict: course_on_conflict
}

"""aggregate avg on columns"""
type course_avg_fields {
  credits: Float
}

"""
order by avg() on columns of table "course"
"""
input course_avg_order_by {
  credits: order_by
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input course_bool_exp {
  _and: [course_bool_exp]
  _not: course_bool_exp
  _or: [course_bool_exp]
  course_id: String_comparison_exp
  credits: numeric_comparison_exp
  department: department_bool_exp
  dept_name: String_comparison_exp
  prereqs: prereq_bool_exp
  prereqsByCourseId: prereq_bool_exp
  sections: section_bool_exp
  takes: takes_bool_exp
  teaches: teaches_bool_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "course"
"""
enum course_constraint {
  """unique or primary key constraint"""
  idx_19897_sqlite_autoindex_course_1
}

"""
input type for incrementing integer column in table "course"
"""
input course_inc_input {
  credits: numeric
}

"""
input type for inserting data into table "course"
"""
input course_insert_input {
  course_id: String
  credits: numeric
  department: department_obj_rel_insert_input
  dept_name: String
  prereqs: prereq_arr_rel_insert_input
  prereqsByCourseId: prereq_arr_rel_insert_input
  sections: section_arr_rel_insert_input
  takes: takes_arr_rel_insert_input
  teaches: teaches_arr_rel_insert_input
  title: String
}

"""aggregate max on columns"""
type course_max_fields {
  course_id: String
  credits: numeric
  dept_name: String
  title: String
}

"""
order by max() on columns of table "course"
"""
input course_max_order_by {
  course_id: order_by
  credits: order_by
  dept_name: order_by
  title: order_by
}

"""aggregate min on columns"""
type course_min_fields {
  course_id: String
  credits: numeric
  dept_name: String
  title: String
}

"""
order by min() on columns of table "course"
"""
input course_min_order_by {
  course_id: order_by
  credits: order_by
  dept_name: order_by
  title: order_by
}

"""
response of any mutation on the table "course"
"""
type course_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input course_obj_rel_insert_input {
  data: course_insert_input!
  on_conflict: course_on_conflict
}

"""
on conflict condition type for table "course"
"""
input course_on_conflict {
  constraint: course_constraint!
  update_columns: [course_update_column!]!
  where: course_bool_exp
}

"""
ordering options when selecting data from "course"
"""
input course_order_by {
  course_id: order_by
  credits: order_by
  department: department_order_by
  dept_name: order_by
  prereqsByCourseId_aggregate: prereq_aggregate_order_by
  prereqs_aggregate: prereq_aggregate_order_by
  sections_aggregate: section_aggregate_order_by
  takes_aggregate: takes_aggregate_order_by
  teaches_aggregate: teaches_aggregate_order_by
  title: order_by
}

"""
primary key columns input for table: "course"
"""
input course_pk_columns_input {
  course_id: String!
}

"""
select columns of table "course"
"""
enum course_select_column {
  """column name"""
  course_id

  """column name"""
  credits

  """column name"""
  dept_name

  """column name"""
  title
}

"""
input type for updating data in table "course"
"""
input course_set_input {
  course_id: String
  credits: numeric
  dept_name: String
  title: String
}

"""aggregate stddev on columns"""
type course_stddev_fields {
  credits: Float
}

"""
order by stddev() on columns of table "course"
"""
input course_stddev_order_by {
  credits: order_by
}

"""aggregate stddev_pop on columns"""
type course_stddev_pop_fields {
  credits: Float
}

"""
order by stddev_pop() on columns of table "course"
"""
input course_stddev_pop_order_by {
  credits: order_by
}

"""aggregate stddev_samp on columns"""
type course_stddev_samp_fields {
  credits: Float
}

"""
order by stddev_samp() on columns of table "course"
"""
input course_stddev_samp_order_by {
  credits: order_by
}

"""aggregate sum on columns"""
type course_sum_fields {
  credits: numeric
}

"""
order by sum() on columns of table "course"
"""
input course_sum_order_by {
  credits: order_by
}

"""
update columns of table "course"
"""
enum course_update_column {
  """column name"""
  course_id

  """column name"""
  credits

  """column name"""
  dept_name

  """column name"""
  title
}

"""aggregate var_pop on columns"""
type course_var_pop_fields {
  credits: Float
}

"""
order by var_pop() on columns of table "course"
"""
input course_var_pop_order_by {
  credits: order_by
}

"""aggregate var_samp on columns"""
type course_var_samp_fields {
  credits: Float
}

"""
order by var_samp() on columns of table "course"
"""
input course_var_samp_order_by {
  credits: order_by
}

"""aggregate variance on columns"""
type course_variance_fields {
  credits: Float
}

"""
order by variance() on columns of table "course"
"""
input course_variance_order_by {
  credits: order_by
}

"""
columns and relationships of "department"
"""
type department {
  budget: numeric
  building: String

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """An aggregated array relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!
  dept_name: String!

  """An array relationship"""
  instructors(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): [instructor!]!

  """An aggregated array relationship"""
  instructors_aggregate(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): instructor_aggregate!

  """An array relationship"""
  students(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): [student!]!

  """An aggregated array relationship"""
  students_aggregate(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): student_aggregate!
}

"""
aggregated selection of "department"
"""
type department_aggregate {
  aggregate: department_aggregate_fields
  nodes: [department!]!
}

"""
aggregate fields of "department"
"""
type department_aggregate_fields {
  avg: department_avg_fields
  count(columns: [department_select_column!], distinct: Boolean): Int
  max: department_max_fields
  min: department_min_fields
  stddev: department_stddev_fields
  stddev_pop: department_stddev_pop_fields
  stddev_samp: department_stddev_samp_fields
  sum: department_sum_fields
  var_pop: department_var_pop_fields
  var_samp: department_var_samp_fields
  variance: department_variance_fields
}

"""
order by aggregate values of table "department"
"""
input department_aggregate_order_by {
  avg: department_avg_order_by
  count: order_by
  max: department_max_order_by
  min: department_min_order_by
  stddev: department_stddev_order_by
  stddev_pop: department_stddev_pop_order_by
  stddev_samp: department_stddev_samp_order_by
  sum: department_sum_order_by
  var_pop: department_var_pop_order_by
  var_samp: department_var_samp_order_by
  variance: department_variance_order_by
}

"""
input type for inserting array relation for remote table "department"
"""
input department_arr_rel_insert_input {
  data: [department_insert_input!]!
  on_conflict: department_on_conflict
}

"""aggregate avg on columns"""
type department_avg_fields {
  budget: Float
}

"""
order by avg() on columns of table "department"
"""
input department_avg_order_by {
  budget: order_by
}

"""
Boolean expression to filter rows from the table "department". All fields are combined with a logical 'AND'.
"""
input department_bool_exp {
  _and: [department_bool_exp]
  _not: department_bool_exp
  _or: [department_bool_exp]
  budget: numeric_comparison_exp
  building: String_comparison_exp
  courses: course_bool_exp
  dept_name: String_comparison_exp
  instructors: instructor_bool_exp
  students: student_bool_exp
}

"""
unique or primary key constraints on table "department"
"""
enum department_constraint {
  """unique or primary key constraint"""
  idx_19891_sqlite_autoindex_department_1
}

"""
input type for incrementing integer column in table "department"
"""
input department_inc_input {
  budget: numeric
}

"""
input type for inserting data into table "department"
"""
input department_insert_input {
  budget: numeric
  building: String
  courses: course_arr_rel_insert_input
  dept_name: String
  instructors: instructor_arr_rel_insert_input
  students: student_arr_rel_insert_input
}

"""aggregate max on columns"""
type department_max_fields {
  budget: numeric
  building: String
  dept_name: String
}

"""
order by max() on columns of table "department"
"""
input department_max_order_by {
  budget: order_by
  building: order_by
  dept_name: order_by
}

"""aggregate min on columns"""
type department_min_fields {
  budget: numeric
  building: String
  dept_name: String
}

"""
order by min() on columns of table "department"
"""
input department_min_order_by {
  budget: order_by
  building: order_by
  dept_name: order_by
}

"""
response of any mutation on the table "department"
"""
type department_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [department!]!
}

"""
input type for inserting object relation for remote table "department"
"""
input department_obj_rel_insert_input {
  data: department_insert_input!
  on_conflict: department_on_conflict
}

"""
on conflict condition type for table "department"
"""
input department_on_conflict {
  constraint: department_constraint!
  update_columns: [department_update_column!]!
  where: department_bool_exp
}

"""
ordering options when selecting data from "department"
"""
input department_order_by {
  budget: order_by
  building: order_by
  courses_aggregate: course_aggregate_order_by
  dept_name: order_by
  instructors_aggregate: instructor_aggregate_order_by
  students_aggregate: student_aggregate_order_by
}

"""
primary key columns input for table: "department"
"""
input department_pk_columns_input {
  dept_name: String!
}

"""
select columns of table "department"
"""
enum department_select_column {
  """column name"""
  budget

  """column name"""
  building

  """column name"""
  dept_name
}

"""
input type for updating data in table "department"
"""
input department_set_input {
  budget: numeric
  building: String
  dept_name: String
}

"""aggregate stddev on columns"""
type department_stddev_fields {
  budget: Float
}

"""
order by stddev() on columns of table "department"
"""
input department_stddev_order_by {
  budget: order_by
}

"""aggregate stddev_pop on columns"""
type department_stddev_pop_fields {
  budget: Float
}

"""
order by stddev_pop() on columns of table "department"
"""
input department_stddev_pop_order_by {
  budget: order_by
}

"""aggregate stddev_samp on columns"""
type department_stddev_samp_fields {
  budget: Float
}

"""
order by stddev_samp() on columns of table "department"
"""
input department_stddev_samp_order_by {
  budget: order_by
}

"""aggregate sum on columns"""
type department_sum_fields {
  budget: numeric
}

"""
order by sum() on columns of table "department"
"""
input department_sum_order_by {
  budget: order_by
}

"""
update columns of table "department"
"""
enum department_update_column {
  """column name"""
  budget

  """column name"""
  building

  """column name"""
  dept_name
}

"""aggregate var_pop on columns"""
type department_var_pop_fields {
  budget: Float
}

"""
order by var_pop() on columns of table "department"
"""
input department_var_pop_order_by {
  budget: order_by
}

"""aggregate var_samp on columns"""
type department_var_samp_fields {
  budget: Float
}

"""
order by var_samp() on columns of table "department"
"""
input department_var_samp_order_by {
  budget: order_by
}

"""aggregate variance on columns"""
type department_variance_fields {
  budget: Float
}

"""
order by variance() on columns of table "department"
"""
input department_variance_order_by {
  budget: order_by
}

"""
columns and relationships of "instructor"
"""
type instructor {
  """An array relationship"""
  advisors(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): [advisor!]!

  """An aggregated array relationship"""
  advisors_aggregate(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): advisor_aggregate!

  """An object relationship"""
  department: department
  dept_name: String
  id: String
  name: String
  salary: numeric

  """An array relationship"""
  teaches(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): [teaches!]!

  """An aggregated array relationship"""
  teaches_aggregate(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): teaches_aggregate!
}

"""
aggregated selection of "instructor"
"""
type instructor_aggregate {
  aggregate: instructor_aggregate_fields
  nodes: [instructor!]!
}

"""
aggregate fields of "instructor"
"""
type instructor_aggregate_fields {
  avg: instructor_avg_fields
  count(columns: [instructor_select_column!], distinct: Boolean): Int
  max: instructor_max_fields
  min: instructor_min_fields
  stddev: instructor_stddev_fields
  stddev_pop: instructor_stddev_pop_fields
  stddev_samp: instructor_stddev_samp_fields
  sum: instructor_sum_fields
  var_pop: instructor_var_pop_fields
  var_samp: instructor_var_samp_fields
  variance: instructor_variance_fields
}

"""
order by aggregate values of table "instructor"
"""
input instructor_aggregate_order_by {
  avg: instructor_avg_order_by
  count: order_by
  max: instructor_max_order_by
  min: instructor_min_order_by
  stddev: instructor_stddev_order_by
  stddev_pop: instructor_stddev_pop_order_by
  stddev_samp: instructor_stddev_samp_order_by
  sum: instructor_sum_order_by
  var_pop: instructor_var_pop_order_by
  var_samp: instructor_var_samp_order_by
  variance: instructor_variance_order_by
}

"""
input type for inserting array relation for remote table "instructor"
"""
input instructor_arr_rel_insert_input {
  data: [instructor_insert_input!]!
  on_conflict: instructor_on_conflict
}

"""aggregate avg on columns"""
type instructor_avg_fields {
  salary: Float
}

"""
order by avg() on columns of table "instructor"
"""
input instructor_avg_order_by {
  salary: order_by
}

"""
Boolean expression to filter rows from the table "instructor". All fields are combined with a logical 'AND'.
"""
input instructor_bool_exp {
  _and: [instructor_bool_exp]
  _not: instructor_bool_exp
  _or: [instructor_bool_exp]
  advisors: advisor_bool_exp
  department: department_bool_exp
  dept_name: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  salary: numeric_comparison_exp
  teaches: teaches_bool_exp
}

"""
unique or primary key constraints on table "instructor"
"""
enum instructor_constraint {
  """unique or primary key constraint"""
  idx_19903_sqlite_autoindex_instructor_1
}

"""
input type for incrementing integer column in table "instructor"
"""
input instructor_inc_input {
  salary: numeric
}

"""
input type for inserting data into table "instructor"
"""
input instructor_insert_input {
  advisors: advisor_arr_rel_insert_input
  department: department_obj_rel_insert_input
  dept_name: String
  id: String
  name: String
  salary: numeric
  teaches: teaches_arr_rel_insert_input
}

"""aggregate max on columns"""
type instructor_max_fields {
  dept_name: String
  id: String
  name: String
  salary: numeric
}

"""
order by max() on columns of table "instructor"
"""
input instructor_max_order_by {
  dept_name: order_by
  id: order_by
  name: order_by
  salary: order_by
}

"""aggregate min on columns"""
type instructor_min_fields {
  dept_name: String
  id: String
  name: String
  salary: numeric
}

"""
order by min() on columns of table "instructor"
"""
input instructor_min_order_by {
  dept_name: order_by
  id: order_by
  name: order_by
  salary: order_by
}

"""
response of any mutation on the table "instructor"
"""
type instructor_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [instructor!]!
}

"""
input type for inserting object relation for remote table "instructor"
"""
input instructor_obj_rel_insert_input {
  data: instructor_insert_input!
  on_conflict: instructor_on_conflict
}

"""
on conflict condition type for table "instructor"
"""
input instructor_on_conflict {
  constraint: instructor_constraint!
  update_columns: [instructor_update_column!]!
  where: instructor_bool_exp
}

"""
ordering options when selecting data from "instructor"
"""
input instructor_order_by {
  advisors_aggregate: advisor_aggregate_order_by
  department: department_order_by
  dept_name: order_by
  id: order_by
  name: order_by
  salary: order_by
  teaches_aggregate: teaches_aggregate_order_by
}

"""
select columns of table "instructor"
"""
enum instructor_select_column {
  """column name"""
  dept_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  salary
}

"""
input type for updating data in table "instructor"
"""
input instructor_set_input {
  dept_name: String
  id: String
  name: String
  salary: numeric
}

"""aggregate stddev on columns"""
type instructor_stddev_fields {
  salary: Float
}

"""
order by stddev() on columns of table "instructor"
"""
input instructor_stddev_order_by {
  salary: order_by
}

"""aggregate stddev_pop on columns"""
type instructor_stddev_pop_fields {
  salary: Float
}

"""
order by stddev_pop() on columns of table "instructor"
"""
input instructor_stddev_pop_order_by {
  salary: order_by
}

"""aggregate stddev_samp on columns"""
type instructor_stddev_samp_fields {
  salary: Float
}

"""
order by stddev_samp() on columns of table "instructor"
"""
input instructor_stddev_samp_order_by {
  salary: order_by
}

"""aggregate sum on columns"""
type instructor_sum_fields {
  salary: numeric
}

"""
order by sum() on columns of table "instructor"
"""
input instructor_sum_order_by {
  salary: order_by
}

"""
update columns of table "instructor"
"""
enum instructor_update_column {
  """column name"""
  dept_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  salary
}

"""aggregate var_pop on columns"""
type instructor_var_pop_fields {
  salary: Float
}

"""
order by var_pop() on columns of table "instructor"
"""
input instructor_var_pop_order_by {
  salary: order_by
}

"""aggregate var_samp on columns"""
type instructor_var_samp_fields {
  salary: Float
}

"""
order by var_samp() on columns of table "instructor"
"""
input instructor_var_samp_order_by {
  salary: order_by
}

"""aggregate variance on columns"""
type instructor_variance_fields {
  salary: Float
}

"""
order by variance() on columns of table "instructor"
"""
input instructor_variance_order_by {
  salary: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "advisor"
  """
  delete_advisor(
    """filter the rows which have to be deleted"""
    where: advisor_bool_exp!
  ): advisor_mutation_response

  """
  delete data from the table: "classroom"
  """
  delete_classroom(
    """filter the rows which have to be deleted"""
    where: classroom_bool_exp!
  ): classroom_mutation_response

  """
  delete single row from the table: "classroom"
  """
  delete_classroom_by_pk(building: String!, room_number: String!): classroom

  """
  delete data from the table: "course"
  """
  delete_course(
    """filter the rows which have to be deleted"""
    where: course_bool_exp!
  ): course_mutation_response

  """
  delete single row from the table: "course"
  """
  delete_course_by_pk(course_id: String!): course

  """
  delete data from the table: "department"
  """
  delete_department(
    """filter the rows which have to be deleted"""
    where: department_bool_exp!
  ): department_mutation_response

  """
  delete single row from the table: "department"
  """
  delete_department_by_pk(dept_name: String!): department

  """
  delete data from the table: "instructor"
  """
  delete_instructor(
    """filter the rows which have to be deleted"""
    where: instructor_bool_exp!
  ): instructor_mutation_response

  """
  delete data from the table: "prereq"
  """
  delete_prereq(
    """filter the rows which have to be deleted"""
    where: prereq_bool_exp!
  ): prereq_mutation_response

  """
  delete single row from the table: "prereq"
  """
  delete_prereq_by_pk(course_id: String!, prereq_id: String!): prereq

  """
  delete data from the table: "section"
  """
  delete_section(
    """filter the rows which have to be deleted"""
    where: section_bool_exp!
  ): section_mutation_response

  """
  delete single row from the table: "section"
  """
  delete_section_by_pk(course_id: String!, sec_id: String!, semester: String!, year: numeric!): section

  """
  delete data from the table: "student"
  """
  delete_student(
    """filter the rows which have to be deleted"""
    where: student_bool_exp!
  ): student_mutation_response

  """
  delete data from the table: "takes"
  """
  delete_takes(
    """filter the rows which have to be deleted"""
    where: takes_bool_exp!
  ): takes_mutation_response

  """
  delete data from the table: "teaches"
  """
  delete_teaches(
    """filter the rows which have to be deleted"""
    where: teaches_bool_exp!
  ): teaches_mutation_response

  """
  delete data from the table: "time_slot"
  """
  delete_time_slot(
    """filter the rows which have to be deleted"""
    where: time_slot_bool_exp!
  ): time_slot_mutation_response

  """
  delete single row from the table: "time_slot"
  """
  delete_time_slot_by_pk(day: String!, start_hr: numeric!, start_min: numeric!, time_slot_id: String!): time_slot

  """
  insert data into the table: "advisor"
  """
  insert_advisor(
    """the rows to be inserted"""
    objects: [advisor_insert_input!]!

    """on conflict condition"""
    on_conflict: advisor_on_conflict
  ): advisor_mutation_response

  """
  insert a single row into the table: "advisor"
  """
  insert_advisor_one(
    """the row to be inserted"""
    object: advisor_insert_input!

    """on conflict condition"""
    on_conflict: advisor_on_conflict
  ): advisor

  """
  insert data into the table: "classroom"
  """
  insert_classroom(
    """the rows to be inserted"""
    objects: [classroom_insert_input!]!

    """on conflict condition"""
    on_conflict: classroom_on_conflict
  ): classroom_mutation_response

  """
  insert a single row into the table: "classroom"
  """
  insert_classroom_one(
    """the row to be inserted"""
    object: classroom_insert_input!

    """on conflict condition"""
    on_conflict: classroom_on_conflict
  ): classroom

  """
  insert data into the table: "course"
  """
  insert_course(
    """the rows to be inserted"""
    objects: [course_insert_input!]!

    """on conflict condition"""
    on_conflict: course_on_conflict
  ): course_mutation_response

  """
  insert a single row into the table: "course"
  """
  insert_course_one(
    """the row to be inserted"""
    object: course_insert_input!

    """on conflict condition"""
    on_conflict: course_on_conflict
  ): course

  """
  insert data into the table: "department"
  """
  insert_department(
    """the rows to be inserted"""
    objects: [department_insert_input!]!

    """on conflict condition"""
    on_conflict: department_on_conflict
  ): department_mutation_response

  """
  insert a single row into the table: "department"
  """
  insert_department_one(
    """the row to be inserted"""
    object: department_insert_input!

    """on conflict condition"""
    on_conflict: department_on_conflict
  ): department

  """
  insert data into the table: "instructor"
  """
  insert_instructor(
    """the rows to be inserted"""
    objects: [instructor_insert_input!]!

    """on conflict condition"""
    on_conflict: instructor_on_conflict
  ): instructor_mutation_response

  """
  insert a single row into the table: "instructor"
  """
  insert_instructor_one(
    """the row to be inserted"""
    object: instructor_insert_input!

    """on conflict condition"""
    on_conflict: instructor_on_conflict
  ): instructor

  """
  insert data into the table: "prereq"
  """
  insert_prereq(
    """the rows to be inserted"""
    objects: [prereq_insert_input!]!

    """on conflict condition"""
    on_conflict: prereq_on_conflict
  ): prereq_mutation_response

  """
  insert a single row into the table: "prereq"
  """
  insert_prereq_one(
    """the row to be inserted"""
    object: prereq_insert_input!

    """on conflict condition"""
    on_conflict: prereq_on_conflict
  ): prereq

  """
  insert data into the table: "section"
  """
  insert_section(
    """the rows to be inserted"""
    objects: [section_insert_input!]!

    """on conflict condition"""
    on_conflict: section_on_conflict
  ): section_mutation_response

  """
  insert a single row into the table: "section"
  """
  insert_section_one(
    """the row to be inserted"""
    object: section_insert_input!

    """on conflict condition"""
    on_conflict: section_on_conflict
  ): section

  """
  insert data into the table: "student"
  """
  insert_student(
    """the rows to be inserted"""
    objects: [student_insert_input!]!

    """on conflict condition"""
    on_conflict: student_on_conflict
  ): student_mutation_response

  """
  insert a single row into the table: "student"
  """
  insert_student_one(
    """the row to be inserted"""
    object: student_insert_input!

    """on conflict condition"""
    on_conflict: student_on_conflict
  ): student

  """
  insert data into the table: "takes"
  """
  insert_takes(
    """the rows to be inserted"""
    objects: [takes_insert_input!]!

    """on conflict condition"""
    on_conflict: takes_on_conflict
  ): takes_mutation_response

  """
  insert a single row into the table: "takes"
  """
  insert_takes_one(
    """the row to be inserted"""
    object: takes_insert_input!

    """on conflict condition"""
    on_conflict: takes_on_conflict
  ): takes

  """
  insert data into the table: "teaches"
  """
  insert_teaches(
    """the rows to be inserted"""
    objects: [teaches_insert_input!]!

    """on conflict condition"""
    on_conflict: teaches_on_conflict
  ): teaches_mutation_response

  """
  insert a single row into the table: "teaches"
  """
  insert_teaches_one(
    """the row to be inserted"""
    object: teaches_insert_input!

    """on conflict condition"""
    on_conflict: teaches_on_conflict
  ): teaches

  """
  insert data into the table: "time_slot"
  """
  insert_time_slot(
    """the rows to be inserted"""
    objects: [time_slot_insert_input!]!

    """on conflict condition"""
    on_conflict: time_slot_on_conflict
  ): time_slot_mutation_response

  """
  insert a single row into the table: "time_slot"
  """
  insert_time_slot_one(
    """the row to be inserted"""
    object: time_slot_insert_input!

    """on conflict condition"""
    on_conflict: time_slot_on_conflict
  ): time_slot

  """
  update data of the table: "advisor"
  """
  update_advisor(
    """sets the columns of the filtered rows to the given values"""
    _set: advisor_set_input

    """filter the rows which have to be updated"""
    where: advisor_bool_exp!
  ): advisor_mutation_response

  """
  update data of the table: "classroom"
  """
  update_classroom(
    """increments the integer columns with given value of the filtered values"""
    _inc: classroom_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: classroom_set_input

    """filter the rows which have to be updated"""
    where: classroom_bool_exp!
  ): classroom_mutation_response

  """
  update single row of the table: "classroom"
  """
  update_classroom_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: classroom_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: classroom_set_input
    pk_columns: classroom_pk_columns_input!
  ): classroom

  """
  update data of the table: "course"
  """
  update_course(
    """increments the integer columns with given value of the filtered values"""
    _inc: course_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_set_input

    """filter the rows which have to be updated"""
    where: course_bool_exp!
  ): course_mutation_response

  """
  update single row of the table: "course"
  """
  update_course_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: course_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_set_input
    pk_columns: course_pk_columns_input!
  ): course

  """
  update data of the table: "department"
  """
  update_department(
    """increments the integer columns with given value of the filtered values"""
    _inc: department_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: department_set_input

    """filter the rows which have to be updated"""
    where: department_bool_exp!
  ): department_mutation_response

  """
  update single row of the table: "department"
  """
  update_department_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: department_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: department_set_input
    pk_columns: department_pk_columns_input!
  ): department

  """
  update data of the table: "instructor"
  """
  update_instructor(
    """increments the integer columns with given value of the filtered values"""
    _inc: instructor_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: instructor_set_input

    """filter the rows which have to be updated"""
    where: instructor_bool_exp!
  ): instructor_mutation_response

  """
  update data of the table: "prereq"
  """
  update_prereq(
    """sets the columns of the filtered rows to the given values"""
    _set: prereq_set_input

    """filter the rows which have to be updated"""
    where: prereq_bool_exp!
  ): prereq_mutation_response

  """
  update single row of the table: "prereq"
  """
  update_prereq_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: prereq_set_input
    pk_columns: prereq_pk_columns_input!
  ): prereq

  """
  update data of the table: "section"
  """
  update_section(
    """increments the integer columns with given value of the filtered values"""
    _inc: section_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: section_set_input

    """filter the rows which have to be updated"""
    where: section_bool_exp!
  ): section_mutation_response

  """
  update single row of the table: "section"
  """
  update_section_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: section_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: section_set_input
    pk_columns: section_pk_columns_input!
  ): section

  """
  update data of the table: "student"
  """
  update_student(
    """increments the integer columns with given value of the filtered values"""
    _inc: student_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: student_set_input

    """filter the rows which have to be updated"""
    where: student_bool_exp!
  ): student_mutation_response

  """
  update data of the table: "takes"
  """
  update_takes(
    """increments the integer columns with given value of the filtered values"""
    _inc: takes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: takes_set_input

    """filter the rows which have to be updated"""
    where: takes_bool_exp!
  ): takes_mutation_response

  """
  update data of the table: "teaches"
  """
  update_teaches(
    """increments the integer columns with given value of the filtered values"""
    _inc: teaches_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teaches_set_input

    """filter the rows which have to be updated"""
    where: teaches_bool_exp!
  ): teaches_mutation_response

  """
  update data of the table: "time_slot"
  """
  update_time_slot(
    """increments the integer columns with given value of the filtered values"""
    _inc: time_slot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: time_slot_set_input

    """filter the rows which have to be updated"""
    where: time_slot_bool_exp!
  ): time_slot_mutation_response

  """
  update single row of the table: "time_slot"
  """
  update_time_slot_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: time_slot_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: time_slot_set_input
    pk_columns: time_slot_pk_columns_input!
  ): time_slot
}

scalar numeric

"""
expression to compare columns of type numeric. All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "prereq"
"""
type prereq {
  """An object relationship"""
  course: course!

  """An object relationship"""
  courseByPrereqId: course!
  course_id: String!
  prereq_id: String!
}

"""
aggregated selection of "prereq"
"""
type prereq_aggregate {
  aggregate: prereq_aggregate_fields
  nodes: [prereq!]!
}

"""
aggregate fields of "prereq"
"""
type prereq_aggregate_fields {
  count(columns: [prereq_select_column!], distinct: Boolean): Int
  max: prereq_max_fields
  min: prereq_min_fields
}

"""
order by aggregate values of table "prereq"
"""
input prereq_aggregate_order_by {
  count: order_by
  max: prereq_max_order_by
  min: prereq_min_order_by
}

"""
input type for inserting array relation for remote table "prereq"
"""
input prereq_arr_rel_insert_input {
  data: [prereq_insert_input!]!
  on_conflict: prereq_on_conflict
}

"""
Boolean expression to filter rows from the table "prereq". All fields are combined with a logical 'AND'.
"""
input prereq_bool_exp {
  _and: [prereq_bool_exp]
  _not: prereq_bool_exp
  _or: [prereq_bool_exp]
  course: course_bool_exp
  courseByPrereqId: course_bool_exp
  course_id: String_comparison_exp
  prereq_id: String_comparison_exp
}

"""
unique or primary key constraints on table "prereq"
"""
enum prereq_constraint {
  """unique or primary key constraint"""
  idx_19945_sqlite_autoindex_prereq_1
}

"""
input type for inserting data into table "prereq"
"""
input prereq_insert_input {
  course: course_obj_rel_insert_input
  courseByPrereqId: course_obj_rel_insert_input
  course_id: String
  prereq_id: String
}

"""aggregate max on columns"""
type prereq_max_fields {
  course_id: String
  prereq_id: String
}

"""
order by max() on columns of table "prereq"
"""
input prereq_max_order_by {
  course_id: order_by
  prereq_id: order_by
}

"""aggregate min on columns"""
type prereq_min_fields {
  course_id: String
  prereq_id: String
}

"""
order by min() on columns of table "prereq"
"""
input prereq_min_order_by {
  course_id: order_by
  prereq_id: order_by
}

"""
response of any mutation on the table "prereq"
"""
type prereq_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [prereq!]!
}

"""
input type for inserting object relation for remote table "prereq"
"""
input prereq_obj_rel_insert_input {
  data: prereq_insert_input!
  on_conflict: prereq_on_conflict
}

"""
on conflict condition type for table "prereq"
"""
input prereq_on_conflict {
  constraint: prereq_constraint!
  update_columns: [prereq_update_column!]!
  where: prereq_bool_exp
}

"""
ordering options when selecting data from "prereq"
"""
input prereq_order_by {
  course: course_order_by
  courseByPrereqId: course_order_by
  course_id: order_by
  prereq_id: order_by
}

"""
primary key columns input for table: "prereq"
"""
input prereq_pk_columns_input {
  course_id: String!
  prereq_id: String!
}

"""
select columns of table "prereq"
"""
enum prereq_select_column {
  """column name"""
  course_id

  """column name"""
  prereq_id
}

"""
input type for updating data in table "prereq"
"""
input prereq_set_input {
  course_id: String
  prereq_id: String
}

"""
update columns of table "prereq"
"""
enum prereq_update_column {
  """column name"""
  course_id

  """column name"""
  prereq_id
}

"""query root"""
type query_root {
  """
  fetch data from the table: "advisor"
  """
  advisor(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): [advisor!]!

  """
  fetch aggregated fields from the table: "advisor"
  """
  advisor_aggregate(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): advisor_aggregate!

  """
  fetch data from the table: "classroom"
  """
  classroom(
    """distinct select on columns"""
    distinct_on: [classroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classroom_order_by!]

    """filter the rows returned"""
    where: classroom_bool_exp
  ): [classroom!]!

  """
  fetch aggregated fields from the table: "classroom"
  """
  classroom_aggregate(
    """distinct select on columns"""
    distinct_on: [classroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classroom_order_by!]

    """filter the rows returned"""
    where: classroom_bool_exp
  ): classroom_aggregate!

  """fetch data from the table: "classroom" using primary key columns"""
  classroom_by_pk(building: String!, room_number: String!): classroom

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  course_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """fetch data from the table: "course" using primary key columns"""
  course_by_pk(course_id: String!): course

  """
  fetch data from the table: "department"
  """
  department(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): [department!]!

  """
  fetch aggregated fields from the table: "department"
  """
  department_aggregate(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): department_aggregate!

  """fetch data from the table: "department" using primary key columns"""
  department_by_pk(dept_name: String!): department

  """
  fetch data from the table: "instructor"
  """
  instructor(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): [instructor!]!

  """
  fetch aggregated fields from the table: "instructor"
  """
  instructor_aggregate(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): instructor_aggregate!

  """
  fetch data from the table: "prereq"
  """
  prereq(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): [prereq!]!

  """
  fetch aggregated fields from the table: "prereq"
  """
  prereq_aggregate(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): prereq_aggregate!

  """fetch data from the table: "prereq" using primary key columns"""
  prereq_by_pk(course_id: String!, prereq_id: String!): prereq

  """
  fetch data from the table: "section"
  """
  section(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): [section!]!

  """
  fetch aggregated fields from the table: "section"
  """
  section_aggregate(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): section_aggregate!

  """fetch data from the table: "section" using primary key columns"""
  section_by_pk(course_id: String!, sec_id: String!, semester: String!, year: numeric!): section

  """
  fetch data from the table: "student"
  """
  student(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): [student!]!

  """
  fetch aggregated fields from the table: "student"
  """
  student_aggregate(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): student_aggregate!

  """
  fetch data from the table: "takes"
  """
  takes(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): [takes!]!

  """
  fetch aggregated fields from the table: "takes"
  """
  takes_aggregate(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): takes_aggregate!

  """
  fetch data from the table: "teaches"
  """
  teaches(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): [teaches!]!

  """
  fetch aggregated fields from the table: "teaches"
  """
  teaches_aggregate(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): teaches_aggregate!

  """
  fetch data from the table: "time_slot"
  """
  time_slot(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): [time_slot!]!

  """
  fetch aggregated fields from the table: "time_slot"
  """
  time_slot_aggregate(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): time_slot_aggregate!

  """fetch data from the table: "time_slot" using primary key columns"""
  time_slot_by_pk(day: String!, start_hr: numeric!, start_min: numeric!, time_slot_id: String!): time_slot
}

"""
columns and relationships of "section"
"""
type section {
  building: String

  """An object relationship"""
  classroom: classroom

  """An object relationship"""
  course: course!
  course_id: String!
  room_number: String
  sec_id: String!
  semester: String!

  """An array relationship"""
  takes(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): [takes!]!

  """An aggregated array relationship"""
  takes_aggregate(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): takes_aggregate!

  """An array relationship"""
  teaches(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): [teaches!]!

  """An aggregated array relationship"""
  teaches_aggregate(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): teaches_aggregate!
  time_slot_id: String

  """An array relationship"""
  time_slots(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): [time_slot!]!

  """An aggregated array relationship"""
  time_slots_aggregate(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): time_slot_aggregate!
  year: numeric!
}

"""
aggregated selection of "section"
"""
type section_aggregate {
  aggregate: section_aggregate_fields
  nodes: [section!]!
}

"""
aggregate fields of "section"
"""
type section_aggregate_fields {
  avg: section_avg_fields
  count(columns: [section_select_column!], distinct: Boolean): Int
  max: section_max_fields
  min: section_min_fields
  stddev: section_stddev_fields
  stddev_pop: section_stddev_pop_fields
  stddev_samp: section_stddev_samp_fields
  sum: section_sum_fields
  var_pop: section_var_pop_fields
  var_samp: section_var_samp_fields
  variance: section_variance_fields
}

"""
order by aggregate values of table "section"
"""
input section_aggregate_order_by {
  avg: section_avg_order_by
  count: order_by
  max: section_max_order_by
  min: section_min_order_by
  stddev: section_stddev_order_by
  stddev_pop: section_stddev_pop_order_by
  stddev_samp: section_stddev_samp_order_by
  sum: section_sum_order_by
  var_pop: section_var_pop_order_by
  var_samp: section_var_samp_order_by
  variance: section_variance_order_by
}

"""
input type for inserting array relation for remote table "section"
"""
input section_arr_rel_insert_input {
  data: [section_insert_input!]!
  on_conflict: section_on_conflict
}

"""aggregate avg on columns"""
type section_avg_fields {
  year: Float
}

"""
order by avg() on columns of table "section"
"""
input section_avg_order_by {
  year: order_by
}

"""
Boolean expression to filter rows from the table "section". All fields are combined with a logical 'AND'.
"""
input section_bool_exp {
  _and: [section_bool_exp]
  _not: section_bool_exp
  _or: [section_bool_exp]
  building: String_comparison_exp
  classroom: classroom_bool_exp
  course: course_bool_exp
  course_id: String_comparison_exp
  room_number: String_comparison_exp
  sec_id: String_comparison_exp
  semester: String_comparison_exp
  takes: takes_bool_exp
  teaches: teaches_bool_exp
  time_slot_id: String_comparison_exp
  time_slots: time_slot_bool_exp
  year: numeric_comparison_exp
}

"""
unique or primary key constraints on table "section"
"""
enum section_constraint {
  """unique or primary key constraint"""
  idx_19909_sqlite_autoindex_section_1
}

"""
input type for incrementing integer column in table "section"
"""
input section_inc_input {
  year: numeric
}

"""
input type for inserting data into table "section"
"""
input section_insert_input {
  building: String
  classroom: classroom_obj_rel_insert_input
  course: course_obj_rel_insert_input
  course_id: String
  room_number: String
  sec_id: String
  semester: String
  takes: takes_arr_rel_insert_input
  teaches: teaches_arr_rel_insert_input
  time_slot_id: String
  time_slots: time_slot_arr_rel_insert_input
  year: numeric
}

"""aggregate max on columns"""
type section_max_fields {
  building: String
  course_id: String
  room_number: String
  sec_id: String
  semester: String
  time_slot_id: String
  year: numeric
}

"""
order by max() on columns of table "section"
"""
input section_max_order_by {
  building: order_by
  course_id: order_by
  room_number: order_by
  sec_id: order_by
  semester: order_by
  time_slot_id: order_by
  year: order_by
}

"""aggregate min on columns"""
type section_min_fields {
  building: String
  course_id: String
  room_number: String
  sec_id: String
  semester: String
  time_slot_id: String
  year: numeric
}

"""
order by min() on columns of table "section"
"""
input section_min_order_by {
  building: order_by
  course_id: order_by
  room_number: order_by
  sec_id: order_by
  semester: order_by
  time_slot_id: order_by
  year: order_by
}

"""
response of any mutation on the table "section"
"""
type section_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [section!]!
}

"""
input type for inserting object relation for remote table "section"
"""
input section_obj_rel_insert_input {
  data: section_insert_input!
  on_conflict: section_on_conflict
}

"""
on conflict condition type for table "section"
"""
input section_on_conflict {
  constraint: section_constraint!
  update_columns: [section_update_column!]!
  where: section_bool_exp
}

"""
ordering options when selecting data from "section"
"""
input section_order_by {
  building: order_by
  classroom: classroom_order_by
  course: course_order_by
  course_id: order_by
  room_number: order_by
  sec_id: order_by
  semester: order_by
  takes_aggregate: takes_aggregate_order_by
  teaches_aggregate: teaches_aggregate_order_by
  time_slot_id: order_by
  time_slots_aggregate: time_slot_aggregate_order_by
  year: order_by
}

"""
primary key columns input for table: "section"
"""
input section_pk_columns_input {
  course_id: String!
  sec_id: String!
  semester: String!
  year: numeric!
}

"""
select columns of table "section"
"""
enum section_select_column {
  """column name"""
  building

  """column name"""
  course_id

  """column name"""
  room_number

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  time_slot_id

  """column name"""
  year
}

"""
input type for updating data in table "section"
"""
input section_set_input {
  building: String
  course_id: String
  room_number: String
  sec_id: String
  semester: String
  time_slot_id: String
  year: numeric
}

"""aggregate stddev on columns"""
type section_stddev_fields {
  year: Float
}

"""
order by stddev() on columns of table "section"
"""
input section_stddev_order_by {
  year: order_by
}

"""aggregate stddev_pop on columns"""
type section_stddev_pop_fields {
  year: Float
}

"""
order by stddev_pop() on columns of table "section"
"""
input section_stddev_pop_order_by {
  year: order_by
}

"""aggregate stddev_samp on columns"""
type section_stddev_samp_fields {
  year: Float
}

"""
order by stddev_samp() on columns of table "section"
"""
input section_stddev_samp_order_by {
  year: order_by
}

"""aggregate sum on columns"""
type section_sum_fields {
  year: numeric
}

"""
order by sum() on columns of table "section"
"""
input section_sum_order_by {
  year: order_by
}

"""
update columns of table "section"
"""
enum section_update_column {
  """column name"""
  building

  """column name"""
  course_id

  """column name"""
  room_number

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  time_slot_id

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type section_var_pop_fields {
  year: Float
}

"""
order by var_pop() on columns of table "section"
"""
input section_var_pop_order_by {
  year: order_by
}

"""aggregate var_samp on columns"""
type section_var_samp_fields {
  year: Float
}

"""
order by var_samp() on columns of table "section"
"""
input section_var_samp_order_by {
  year: order_by
}

"""aggregate variance on columns"""
type section_variance_fields {
  year: Float
}

"""
order by variance() on columns of table "section"
"""
input section_variance_order_by {
  year: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""
columns and relationships of "student"
"""
type student {
  """An array relationship"""
  advisors(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): [advisor!]!

  """An aggregated array relationship"""
  advisors_aggregate(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): advisor_aggregate!

  """An object relationship"""
  department: department
  dept_name: String
  id: String
  name: String

  """An array relationship"""
  takes(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): [takes!]!

  """An aggregated array relationship"""
  takes_aggregate(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): takes_aggregate!
  tot_cred: numeric
}

"""
aggregated selection of "student"
"""
type student_aggregate {
  aggregate: student_aggregate_fields
  nodes: [student!]!
}

"""
aggregate fields of "student"
"""
type student_aggregate_fields {
  avg: student_avg_fields
  count(columns: [student_select_column!], distinct: Boolean): Int
  max: student_max_fields
  min: student_min_fields
  stddev: student_stddev_fields
  stddev_pop: student_stddev_pop_fields
  stddev_samp: student_stddev_samp_fields
  sum: student_sum_fields
  var_pop: student_var_pop_fields
  var_samp: student_var_samp_fields
  variance: student_variance_fields
}

"""
order by aggregate values of table "student"
"""
input student_aggregate_order_by {
  avg: student_avg_order_by
  count: order_by
  max: student_max_order_by
  min: student_min_order_by
  stddev: student_stddev_order_by
  stddev_pop: student_stddev_pop_order_by
  stddev_samp: student_stddev_samp_order_by
  sum: student_sum_order_by
  var_pop: student_var_pop_order_by
  var_samp: student_var_samp_order_by
  variance: student_variance_order_by
}

"""
input type for inserting array relation for remote table "student"
"""
input student_arr_rel_insert_input {
  data: [student_insert_input!]!
  on_conflict: student_on_conflict
}

"""aggregate avg on columns"""
type student_avg_fields {
  tot_cred: Float
}

"""
order by avg() on columns of table "student"
"""
input student_avg_order_by {
  tot_cred: order_by
}

"""
Boolean expression to filter rows from the table "student". All fields are combined with a logical 'AND'.
"""
input student_bool_exp {
  _and: [student_bool_exp]
  _not: student_bool_exp
  _or: [student_bool_exp]
  advisors: advisor_bool_exp
  department: department_bool_exp
  dept_name: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  takes: takes_bool_exp
  tot_cred: numeric_comparison_exp
}

"""
unique or primary key constraints on table "student"
"""
enum student_constraint {
  """unique or primary key constraint"""
  idx_19921_sqlite_autoindex_student_1
}

"""
input type for incrementing integer column in table "student"
"""
input student_inc_input {
  tot_cred: numeric
}

"""
input type for inserting data into table "student"
"""
input student_insert_input {
  advisors: advisor_arr_rel_insert_input
  department: department_obj_rel_insert_input
  dept_name: String
  id: String
  name: String
  takes: takes_arr_rel_insert_input
  tot_cred: numeric
}

"""aggregate max on columns"""
type student_max_fields {
  dept_name: String
  id: String
  name: String
  tot_cred: numeric
}

"""
order by max() on columns of table "student"
"""
input student_max_order_by {
  dept_name: order_by
  id: order_by
  name: order_by
  tot_cred: order_by
}

"""aggregate min on columns"""
type student_min_fields {
  dept_name: String
  id: String
  name: String
  tot_cred: numeric
}

"""
order by min() on columns of table "student"
"""
input student_min_order_by {
  dept_name: order_by
  id: order_by
  name: order_by
  tot_cred: order_by
}

"""
response of any mutation on the table "student"
"""
type student_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [student!]!
}

"""
input type for inserting object relation for remote table "student"
"""
input student_obj_rel_insert_input {
  data: student_insert_input!
  on_conflict: student_on_conflict
}

"""
on conflict condition type for table "student"
"""
input student_on_conflict {
  constraint: student_constraint!
  update_columns: [student_update_column!]!
  where: student_bool_exp
}

"""
ordering options when selecting data from "student"
"""
input student_order_by {
  advisors_aggregate: advisor_aggregate_order_by
  department: department_order_by
  dept_name: order_by
  id: order_by
  name: order_by
  takes_aggregate: takes_aggregate_order_by
  tot_cred: order_by
}

"""
select columns of table "student"
"""
enum student_select_column {
  """column name"""
  dept_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tot_cred
}

"""
input type for updating data in table "student"
"""
input student_set_input {
  dept_name: String
  id: String
  name: String
  tot_cred: numeric
}

"""aggregate stddev on columns"""
type student_stddev_fields {
  tot_cred: Float
}

"""
order by stddev() on columns of table "student"
"""
input student_stddev_order_by {
  tot_cred: order_by
}

"""aggregate stddev_pop on columns"""
type student_stddev_pop_fields {
  tot_cred: Float
}

"""
order by stddev_pop() on columns of table "student"
"""
input student_stddev_pop_order_by {
  tot_cred: order_by
}

"""aggregate stddev_samp on columns"""
type student_stddev_samp_fields {
  tot_cred: Float
}

"""
order by stddev_samp() on columns of table "student"
"""
input student_stddev_samp_order_by {
  tot_cred: order_by
}

"""aggregate sum on columns"""
type student_sum_fields {
  tot_cred: numeric
}

"""
order by sum() on columns of table "student"
"""
input student_sum_order_by {
  tot_cred: order_by
}

"""
update columns of table "student"
"""
enum student_update_column {
  """column name"""
  dept_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tot_cred
}

"""aggregate var_pop on columns"""
type student_var_pop_fields {
  tot_cred: Float
}

"""
order by var_pop() on columns of table "student"
"""
input student_var_pop_order_by {
  tot_cred: order_by
}

"""aggregate var_samp on columns"""
type student_var_samp_fields {
  tot_cred: Float
}

"""
order by var_samp() on columns of table "student"
"""
input student_var_samp_order_by {
  tot_cred: order_by
}

"""aggregate variance on columns"""
type student_variance_fields {
  tot_cred: Float
}

"""
order by variance() on columns of table "student"
"""
input student_variance_order_by {
  tot_cred: order_by
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "advisor"
  """
  advisor(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): [advisor!]!

  """
  fetch aggregated fields from the table: "advisor"
  """
  advisor_aggregate(
    """distinct select on columns"""
    distinct_on: [advisor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [advisor_order_by!]

    """filter the rows returned"""
    where: advisor_bool_exp
  ): advisor_aggregate!

  """
  fetch data from the table: "classroom"
  """
  classroom(
    """distinct select on columns"""
    distinct_on: [classroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classroom_order_by!]

    """filter the rows returned"""
    where: classroom_bool_exp
  ): [classroom!]!

  """
  fetch aggregated fields from the table: "classroom"
  """
  classroom_aggregate(
    """distinct select on columns"""
    distinct_on: [classroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classroom_order_by!]

    """filter the rows returned"""
    where: classroom_bool_exp
  ): classroom_aggregate!

  """fetch data from the table: "classroom" using primary key columns"""
  classroom_by_pk(building: String!, room_number: String!): classroom

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  course_aggregate(
    """distinct select on columns"""
    distinct_on: [course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_order_by!]

    """filter the rows returned"""
    where: course_bool_exp
  ): course_aggregate!

  """fetch data from the table: "course" using primary key columns"""
  course_by_pk(course_id: String!): course

  """
  fetch data from the table: "department"
  """
  department(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): [department!]!

  """
  fetch aggregated fields from the table: "department"
  """
  department_aggregate(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): department_aggregate!

  """fetch data from the table: "department" using primary key columns"""
  department_by_pk(dept_name: String!): department

  """
  fetch data from the table: "instructor"
  """
  instructor(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): [instructor!]!

  """
  fetch aggregated fields from the table: "instructor"
  """
  instructor_aggregate(
    """distinct select on columns"""
    distinct_on: [instructor_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instructor_order_by!]

    """filter the rows returned"""
    where: instructor_bool_exp
  ): instructor_aggregate!

  """
  fetch data from the table: "prereq"
  """
  prereq(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): [prereq!]!

  """
  fetch aggregated fields from the table: "prereq"
  """
  prereq_aggregate(
    """distinct select on columns"""
    distinct_on: [prereq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prereq_order_by!]

    """filter the rows returned"""
    where: prereq_bool_exp
  ): prereq_aggregate!

  """fetch data from the table: "prereq" using primary key columns"""
  prereq_by_pk(course_id: String!, prereq_id: String!): prereq

  """
  fetch data from the table: "section"
  """
  section(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): [section!]!

  """
  fetch aggregated fields from the table: "section"
  """
  section_aggregate(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): section_aggregate!

  """fetch data from the table: "section" using primary key columns"""
  section_by_pk(course_id: String!, sec_id: String!, semester: String!, year: numeric!): section

  """
  fetch data from the table: "student"
  """
  student(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): [student!]!

  """
  fetch aggregated fields from the table: "student"
  """
  student_aggregate(
    """distinct select on columns"""
    distinct_on: [student_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [student_order_by!]

    """filter the rows returned"""
    where: student_bool_exp
  ): student_aggregate!

  """
  fetch data from the table: "takes"
  """
  takes(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): [takes!]!

  """
  fetch aggregated fields from the table: "takes"
  """
  takes_aggregate(
    """distinct select on columns"""
    distinct_on: [takes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [takes_order_by!]

    """filter the rows returned"""
    where: takes_bool_exp
  ): takes_aggregate!

  """
  fetch data from the table: "teaches"
  """
  teaches(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): [teaches!]!

  """
  fetch aggregated fields from the table: "teaches"
  """
  teaches_aggregate(
    """distinct select on columns"""
    distinct_on: [teaches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teaches_order_by!]

    """filter the rows returned"""
    where: teaches_bool_exp
  ): teaches_aggregate!

  """
  fetch data from the table: "time_slot"
  """
  time_slot(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): [time_slot!]!

  """
  fetch aggregated fields from the table: "time_slot"
  """
  time_slot_aggregate(
    """distinct select on columns"""
    distinct_on: [time_slot_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [time_slot_order_by!]

    """filter the rows returned"""
    where: time_slot_bool_exp
  ): time_slot_aggregate!

  """fetch data from the table: "time_slot" using primary key columns"""
  time_slot_by_pk(day: String!, start_hr: numeric!, start_min: numeric!, time_slot_id: String!): time_slot
}

"""
columns and relationships of "takes"
"""
type takes {
  """An object relationship"""
  course: course
  course_id: String
  grade: String
  id: String
  sec_id: String

  """An object relationship"""
  section: section
  semester: String

  """An object relationship"""
  student: student
  year: numeric
}

"""
aggregated selection of "takes"
"""
type takes_aggregate {
  aggregate: takes_aggregate_fields
  nodes: [takes!]!
}

"""
aggregate fields of "takes"
"""
type takes_aggregate_fields {
  avg: takes_avg_fields
  count(columns: [takes_select_column!], distinct: Boolean): Int
  max: takes_max_fields
  min: takes_min_fields
  stddev: takes_stddev_fields
  stddev_pop: takes_stddev_pop_fields
  stddev_samp: takes_stddev_samp_fields
  sum: takes_sum_fields
  var_pop: takes_var_pop_fields
  var_samp: takes_var_samp_fields
  variance: takes_variance_fields
}

"""
order by aggregate values of table "takes"
"""
input takes_aggregate_order_by {
  avg: takes_avg_order_by
  count: order_by
  max: takes_max_order_by
  min: takes_min_order_by
  stddev: takes_stddev_order_by
  stddev_pop: takes_stddev_pop_order_by
  stddev_samp: takes_stddev_samp_order_by
  sum: takes_sum_order_by
  var_pop: takes_var_pop_order_by
  var_samp: takes_var_samp_order_by
  variance: takes_variance_order_by
}

"""
input type for inserting array relation for remote table "takes"
"""
input takes_arr_rel_insert_input {
  data: [takes_insert_input!]!
  on_conflict: takes_on_conflict
}

"""aggregate avg on columns"""
type takes_avg_fields {
  year: Float
}

"""
order by avg() on columns of table "takes"
"""
input takes_avg_order_by {
  year: order_by
}

"""
Boolean expression to filter rows from the table "takes". All fields are combined with a logical 'AND'.
"""
input takes_bool_exp {
  _and: [takes_bool_exp]
  _not: takes_bool_exp
  _or: [takes_bool_exp]
  course: course_bool_exp
  course_id: String_comparison_exp
  grade: String_comparison_exp
  id: String_comparison_exp
  sec_id: String_comparison_exp
  section: section_bool_exp
  semester: String_comparison_exp
  student: student_bool_exp
  year: numeric_comparison_exp
}

"""
unique or primary key constraints on table "takes"
"""
enum takes_constraint {
  """unique or primary key constraint"""
  idx_19927_sqlite_autoindex_takes_1
}

"""
input type for incrementing integer column in table "takes"
"""
input takes_inc_input {
  year: numeric
}

"""
input type for inserting data into table "takes"
"""
input takes_insert_input {
  course: course_obj_rel_insert_input
  course_id: String
  grade: String
  id: String
  sec_id: String
  section: section_obj_rel_insert_input
  semester: String
  student: student_obj_rel_insert_input
  year: numeric
}

"""aggregate max on columns"""
type takes_max_fields {
  course_id: String
  grade: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""
order by max() on columns of table "takes"
"""
input takes_max_order_by {
  course_id: order_by
  grade: order_by
  id: order_by
  sec_id: order_by
  semester: order_by
  year: order_by
}

"""aggregate min on columns"""
type takes_min_fields {
  course_id: String
  grade: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""
order by min() on columns of table "takes"
"""
input takes_min_order_by {
  course_id: order_by
  grade: order_by
  id: order_by
  sec_id: order_by
  semester: order_by
  year: order_by
}

"""
response of any mutation on the table "takes"
"""
type takes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [takes!]!
}

"""
input type for inserting object relation for remote table "takes"
"""
input takes_obj_rel_insert_input {
  data: takes_insert_input!
  on_conflict: takes_on_conflict
}

"""
on conflict condition type for table "takes"
"""
input takes_on_conflict {
  constraint: takes_constraint!
  update_columns: [takes_update_column!]!
  where: takes_bool_exp
}

"""
ordering options when selecting data from "takes"
"""
input takes_order_by {
  course: course_order_by
  course_id: order_by
  grade: order_by
  id: order_by
  sec_id: order_by
  section: section_order_by
  semester: order_by
  student: student_order_by
  year: order_by
}

"""
select columns of table "takes"
"""
enum takes_select_column {
  """column name"""
  course_id

  """column name"""
  grade

  """column name"""
  id

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  year
}

"""
input type for updating data in table "takes"
"""
input takes_set_input {
  course_id: String
  grade: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""aggregate stddev on columns"""
type takes_stddev_fields {
  year: Float
}

"""
order by stddev() on columns of table "takes"
"""
input takes_stddev_order_by {
  year: order_by
}

"""aggregate stddev_pop on columns"""
type takes_stddev_pop_fields {
  year: Float
}

"""
order by stddev_pop() on columns of table "takes"
"""
input takes_stddev_pop_order_by {
  year: order_by
}

"""aggregate stddev_samp on columns"""
type takes_stddev_samp_fields {
  year: Float
}

"""
order by stddev_samp() on columns of table "takes"
"""
input takes_stddev_samp_order_by {
  year: order_by
}

"""aggregate sum on columns"""
type takes_sum_fields {
  year: numeric
}

"""
order by sum() on columns of table "takes"
"""
input takes_sum_order_by {
  year: order_by
}

"""
update columns of table "takes"
"""
enum takes_update_column {
  """column name"""
  course_id

  """column name"""
  grade

  """column name"""
  id

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type takes_var_pop_fields {
  year: Float
}

"""
order by var_pop() on columns of table "takes"
"""
input takes_var_pop_order_by {
  year: order_by
}

"""aggregate var_samp on columns"""
type takes_var_samp_fields {
  year: Float
}

"""
order by var_samp() on columns of table "takes"
"""
input takes_var_samp_order_by {
  year: order_by
}

"""aggregate variance on columns"""
type takes_variance_fields {
  year: Float
}

"""
order by variance() on columns of table "takes"
"""
input takes_variance_order_by {
  year: order_by
}

"""
columns and relationships of "teaches"
"""
type teaches {
  """An object relationship"""
  course: course
  course_id: String
  id: String

  """An object relationship"""
  instructor: instructor
  sec_id: String

  """An object relationship"""
  section: section
  semester: String
  year: numeric
}

"""
aggregated selection of "teaches"
"""
type teaches_aggregate {
  aggregate: teaches_aggregate_fields
  nodes: [teaches!]!
}

"""
aggregate fields of "teaches"
"""
type teaches_aggregate_fields {
  avg: teaches_avg_fields
  count(columns: [teaches_select_column!], distinct: Boolean): Int
  max: teaches_max_fields
  min: teaches_min_fields
  stddev: teaches_stddev_fields
  stddev_pop: teaches_stddev_pop_fields
  stddev_samp: teaches_stddev_samp_fields
  sum: teaches_sum_fields
  var_pop: teaches_var_pop_fields
  var_samp: teaches_var_samp_fields
  variance: teaches_variance_fields
}

"""
order by aggregate values of table "teaches"
"""
input teaches_aggregate_order_by {
  avg: teaches_avg_order_by
  count: order_by
  max: teaches_max_order_by
  min: teaches_min_order_by
  stddev: teaches_stddev_order_by
  stddev_pop: teaches_stddev_pop_order_by
  stddev_samp: teaches_stddev_samp_order_by
  sum: teaches_sum_order_by
  var_pop: teaches_var_pop_order_by
  var_samp: teaches_var_samp_order_by
  variance: teaches_variance_order_by
}

"""
input type for inserting array relation for remote table "teaches"
"""
input teaches_arr_rel_insert_input {
  data: [teaches_insert_input!]!
  on_conflict: teaches_on_conflict
}

"""aggregate avg on columns"""
type teaches_avg_fields {
  year: Float
}

"""
order by avg() on columns of table "teaches"
"""
input teaches_avg_order_by {
  year: order_by
}

"""
Boolean expression to filter rows from the table "teaches". All fields are combined with a logical 'AND'.
"""
input teaches_bool_exp {
  _and: [teaches_bool_exp]
  _not: teaches_bool_exp
  _or: [teaches_bool_exp]
  course: course_bool_exp
  course_id: String_comparison_exp
  id: String_comparison_exp
  instructor: instructor_bool_exp
  sec_id: String_comparison_exp
  section: section_bool_exp
  semester: String_comparison_exp
  year: numeric_comparison_exp
}

"""
unique or primary key constraints on table "teaches"
"""
enum teaches_constraint {
  """unique or primary key constraint"""
  idx_19915_sqlite_autoindex_teaches_1
}

"""
input type for incrementing integer column in table "teaches"
"""
input teaches_inc_input {
  year: numeric
}

"""
input type for inserting data into table "teaches"
"""
input teaches_insert_input {
  course: course_obj_rel_insert_input
  course_id: String
  id: String
  instructor: instructor_obj_rel_insert_input
  sec_id: String
  section: section_obj_rel_insert_input
  semester: String
  year: numeric
}

"""aggregate max on columns"""
type teaches_max_fields {
  course_id: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""
order by max() on columns of table "teaches"
"""
input teaches_max_order_by {
  course_id: order_by
  id: order_by
  sec_id: order_by
  semester: order_by
  year: order_by
}

"""aggregate min on columns"""
type teaches_min_fields {
  course_id: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""
order by min() on columns of table "teaches"
"""
input teaches_min_order_by {
  course_id: order_by
  id: order_by
  sec_id: order_by
  semester: order_by
  year: order_by
}

"""
response of any mutation on the table "teaches"
"""
type teaches_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [teaches!]!
}

"""
input type for inserting object relation for remote table "teaches"
"""
input teaches_obj_rel_insert_input {
  data: teaches_insert_input!
  on_conflict: teaches_on_conflict
}

"""
on conflict condition type for table "teaches"
"""
input teaches_on_conflict {
  constraint: teaches_constraint!
  update_columns: [teaches_update_column!]!
  where: teaches_bool_exp
}

"""
ordering options when selecting data from "teaches"
"""
input teaches_order_by {
  course: course_order_by
  course_id: order_by
  id: order_by
  instructor: instructor_order_by
  sec_id: order_by
  section: section_order_by
  semester: order_by
  year: order_by
}

"""
select columns of table "teaches"
"""
enum teaches_select_column {
  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  year
}

"""
input type for updating data in table "teaches"
"""
input teaches_set_input {
  course_id: String
  id: String
  sec_id: String
  semester: String
  year: numeric
}

"""aggregate stddev on columns"""
type teaches_stddev_fields {
  year: Float
}

"""
order by stddev() on columns of table "teaches"
"""
input teaches_stddev_order_by {
  year: order_by
}

"""aggregate stddev_pop on columns"""
type teaches_stddev_pop_fields {
  year: Float
}

"""
order by stddev_pop() on columns of table "teaches"
"""
input teaches_stddev_pop_order_by {
  year: order_by
}

"""aggregate stddev_samp on columns"""
type teaches_stddev_samp_fields {
  year: Float
}

"""
order by stddev_samp() on columns of table "teaches"
"""
input teaches_stddev_samp_order_by {
  year: order_by
}

"""aggregate sum on columns"""
type teaches_sum_fields {
  year: numeric
}

"""
order by sum() on columns of table "teaches"
"""
input teaches_sum_order_by {
  year: order_by
}

"""
update columns of table "teaches"
"""
enum teaches_update_column {
  """column name"""
  course_id

  """column name"""
  id

  """column name"""
  sec_id

  """column name"""
  semester

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type teaches_var_pop_fields {
  year: Float
}

"""
order by var_pop() on columns of table "teaches"
"""
input teaches_var_pop_order_by {
  year: order_by
}

"""aggregate var_samp on columns"""
type teaches_var_samp_fields {
  year: Float
}

"""
order by var_samp() on columns of table "teaches"
"""
input teaches_var_samp_order_by {
  year: order_by
}

"""aggregate variance on columns"""
type teaches_variance_fields {
  year: Float
}

"""
order by variance() on columns of table "teaches"
"""
input teaches_variance_order_by {
  year: order_by
}

"""
columns and relationships of "time_slot"
"""
type time_slot {
  day: String!
  end_hr: numeric
  end_min: numeric

  """An array relationship"""
  sections(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): [section!]!

  """An aggregated array relationship"""
  sections_aggregate(
    """distinct select on columns"""
    distinct_on: [section_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [section_order_by!]

    """filter the rows returned"""
    where: section_bool_exp
  ): section_aggregate!
  start_hr: numeric!
  start_min: numeric!
  time_slot_id: String!
}

"""
aggregated selection of "time_slot"
"""
type time_slot_aggregate {
  aggregate: time_slot_aggregate_fields
  nodes: [time_slot!]!
}

"""
aggregate fields of "time_slot"
"""
type time_slot_aggregate_fields {
  avg: time_slot_avg_fields
  count(columns: [time_slot_select_column!], distinct: Boolean): Int
  max: time_slot_max_fields
  min: time_slot_min_fields
  stddev: time_slot_stddev_fields
  stddev_pop: time_slot_stddev_pop_fields
  stddev_samp: time_slot_stddev_samp_fields
  sum: time_slot_sum_fields
  var_pop: time_slot_var_pop_fields
  var_samp: time_slot_var_samp_fields
  variance: time_slot_variance_fields
}

"""
order by aggregate values of table "time_slot"
"""
input time_slot_aggregate_order_by {
  avg: time_slot_avg_order_by
  count: order_by
  max: time_slot_max_order_by
  min: time_slot_min_order_by
  stddev: time_slot_stddev_order_by
  stddev_pop: time_slot_stddev_pop_order_by
  stddev_samp: time_slot_stddev_samp_order_by
  sum: time_slot_sum_order_by
  var_pop: time_slot_var_pop_order_by
  var_samp: time_slot_var_samp_order_by
  variance: time_slot_variance_order_by
}

"""
input type for inserting array relation for remote table "time_slot"
"""
input time_slot_arr_rel_insert_input {
  data: [time_slot_insert_input!]!
  on_conflict: time_slot_on_conflict
}

"""aggregate avg on columns"""
type time_slot_avg_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by avg() on columns of table "time_slot"
"""
input time_slot_avg_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""
Boolean expression to filter rows from the table "time_slot". All fields are combined with a logical 'AND'.
"""
input time_slot_bool_exp {
  _and: [time_slot_bool_exp]
  _not: time_slot_bool_exp
  _or: [time_slot_bool_exp]
  day: String_comparison_exp
  end_hr: numeric_comparison_exp
  end_min: numeric_comparison_exp
  sections: section_bool_exp
  start_hr: numeric_comparison_exp
  start_min: numeric_comparison_exp
  time_slot_id: String_comparison_exp
}

"""
unique or primary key constraints on table "time_slot"
"""
enum time_slot_constraint {
  """unique or primary key constraint"""
  idx_19939_sqlite_autoindex_time_slot_1
}

"""
input type for incrementing integer column in table "time_slot"
"""
input time_slot_inc_input {
  end_hr: numeric
  end_min: numeric
  start_hr: numeric
  start_min: numeric
}

"""
input type for inserting data into table "time_slot"
"""
input time_slot_insert_input {
  day: String
  end_hr: numeric
  end_min: numeric
  sections: section_arr_rel_insert_input
  start_hr: numeric
  start_min: numeric
  time_slot_id: String
}

"""aggregate max on columns"""
type time_slot_max_fields {
  day: String
  end_hr: numeric
  end_min: numeric
  start_hr: numeric
  start_min: numeric
  time_slot_id: String
}

"""
order by max() on columns of table "time_slot"
"""
input time_slot_max_order_by {
  day: order_by
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
  time_slot_id: order_by
}

"""aggregate min on columns"""
type time_slot_min_fields {
  day: String
  end_hr: numeric
  end_min: numeric
  start_hr: numeric
  start_min: numeric
  time_slot_id: String
}

"""
order by min() on columns of table "time_slot"
"""
input time_slot_min_order_by {
  day: order_by
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
  time_slot_id: order_by
}

"""
response of any mutation on the table "time_slot"
"""
type time_slot_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [time_slot!]!
}

"""
input type for inserting object relation for remote table "time_slot"
"""
input time_slot_obj_rel_insert_input {
  data: time_slot_insert_input!
  on_conflict: time_slot_on_conflict
}

"""
on conflict condition type for table "time_slot"
"""
input time_slot_on_conflict {
  constraint: time_slot_constraint!
  update_columns: [time_slot_update_column!]!
  where: time_slot_bool_exp
}

"""
ordering options when selecting data from "time_slot"
"""
input time_slot_order_by {
  day: order_by
  end_hr: order_by
  end_min: order_by
  sections_aggregate: section_aggregate_order_by
  start_hr: order_by
  start_min: order_by
  time_slot_id: order_by
}

"""
primary key columns input for table: "time_slot"
"""
input time_slot_pk_columns_input {
  day: String!
  start_hr: numeric!
  start_min: numeric!
  time_slot_id: String!
}

"""
select columns of table "time_slot"
"""
enum time_slot_select_column {
  """column name"""
  day

  """column name"""
  end_hr

  """column name"""
  end_min

  """column name"""
  start_hr

  """column name"""
  start_min

  """column name"""
  time_slot_id
}

"""
input type for updating data in table "time_slot"
"""
input time_slot_set_input {
  day: String
  end_hr: numeric
  end_min: numeric
  start_hr: numeric
  start_min: numeric
  time_slot_id: String
}

"""aggregate stddev on columns"""
type time_slot_stddev_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by stddev() on columns of table "time_slot"
"""
input time_slot_stddev_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""aggregate stddev_pop on columns"""
type time_slot_stddev_pop_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by stddev_pop() on columns of table "time_slot"
"""
input time_slot_stddev_pop_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""aggregate stddev_samp on columns"""
type time_slot_stddev_samp_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by stddev_samp() on columns of table "time_slot"
"""
input time_slot_stddev_samp_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""aggregate sum on columns"""
type time_slot_sum_fields {
  end_hr: numeric
  end_min: numeric
  start_hr: numeric
  start_min: numeric
}

"""
order by sum() on columns of table "time_slot"
"""
input time_slot_sum_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""
update columns of table "time_slot"
"""
enum time_slot_update_column {
  """column name"""
  day

  """column name"""
  end_hr

  """column name"""
  end_min

  """column name"""
  start_hr

  """column name"""
  start_min

  """column name"""
  time_slot_id
}

"""aggregate var_pop on columns"""
type time_slot_var_pop_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by var_pop() on columns of table "time_slot"
"""
input time_slot_var_pop_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""aggregate var_samp on columns"""
type time_slot_var_samp_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by var_samp() on columns of table "time_slot"
"""
input time_slot_var_samp_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}

"""aggregate variance on columns"""
type time_slot_variance_fields {
  end_hr: Float
  end_min: Float
  start_hr: Float
  start_min: Float
}

"""
order by variance() on columns of table "time_slot"
"""
input time_slot_variance_order_by {
  end_hr: order_by
  end_min: order_by
  start_hr: order_by
  start_min: order_by
}
