schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "business"
"""
type business {
  bid: Int!
  business_id: String
  city: String
  full_address: String
  is_open: Int
  latitude: String
  longitude: String
  name: String
  rating: Float
  review_count: Int
  state: String
}

"""
aggregated selection of "business"
"""
type business_aggregate {
  aggregate: business_aggregate_fields
  nodes: [business!]!
}

"""
aggregate fields of "business"
"""
type business_aggregate_fields {
  avg: business_avg_fields
  count(columns: [business_select_column!], distinct: Boolean): Int
  max: business_max_fields
  min: business_min_fields
  stddev: business_stddev_fields
  stddev_pop: business_stddev_pop_fields
  stddev_samp: business_stddev_samp_fields
  sum: business_sum_fields
  var_pop: business_var_pop_fields
  var_samp: business_var_samp_fields
  variance: business_variance_fields
}

"""
order by aggregate values of table "business"
"""
input business_aggregate_order_by {
  avg: business_avg_order_by
  count: order_by
  max: business_max_order_by
  min: business_min_order_by
  stddev: business_stddev_order_by
  stddev_pop: business_stddev_pop_order_by
  stddev_samp: business_stddev_samp_order_by
  sum: business_sum_order_by
  var_pop: business_var_pop_order_by
  var_samp: business_var_samp_order_by
  variance: business_variance_order_by
}

"""
input type for inserting array relation for remote table "business"
"""
input business_arr_rel_insert_input {
  data: [business_insert_input!]!
  on_conflict: business_on_conflict
}

"""aggregate avg on columns"""
type business_avg_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by avg() on columns of table "business"
"""
input business_avg_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""
Boolean expression to filter rows from the table "business". All fields are combined with a logical 'AND'.
"""
input business_bool_exp {
  _and: [business_bool_exp]
  _not: business_bool_exp
  _or: [business_bool_exp]
  bid: Int_comparison_exp
  business_id: String_comparison_exp
  city: String_comparison_exp
  full_address: String_comparison_exp
  is_open: Int_comparison_exp
  latitude: String_comparison_exp
  longitude: String_comparison_exp
  name: String_comparison_exp
  rating: Float_comparison_exp
  review_count: Int_comparison_exp
  state: String_comparison_exp
}

"""
unique or primary key constraints on table "business"
"""
enum business_constraint {
  """unique or primary key constraint"""
  idx_20269_sqlite_autoindex_business_1
}

"""
input type for incrementing integer column in table "business"
"""
input business_inc_input {
  bid: Int
  is_open: Int
  rating: Float
  review_count: Int
}

"""
input type for inserting data into table "business"
"""
input business_insert_input {
  bid: Int
  business_id: String
  city: String
  full_address: String
  is_open: Int
  latitude: String
  longitude: String
  name: String
  rating: Float
  review_count: Int
  state: String
}

"""aggregate max on columns"""
type business_max_fields {
  bid: Int
  business_id: String
  city: String
  full_address: String
  is_open: Int
  latitude: String
  longitude: String
  name: String
  rating: Float
  review_count: Int
  state: String
}

"""
order by max() on columns of table "business"
"""
input business_max_order_by {
  bid: order_by
  business_id: order_by
  city: order_by
  full_address: order_by
  is_open: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  rating: order_by
  review_count: order_by
  state: order_by
}

"""aggregate min on columns"""
type business_min_fields {
  bid: Int
  business_id: String
  city: String
  full_address: String
  is_open: Int
  latitude: String
  longitude: String
  name: String
  rating: Float
  review_count: Int
  state: String
}

"""
order by min() on columns of table "business"
"""
input business_min_order_by {
  bid: order_by
  business_id: order_by
  city: order_by
  full_address: order_by
  is_open: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  rating: order_by
  review_count: order_by
  state: order_by
}

"""
response of any mutation on the table "business"
"""
type business_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [business!]!
}

"""
input type for inserting object relation for remote table "business"
"""
input business_obj_rel_insert_input {
  data: business_insert_input!
  on_conflict: business_on_conflict
}

"""
on conflict condition type for table "business"
"""
input business_on_conflict {
  constraint: business_constraint!
  update_columns: [business_update_column!]!
  where: business_bool_exp
}

"""
ordering options when selecting data from "business"
"""
input business_order_by {
  bid: order_by
  business_id: order_by
  city: order_by
  full_address: order_by
  is_open: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  rating: order_by
  review_count: order_by
  state: order_by
}

"""
primary key columns input for table: "business"
"""
input business_pk_columns_input {
  bid: Int!
}

"""
select columns of table "business"
"""
enum business_select_column {
  """column name"""
  bid

  """column name"""
  business_id

  """column name"""
  city

  """column name"""
  full_address

  """column name"""
  is_open

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  name

  """column name"""
  rating

  """column name"""
  review_count

  """column name"""
  state
}

"""
input type for updating data in table "business"
"""
input business_set_input {
  bid: Int
  business_id: String
  city: String
  full_address: String
  is_open: Int
  latitude: String
  longitude: String
  name: String
  rating: Float
  review_count: Int
  state: String
}

"""aggregate stddev on columns"""
type business_stddev_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by stddev() on columns of table "business"
"""
input business_stddev_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""aggregate stddev_pop on columns"""
type business_stddev_pop_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by stddev_pop() on columns of table "business"
"""
input business_stddev_pop_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""aggregate stddev_samp on columns"""
type business_stddev_samp_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by stddev_samp() on columns of table "business"
"""
input business_stddev_samp_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""aggregate sum on columns"""
type business_sum_fields {
  bid: Int
  is_open: Int
  rating: Float
  review_count: Int
}

"""
order by sum() on columns of table "business"
"""
input business_sum_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""
update columns of table "business"
"""
enum business_update_column {
  """column name"""
  bid

  """column name"""
  business_id

  """column name"""
  city

  """column name"""
  full_address

  """column name"""
  is_open

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  name

  """column name"""
  rating

  """column name"""
  review_count

  """column name"""
  state
}

"""aggregate var_pop on columns"""
type business_var_pop_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by var_pop() on columns of table "business"
"""
input business_var_pop_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""aggregate var_samp on columns"""
type business_var_samp_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by var_samp() on columns of table "business"
"""
input business_var_samp_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""aggregate variance on columns"""
type business_variance_fields {
  bid: Float
  is_open: Float
  rating: Float
  review_count: Float
}

"""
order by variance() on columns of table "business"
"""
input business_variance_order_by {
  bid: order_by
  is_open: order_by
  rating: order_by
  review_count: order_by
}

"""
columns and relationships of "category"
"""
type category {
  business_id: String
  category_name: String
  id: Int!
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  avg: category_avg_fields
  count(columns: [category_select_column!], distinct: Boolean): Int
  max: category_max_fields
  min: category_min_fields
  stddev: category_stddev_fields
  stddev_pop: category_stddev_pop_fields
  stddev_samp: category_stddev_samp_fields
  sum: category_sum_fields
  var_pop: category_var_pop_fields
  var_samp: category_var_samp_fields
  variance: category_variance_fields
}

"""
order by aggregate values of table "category"
"""
input category_aggregate_order_by {
  avg: category_avg_order_by
  count: order_by
  max: category_max_order_by
  min: category_min_order_by
  stddev: category_stddev_order_by
  stddev_pop: category_stddev_pop_order_by
  stddev_samp: category_stddev_samp_order_by
  sum: category_sum_order_by
  var_pop: category_var_pop_order_by
  var_samp: category_var_samp_order_by
  variance: category_variance_order_by
}

"""
input type for inserting array relation for remote table "category"
"""
input category_arr_rel_insert_input {
  data: [category_insert_input!]!
  on_conflict: category_on_conflict
}

"""aggregate avg on columns"""
type category_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "category"
"""
input category_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp]
  _not: category_bool_exp
  _or: [category_bool_exp]
  business_id: String_comparison_exp
  category_name: String_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """unique or primary key constraint"""
  idx_20275_sqlite_autoindex_category_1
}

"""
input type for incrementing integer column in table "category"
"""
input category_inc_input {
  id: Int
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  business_id: String
  category_name: String
  id: Int
}

"""aggregate max on columns"""
type category_max_fields {
  business_id: String
  category_name: String
  id: Int
}

"""
order by max() on columns of table "category"
"""
input category_max_order_by {
  business_id: order_by
  category_name: order_by
  id: order_by
}

"""aggregate min on columns"""
type category_min_fields {
  business_id: String
  category_name: String
  id: Int
}

"""
order by min() on columns of table "category"
"""
input category_min_order_by {
  business_id: order_by
  category_name: order_by
  id: order_by
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input category_obj_rel_insert_input {
  data: category_insert_input!
  on_conflict: category_on_conflict
}

"""
on conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]!
  where: category_bool_exp
}

"""
ordering options when selecting data from "category"
"""
input category_order_by {
  business_id: order_by
  category_name: order_by
  id: order_by
}

"""
primary key columns input for table: "category"
"""
input category_pk_columns_input {
  id: Int!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """column name"""
  business_id

  """column name"""
  category_name

  """column name"""
  id
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  business_id: String
  category_name: String
  id: Int
}

"""aggregate stddev on columns"""
type category_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "category"
"""
input category_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type category_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "category"
"""
input category_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type category_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "category"
"""
input category_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type category_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "category"
"""
input category_sum_order_by {
  id: order_by
}

"""
update columns of table "category"
"""
enum category_update_column {
  """column name"""
  business_id

  """column name"""
  category_name

  """column name"""
  id
}

"""aggregate var_pop on columns"""
type category_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "category"
"""
input category_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type category_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "category"
"""
input category_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type category_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "category"
"""
input category_variance_order_by {
  id: order_by
}

"""
columns and relationships of "checkin"
"""
type checkin {
  business_id: String
  cid: Int!
  count: Int
  day: String
}

"""
aggregated selection of "checkin"
"""
type checkin_aggregate {
  aggregate: checkin_aggregate_fields
  nodes: [checkin!]!
}

"""
aggregate fields of "checkin"
"""
type checkin_aggregate_fields {
  avg: checkin_avg_fields
  count(columns: [checkin_select_column!], distinct: Boolean): Int
  max: checkin_max_fields
  min: checkin_min_fields
  stddev: checkin_stddev_fields
  stddev_pop: checkin_stddev_pop_fields
  stddev_samp: checkin_stddev_samp_fields
  sum: checkin_sum_fields
  var_pop: checkin_var_pop_fields
  var_samp: checkin_var_samp_fields
  variance: checkin_variance_fields
}

"""
order by aggregate values of table "checkin"
"""
input checkin_aggregate_order_by {
  avg: checkin_avg_order_by
  count: order_by
  max: checkin_max_order_by
  min: checkin_min_order_by
  stddev: checkin_stddev_order_by
  stddev_pop: checkin_stddev_pop_order_by
  stddev_samp: checkin_stddev_samp_order_by
  sum: checkin_sum_order_by
  var_pop: checkin_var_pop_order_by
  var_samp: checkin_var_samp_order_by
  variance: checkin_variance_order_by
}

"""
input type for inserting array relation for remote table "checkin"
"""
input checkin_arr_rel_insert_input {
  data: [checkin_insert_input!]!
  on_conflict: checkin_on_conflict
}

"""aggregate avg on columns"""
type checkin_avg_fields {
  cid: Float
  count: Float
}

"""
order by avg() on columns of table "checkin"
"""
input checkin_avg_order_by {
  cid: order_by
  count: order_by
}

"""
Boolean expression to filter rows from the table "checkin". All fields are combined with a logical 'AND'.
"""
input checkin_bool_exp {
  _and: [checkin_bool_exp]
  _not: checkin_bool_exp
  _or: [checkin_bool_exp]
  business_id: String_comparison_exp
  cid: Int_comparison_exp
  count: Int_comparison_exp
  day: String_comparison_exp
}

"""
unique or primary key constraints on table "checkin"
"""
enum checkin_constraint {
  """unique or primary key constraint"""
  idx_20287_sqlite_autoindex_checkin_1
}

"""
input type for incrementing integer column in table "checkin"
"""
input checkin_inc_input {
  cid: Int
  count: Int
}

"""
input type for inserting data into table "checkin"
"""
input checkin_insert_input {
  business_id: String
  cid: Int
  count: Int
  day: String
}

"""aggregate max on columns"""
type checkin_max_fields {
  business_id: String
  cid: Int
  count: Int
  day: String
}

"""
order by max() on columns of table "checkin"
"""
input checkin_max_order_by {
  business_id: order_by
  cid: order_by
  count: order_by
  day: order_by
}

"""aggregate min on columns"""
type checkin_min_fields {
  business_id: String
  cid: Int
  count: Int
  day: String
}

"""
order by min() on columns of table "checkin"
"""
input checkin_min_order_by {
  business_id: order_by
  cid: order_by
  count: order_by
  day: order_by
}

"""
response of any mutation on the table "checkin"
"""
type checkin_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [checkin!]!
}

"""
input type for inserting object relation for remote table "checkin"
"""
input checkin_obj_rel_insert_input {
  data: checkin_insert_input!
  on_conflict: checkin_on_conflict
}

"""
on conflict condition type for table "checkin"
"""
input checkin_on_conflict {
  constraint: checkin_constraint!
  update_columns: [checkin_update_column!]!
  where: checkin_bool_exp
}

"""
ordering options when selecting data from "checkin"
"""
input checkin_order_by {
  business_id: order_by
  cid: order_by
  count: order_by
  day: order_by
}

"""
primary key columns input for table: "checkin"
"""
input checkin_pk_columns_input {
  cid: Int!
}

"""
select columns of table "checkin"
"""
enum checkin_select_column {
  """column name"""
  business_id

  """column name"""
  cid

  """column name"""
  count

  """column name"""
  day
}

"""
input type for updating data in table "checkin"
"""
input checkin_set_input {
  business_id: String
  cid: Int
  count: Int
  day: String
}

"""aggregate stddev on columns"""
type checkin_stddev_fields {
  cid: Float
  count: Float
}

"""
order by stddev() on columns of table "checkin"
"""
input checkin_stddev_order_by {
  cid: order_by
  count: order_by
}

"""aggregate stddev_pop on columns"""
type checkin_stddev_pop_fields {
  cid: Float
  count: Float
}

"""
order by stddev_pop() on columns of table "checkin"
"""
input checkin_stddev_pop_order_by {
  cid: order_by
  count: order_by
}

"""aggregate stddev_samp on columns"""
type checkin_stddev_samp_fields {
  cid: Float
  count: Float
}

"""
order by stddev_samp() on columns of table "checkin"
"""
input checkin_stddev_samp_order_by {
  cid: order_by
  count: order_by
}

"""aggregate sum on columns"""
type checkin_sum_fields {
  cid: Int
  count: Int
}

"""
order by sum() on columns of table "checkin"
"""
input checkin_sum_order_by {
  cid: order_by
  count: order_by
}

"""
update columns of table "checkin"
"""
enum checkin_update_column {
  """column name"""
  business_id

  """column name"""
  cid

  """column name"""
  count

  """column name"""
  day
}

"""aggregate var_pop on columns"""
type checkin_var_pop_fields {
  cid: Float
  count: Float
}

"""
order by var_pop() on columns of table "checkin"
"""
input checkin_var_pop_order_by {
  cid: order_by
  count: order_by
}

"""aggregate var_samp on columns"""
type checkin_var_samp_fields {
  cid: Float
  count: Float
}

"""
order by var_samp() on columns of table "checkin"
"""
input checkin_var_samp_order_by {
  cid: order_by
  count: order_by
}

"""aggregate variance on columns"""
type checkin_variance_fields {
  cid: Float
  count: Float
}

"""
order by variance() on columns of table "checkin"
"""
input checkin_variance_order_by {
  cid: order_by
  count: order_by
}

"""
expression to compare columns of type Float. All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "business"
  """
  delete_business(
    """filter the rows which have to be deleted"""
    where: business_bool_exp!
  ): business_mutation_response

  """
  delete single row from the table: "business"
  """
  delete_business_by_pk(bid: Int!): business

  """
  delete data from the table: "category"
  """
  delete_category(
    """filter the rows which have to be deleted"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(id: Int!): category

  """
  delete data from the table: "checkin"
  """
  delete_checkin(
    """filter the rows which have to be deleted"""
    where: checkin_bool_exp!
  ): checkin_mutation_response

  """
  delete single row from the table: "checkin"
  """
  delete_checkin_by_pk(cid: Int!): checkin

  """
  delete data from the table: "neighbourhood"
  """
  delete_neighbourhood(
    """filter the rows which have to be deleted"""
    where: neighbourhood_bool_exp!
  ): neighbourhood_mutation_response

  """
  delete single row from the table: "neighbourhood"
  """
  delete_neighbourhood_by_pk(id: Int!): neighbourhood

  """
  delete data from the table: "review"
  """
  delete_review(
    """filter the rows which have to be deleted"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  delete single row from the table: "review"
  """
  delete_review_by_pk(rid: Int!): review

  """
  delete data from the table: "tip"
  """
  delete_tip(
    """filter the rows which have to be deleted"""
    where: tip_bool_exp!
  ): tip_mutation_response

  """
  delete single row from the table: "tip"
  """
  delete_tip_by_pk(tip_id: Int!): tip

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(uid: Int!): user

  """
  insert data into the table: "business"
  """
  insert_business(
    """the rows to be inserted"""
    objects: [business_insert_input!]!

    """on conflict condition"""
    on_conflict: business_on_conflict
  ): business_mutation_response

  """
  insert a single row into the table: "business"
  """
  insert_business_one(
    """the row to be inserted"""
    object: business_insert_input!

    """on conflict condition"""
    on_conflict: business_on_conflict
  ): business

  """
  insert data into the table: "category"
  """
  insert_category(
    """the rows to be inserted"""
    objects: [category_insert_input!]!

    """on conflict condition"""
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """the row to be inserted"""
    object: category_insert_input!

    """on conflict condition"""
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "checkin"
  """
  insert_checkin(
    """the rows to be inserted"""
    objects: [checkin_insert_input!]!

    """on conflict condition"""
    on_conflict: checkin_on_conflict
  ): checkin_mutation_response

  """
  insert a single row into the table: "checkin"
  """
  insert_checkin_one(
    """the row to be inserted"""
    object: checkin_insert_input!

    """on conflict condition"""
    on_conflict: checkin_on_conflict
  ): checkin

  """
  insert data into the table: "neighbourhood"
  """
  insert_neighbourhood(
    """the rows to be inserted"""
    objects: [neighbourhood_insert_input!]!

    """on conflict condition"""
    on_conflict: neighbourhood_on_conflict
  ): neighbourhood_mutation_response

  """
  insert a single row into the table: "neighbourhood"
  """
  insert_neighbourhood_one(
    """the row to be inserted"""
    object: neighbourhood_insert_input!

    """on conflict condition"""
    on_conflict: neighbourhood_on_conflict
  ): neighbourhood

  """
  insert data into the table: "review"
  """
  insert_review(
    """the rows to be inserted"""
    objects: [review_insert_input!]!

    """on conflict condition"""
    on_conflict: review_on_conflict
  ): review_mutation_response

  """
  insert a single row into the table: "review"
  """
  insert_review_one(
    """the row to be inserted"""
    object: review_insert_input!

    """on conflict condition"""
    on_conflict: review_on_conflict
  ): review

  """
  insert data into the table: "tip"
  """
  insert_tip(
    """the rows to be inserted"""
    objects: [tip_insert_input!]!

    """on conflict condition"""
    on_conflict: tip_on_conflict
  ): tip_mutation_response

  """
  insert a single row into the table: "tip"
  """
  insert_tip_one(
    """the row to be inserted"""
    object: tip_insert_input!

    """on conflict condition"""
    on_conflict: tip_on_conflict
  ): tip

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "business"
  """
  update_business(
    """increments the integer columns with given value of the filtered values"""
    _inc: business_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: business_set_input

    """filter the rows which have to be updated"""
    where: business_bool_exp!
  ): business_mutation_response

  """
  update single row of the table: "business"
  """
  update_business_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: business_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: business_set_input
    pk_columns: business_pk_columns_input!
  ): business

  """
  update data of the table: "category"
  """
  update_category(
    """increments the integer columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input

    """filter the rows which have to be updated"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update data of the table: "checkin"
  """
  update_checkin(
    """increments the integer columns with given value of the filtered values"""
    _inc: checkin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: checkin_set_input

    """filter the rows which have to be updated"""
    where: checkin_bool_exp!
  ): checkin_mutation_response

  """
  update single row of the table: "checkin"
  """
  update_checkin_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: checkin_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: checkin_set_input
    pk_columns: checkin_pk_columns_input!
  ): checkin

  """
  update data of the table: "neighbourhood"
  """
  update_neighbourhood(
    """increments the integer columns with given value of the filtered values"""
    _inc: neighbourhood_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighbourhood_set_input

    """filter the rows which have to be updated"""
    where: neighbourhood_bool_exp!
  ): neighbourhood_mutation_response

  """
  update single row of the table: "neighbourhood"
  """
  update_neighbourhood_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: neighbourhood_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighbourhood_set_input
    pk_columns: neighbourhood_pk_columns_input!
  ): neighbourhood

  """
  update data of the table: "review"
  """
  update_review(
    """increments the integer columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input

    """filter the rows which have to be updated"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  update single row of the table: "review"
  """
  update_review_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  """
  update data of the table: "tip"
  """
  update_tip(
    """increments the integer columns with given value of the filtered values"""
    _inc: tip_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tip_set_input

    """filter the rows which have to be updated"""
    where: tip_bool_exp!
  ): tip_mutation_response

  """
  update single row of the table: "tip"
  """
  update_tip_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: tip_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tip_set_input
    pk_columns: tip_pk_columns_input!
  ): tip

  """
  update data of the table: "user"
  """
  update_user(
    """increments the integer columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user
}

"""
columns and relationships of "neighbourhood"
"""
type neighbourhood {
  business_id: String
  id: Int!
  neighbourhood_name: String
}

"""
aggregated selection of "neighbourhood"
"""
type neighbourhood_aggregate {
  aggregate: neighbourhood_aggregate_fields
  nodes: [neighbourhood!]!
}

"""
aggregate fields of "neighbourhood"
"""
type neighbourhood_aggregate_fields {
  avg: neighbourhood_avg_fields
  count(columns: [neighbourhood_select_column!], distinct: Boolean): Int
  max: neighbourhood_max_fields
  min: neighbourhood_min_fields
  stddev: neighbourhood_stddev_fields
  stddev_pop: neighbourhood_stddev_pop_fields
  stddev_samp: neighbourhood_stddev_samp_fields
  sum: neighbourhood_sum_fields
  var_pop: neighbourhood_var_pop_fields
  var_samp: neighbourhood_var_samp_fields
  variance: neighbourhood_variance_fields
}

"""
order by aggregate values of table "neighbourhood"
"""
input neighbourhood_aggregate_order_by {
  avg: neighbourhood_avg_order_by
  count: order_by
  max: neighbourhood_max_order_by
  min: neighbourhood_min_order_by
  stddev: neighbourhood_stddev_order_by
  stddev_pop: neighbourhood_stddev_pop_order_by
  stddev_samp: neighbourhood_stddev_samp_order_by
  sum: neighbourhood_sum_order_by
  var_pop: neighbourhood_var_pop_order_by
  var_samp: neighbourhood_var_samp_order_by
  variance: neighbourhood_variance_order_by
}

"""
input type for inserting array relation for remote table "neighbourhood"
"""
input neighbourhood_arr_rel_insert_input {
  data: [neighbourhood_insert_input!]!
  on_conflict: neighbourhood_on_conflict
}

"""aggregate avg on columns"""
type neighbourhood_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "neighbourhood"
"""
input neighbourhood_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "neighbourhood". All fields are combined with a logical 'AND'.
"""
input neighbourhood_bool_exp {
  _and: [neighbourhood_bool_exp]
  _not: neighbourhood_bool_exp
  _or: [neighbourhood_bool_exp]
  business_id: String_comparison_exp
  id: Int_comparison_exp
  neighbourhood_name: String_comparison_exp
}

"""
unique or primary key constraints on table "neighbourhood"
"""
enum neighbourhood_constraint {
  """unique or primary key constraint"""
  idx_20293_sqlite_autoindex_neighbourhood_1
}

"""
input type for incrementing integer column in table "neighbourhood"
"""
input neighbourhood_inc_input {
  id: Int
}

"""
input type for inserting data into table "neighbourhood"
"""
input neighbourhood_insert_input {
  business_id: String
  id: Int
  neighbourhood_name: String
}

"""aggregate max on columns"""
type neighbourhood_max_fields {
  business_id: String
  id: Int
  neighbourhood_name: String
}

"""
order by max() on columns of table "neighbourhood"
"""
input neighbourhood_max_order_by {
  business_id: order_by
  id: order_by
  neighbourhood_name: order_by
}

"""aggregate min on columns"""
type neighbourhood_min_fields {
  business_id: String
  id: Int
  neighbourhood_name: String
}

"""
order by min() on columns of table "neighbourhood"
"""
input neighbourhood_min_order_by {
  business_id: order_by
  id: order_by
  neighbourhood_name: order_by
}

"""
response of any mutation on the table "neighbourhood"
"""
type neighbourhood_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [neighbourhood!]!
}

"""
input type for inserting object relation for remote table "neighbourhood"
"""
input neighbourhood_obj_rel_insert_input {
  data: neighbourhood_insert_input!
  on_conflict: neighbourhood_on_conflict
}

"""
on conflict condition type for table "neighbourhood"
"""
input neighbourhood_on_conflict {
  constraint: neighbourhood_constraint!
  update_columns: [neighbourhood_update_column!]!
  where: neighbourhood_bool_exp
}

"""
ordering options when selecting data from "neighbourhood"
"""
input neighbourhood_order_by {
  business_id: order_by
  id: order_by
  neighbourhood_name: order_by
}

"""
primary key columns input for table: "neighbourhood"
"""
input neighbourhood_pk_columns_input {
  id: Int!
}

"""
select columns of table "neighbourhood"
"""
enum neighbourhood_select_column {
  """column name"""
  business_id

  """column name"""
  id

  """column name"""
  neighbourhood_name
}

"""
input type for updating data in table "neighbourhood"
"""
input neighbourhood_set_input {
  business_id: String
  id: Int
  neighbourhood_name: String
}

"""aggregate stddev on columns"""
type neighbourhood_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "neighbourhood"
"""
input neighbourhood_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type neighbourhood_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "neighbourhood"
"""
input neighbourhood_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type neighbourhood_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "neighbourhood"
"""
input neighbourhood_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type neighbourhood_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "neighbourhood"
"""
input neighbourhood_sum_order_by {
  id: order_by
}

"""
update columns of table "neighbourhood"
"""
enum neighbourhood_update_column {
  """column name"""
  business_id

  """column name"""
  id

  """column name"""
  neighbourhood_name
}

"""aggregate var_pop on columns"""
type neighbourhood_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "neighbourhood"
"""
input neighbourhood_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type neighbourhood_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "neighbourhood"
"""
input neighbourhood_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type neighbourhood_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "neighbourhood"
"""
input neighbourhood_variance_order_by {
  id: order_by
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""query root"""
type query_root {
  """
  fetch data from the table: "business"
  """
  business(
    """distinct select on columns"""
    distinct_on: [business_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [business_order_by!]

    """filter the rows returned"""
    where: business_bool_exp
  ): [business!]!

  """
  fetch aggregated fields from the table: "business"
  """
  business_aggregate(
    """distinct select on columns"""
    distinct_on: [business_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [business_order_by!]

    """filter the rows returned"""
    where: business_bool_exp
  ): business_aggregate!

  """fetch data from the table: "business" using primary key columns"""
  business_by_pk(bid: Int!): business

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: Int!): category

  """
  fetch data from the table: "checkin"
  """
  checkin(
    """distinct select on columns"""
    distinct_on: [checkin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkin_order_by!]

    """filter the rows returned"""
    where: checkin_bool_exp
  ): [checkin!]!

  """
  fetch aggregated fields from the table: "checkin"
  """
  checkin_aggregate(
    """distinct select on columns"""
    distinct_on: [checkin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkin_order_by!]

    """filter the rows returned"""
    where: checkin_bool_exp
  ): checkin_aggregate!

  """fetch data from the table: "checkin" using primary key columns"""
  checkin_by_pk(cid: Int!): checkin

  """
  fetch data from the table: "neighbourhood"
  """
  neighbourhood(
    """distinct select on columns"""
    distinct_on: [neighbourhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighbourhood_order_by!]

    """filter the rows returned"""
    where: neighbourhood_bool_exp
  ): [neighbourhood!]!

  """
  fetch aggregated fields from the table: "neighbourhood"
  """
  neighbourhood_aggregate(
    """distinct select on columns"""
    distinct_on: [neighbourhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighbourhood_order_by!]

    """filter the rows returned"""
    where: neighbourhood_bool_exp
  ): neighbourhood_aggregate!

  """fetch data from the table: "neighbourhood" using primary key columns"""
  neighbourhood_by_pk(id: Int!): neighbourhood

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(rid: Int!): review

  """
  fetch data from the table: "tip"
  """
  tip(
    """distinct select on columns"""
    distinct_on: [tip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tip_order_by!]

    """filter the rows returned"""
    where: tip_bool_exp
  ): [tip!]!

  """
  fetch aggregated fields from the table: "tip"
  """
  tip_aggregate(
    """distinct select on columns"""
    distinct_on: [tip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tip_order_by!]

    """filter the rows returned"""
    where: tip_bool_exp
  ): tip_aggregate!

  """fetch data from the table: "tip" using primary key columns"""
  tip_by_pk(tip_id: Int!): tip

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(uid: Int!): user
}

"""
columns and relationships of "review"
"""
type review {
  business_id: String
  month: String
  rating: Float
  rid: Int!
  text: String
  user_id: String
  year: Int
}

"""
aggregated selection of "review"
"""
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

"""
aggregate fields of "review"
"""
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

"""
order by aggregate values of table "review"
"""
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

"""
input type for inserting array relation for remote table "review"
"""
input review_arr_rel_insert_input {
  data: [review_insert_input!]!
  on_conflict: review_on_conflict
}

"""aggregate avg on columns"""
type review_avg_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by avg() on columns of table "review"
"""
input review_avg_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""
Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
"""
input review_bool_exp {
  _and: [review_bool_exp]
  _not: review_bool_exp
  _or: [review_bool_exp]
  business_id: String_comparison_exp
  month: String_comparison_exp
  rating: Float_comparison_exp
  rid: Int_comparison_exp
  text: String_comparison_exp
  user_id: String_comparison_exp
  year: Int_comparison_exp
}

"""
unique or primary key constraints on table "review"
"""
enum review_constraint {
  """unique or primary key constraint"""
  idx_20299_sqlite_autoindex_review_1
}

"""
input type for incrementing integer column in table "review"
"""
input review_inc_input {
  rating: Float
  rid: Int
  year: Int
}

"""
input type for inserting data into table "review"
"""
input review_insert_input {
  business_id: String
  month: String
  rating: Float
  rid: Int
  text: String
  user_id: String
  year: Int
}

"""aggregate max on columns"""
type review_max_fields {
  business_id: String
  month: String
  rating: Float
  rid: Int
  text: String
  user_id: String
  year: Int
}

"""
order by max() on columns of table "review"
"""
input review_max_order_by {
  business_id: order_by
  month: order_by
  rating: order_by
  rid: order_by
  text: order_by
  user_id: order_by
  year: order_by
}

"""aggregate min on columns"""
type review_min_fields {
  business_id: String
  month: String
  rating: Float
  rid: Int
  text: String
  user_id: String
  year: Int
}

"""
order by min() on columns of table "review"
"""
input review_min_order_by {
  business_id: order_by
  month: order_by
  rating: order_by
  rid: order_by
  text: order_by
  user_id: order_by
  year: order_by
}

"""
response of any mutation on the table "review"
"""
type review_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [review!]!
}

"""
input type for inserting object relation for remote table "review"
"""
input review_obj_rel_insert_input {
  data: review_insert_input!
  on_conflict: review_on_conflict
}

"""
on conflict condition type for table "review"
"""
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]!
  where: review_bool_exp
}

"""
ordering options when selecting data from "review"
"""
input review_order_by {
  business_id: order_by
  month: order_by
  rating: order_by
  rid: order_by
  text: order_by
  user_id: order_by
  year: order_by
}

"""
primary key columns input for table: "review"
"""
input review_pk_columns_input {
  rid: Int!
}

"""
select columns of table "review"
"""
enum review_select_column {
  """column name"""
  business_id

  """column name"""
  month

  """column name"""
  rating

  """column name"""
  rid

  """column name"""
  text

  """column name"""
  user_id

  """column name"""
  year
}

"""
input type for updating data in table "review"
"""
input review_set_input {
  business_id: String
  month: String
  rating: Float
  rid: Int
  text: String
  user_id: String
  year: Int
}

"""aggregate stddev on columns"""
type review_stddev_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by stddev() on columns of table "review"
"""
input review_stddev_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""aggregate stddev_pop on columns"""
type review_stddev_pop_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by stddev_pop() on columns of table "review"
"""
input review_stddev_pop_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""aggregate stddev_samp on columns"""
type review_stddev_samp_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by stddev_samp() on columns of table "review"
"""
input review_stddev_samp_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""aggregate sum on columns"""
type review_sum_fields {
  rating: Float
  rid: Int
  year: Int
}

"""
order by sum() on columns of table "review"
"""
input review_sum_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""
update columns of table "review"
"""
enum review_update_column {
  """column name"""
  business_id

  """column name"""
  month

  """column name"""
  rating

  """column name"""
  rid

  """column name"""
  text

  """column name"""
  user_id

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type review_var_pop_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by var_pop() on columns of table "review"
"""
input review_var_pop_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""aggregate var_samp on columns"""
type review_var_samp_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by var_samp() on columns of table "review"
"""
input review_var_samp_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""aggregate variance on columns"""
type review_variance_fields {
  rating: Float
  rid: Float
  year: Float
}

"""
order by variance() on columns of table "review"
"""
input review_variance_order_by {
  rating: order_by
  rid: order_by
  year: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "business"
  """
  business(
    """distinct select on columns"""
    distinct_on: [business_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [business_order_by!]

    """filter the rows returned"""
    where: business_bool_exp
  ): [business!]!

  """
  fetch aggregated fields from the table: "business"
  """
  business_aggregate(
    """distinct select on columns"""
    distinct_on: [business_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [business_order_by!]

    """filter the rows returned"""
    where: business_bool_exp
  ): business_aggregate!

  """fetch data from the table: "business" using primary key columns"""
  business_by_pk(bid: Int!): business

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: Int!): category

  """
  fetch data from the table: "checkin"
  """
  checkin(
    """distinct select on columns"""
    distinct_on: [checkin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkin_order_by!]

    """filter the rows returned"""
    where: checkin_bool_exp
  ): [checkin!]!

  """
  fetch aggregated fields from the table: "checkin"
  """
  checkin_aggregate(
    """distinct select on columns"""
    distinct_on: [checkin_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [checkin_order_by!]

    """filter the rows returned"""
    where: checkin_bool_exp
  ): checkin_aggregate!

  """fetch data from the table: "checkin" using primary key columns"""
  checkin_by_pk(cid: Int!): checkin

  """
  fetch data from the table: "neighbourhood"
  """
  neighbourhood(
    """distinct select on columns"""
    distinct_on: [neighbourhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighbourhood_order_by!]

    """filter the rows returned"""
    where: neighbourhood_bool_exp
  ): [neighbourhood!]!

  """
  fetch aggregated fields from the table: "neighbourhood"
  """
  neighbourhood_aggregate(
    """distinct select on columns"""
    distinct_on: [neighbourhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighbourhood_order_by!]

    """filter the rows returned"""
    where: neighbourhood_bool_exp
  ): neighbourhood_aggregate!

  """fetch data from the table: "neighbourhood" using primary key columns"""
  neighbourhood_by_pk(id: Int!): neighbourhood

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(rid: Int!): review

  """
  fetch data from the table: "tip"
  """
  tip(
    """distinct select on columns"""
    distinct_on: [tip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tip_order_by!]

    """filter the rows returned"""
    where: tip_bool_exp
  ): [tip!]!

  """
  fetch aggregated fields from the table: "tip"
  """
  tip_aggregate(
    """distinct select on columns"""
    distinct_on: [tip_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tip_order_by!]

    """filter the rows returned"""
    where: tip_bool_exp
  ): tip_aggregate!

  """fetch data from the table: "tip" using primary key columns"""
  tip_by_pk(tip_id: Int!): tip

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(uid: Int!): user
}

"""
columns and relationships of "tip"
"""
type tip {
  business_id: String
  likes: Int
  month: String
  text: String
  tip_id: Int!
  user_id: String
  year: Int
}

"""
aggregated selection of "tip"
"""
type tip_aggregate {
  aggregate: tip_aggregate_fields
  nodes: [tip!]!
}

"""
aggregate fields of "tip"
"""
type tip_aggregate_fields {
  avg: tip_avg_fields
  count(columns: [tip_select_column!], distinct: Boolean): Int
  max: tip_max_fields
  min: tip_min_fields
  stddev: tip_stddev_fields
  stddev_pop: tip_stddev_pop_fields
  stddev_samp: tip_stddev_samp_fields
  sum: tip_sum_fields
  var_pop: tip_var_pop_fields
  var_samp: tip_var_samp_fields
  variance: tip_variance_fields
}

"""
order by aggregate values of table "tip"
"""
input tip_aggregate_order_by {
  avg: tip_avg_order_by
  count: order_by
  max: tip_max_order_by
  min: tip_min_order_by
  stddev: tip_stddev_order_by
  stddev_pop: tip_stddev_pop_order_by
  stddev_samp: tip_stddev_samp_order_by
  sum: tip_sum_order_by
  var_pop: tip_var_pop_order_by
  var_samp: tip_var_samp_order_by
  variance: tip_variance_order_by
}

"""
input type for inserting array relation for remote table "tip"
"""
input tip_arr_rel_insert_input {
  data: [tip_insert_input!]!
  on_conflict: tip_on_conflict
}

"""aggregate avg on columns"""
type tip_avg_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by avg() on columns of table "tip"
"""
input tip_avg_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""
Boolean expression to filter rows from the table "tip". All fields are combined with a logical 'AND'.
"""
input tip_bool_exp {
  _and: [tip_bool_exp]
  _not: tip_bool_exp
  _or: [tip_bool_exp]
  business_id: String_comparison_exp
  likes: Int_comparison_exp
  month: String_comparison_exp
  text: String_comparison_exp
  tip_id: Int_comparison_exp
  user_id: String_comparison_exp
  year: Int_comparison_exp
}

"""
unique or primary key constraints on table "tip"
"""
enum tip_constraint {
  """unique or primary key constraint"""
  idx_20305_sqlite_autoindex_tip_1
}

"""
input type for incrementing integer column in table "tip"
"""
input tip_inc_input {
  likes: Int
  tip_id: Int
  year: Int
}

"""
input type for inserting data into table "tip"
"""
input tip_insert_input {
  business_id: String
  likes: Int
  month: String
  text: String
  tip_id: Int
  user_id: String
  year: Int
}

"""aggregate max on columns"""
type tip_max_fields {
  business_id: String
  likes: Int
  month: String
  text: String
  tip_id: Int
  user_id: String
  year: Int
}

"""
order by max() on columns of table "tip"
"""
input tip_max_order_by {
  business_id: order_by
  likes: order_by
  month: order_by
  text: order_by
  tip_id: order_by
  user_id: order_by
  year: order_by
}

"""aggregate min on columns"""
type tip_min_fields {
  business_id: String
  likes: Int
  month: String
  text: String
  tip_id: Int
  user_id: String
  year: Int
}

"""
order by min() on columns of table "tip"
"""
input tip_min_order_by {
  business_id: order_by
  likes: order_by
  month: order_by
  text: order_by
  tip_id: order_by
  user_id: order_by
  year: order_by
}

"""
response of any mutation on the table "tip"
"""
type tip_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [tip!]!
}

"""
input type for inserting object relation for remote table "tip"
"""
input tip_obj_rel_insert_input {
  data: tip_insert_input!
  on_conflict: tip_on_conflict
}

"""
on conflict condition type for table "tip"
"""
input tip_on_conflict {
  constraint: tip_constraint!
  update_columns: [tip_update_column!]!
  where: tip_bool_exp
}

"""
ordering options when selecting data from "tip"
"""
input tip_order_by {
  business_id: order_by
  likes: order_by
  month: order_by
  text: order_by
  tip_id: order_by
  user_id: order_by
  year: order_by
}

"""
primary key columns input for table: "tip"
"""
input tip_pk_columns_input {
  tip_id: Int!
}

"""
select columns of table "tip"
"""
enum tip_select_column {
  """column name"""
  business_id

  """column name"""
  likes

  """column name"""
  month

  """column name"""
  text

  """column name"""
  tip_id

  """column name"""
  user_id

  """column name"""
  year
}

"""
input type for updating data in table "tip"
"""
input tip_set_input {
  business_id: String
  likes: Int
  month: String
  text: String
  tip_id: Int
  user_id: String
  year: Int
}

"""aggregate stddev on columns"""
type tip_stddev_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by stddev() on columns of table "tip"
"""
input tip_stddev_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""aggregate stddev_pop on columns"""
type tip_stddev_pop_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by stddev_pop() on columns of table "tip"
"""
input tip_stddev_pop_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""aggregate stddev_samp on columns"""
type tip_stddev_samp_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by stddev_samp() on columns of table "tip"
"""
input tip_stddev_samp_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""aggregate sum on columns"""
type tip_sum_fields {
  likes: Int
  tip_id: Int
  year: Int
}

"""
order by sum() on columns of table "tip"
"""
input tip_sum_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""
update columns of table "tip"
"""
enum tip_update_column {
  """column name"""
  business_id

  """column name"""
  likes

  """column name"""
  month

  """column name"""
  text

  """column name"""
  tip_id

  """column name"""
  user_id

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type tip_var_pop_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by var_pop() on columns of table "tip"
"""
input tip_var_pop_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""aggregate var_samp on columns"""
type tip_var_samp_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by var_samp() on columns of table "tip"
"""
input tip_var_samp_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""aggregate variance on columns"""
type tip_variance_fields {
  likes: Float
  tip_id: Float
  year: Float
}

"""
order by variance() on columns of table "tip"
"""
input tip_variance_order_by {
  likes: order_by
  tip_id: order_by
  year: order_by
}

"""
columns and relationships of "user"
"""
type user {
  name: String
  uid: Int!
  user_id: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  avg: user_avg_order_by
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
  stddev: user_stddev_order_by
  stddev_pop: user_stddev_pop_order_by
  stddev_samp: user_stddev_samp_order_by
  sum: user_sum_order_by
  var_pop: user_var_pop_order_by
  var_samp: user_var_samp_order_by
  variance: user_variance_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"""aggregate avg on columns"""
type user_avg_fields {
  uid: Float
}

"""
order by avg() on columns of table "user"
"""
input user_avg_order_by {
  uid: order_by
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  name: String_comparison_exp
  uid: Int_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """unique or primary key constraint"""
  idx_20281_sqlite_autoindex_user_1
}

"""
input type for incrementing integer column in table "user"
"""
input user_inc_input {
  uid: Int
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  name: String
  uid: Int
  user_id: String
}

"""aggregate max on columns"""
type user_max_fields {
  name: String
  uid: Int
  user_id: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  name: order_by
  uid: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  name: String
  uid: Int
  user_id: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  name: order_by
  uid: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
ordering options when selecting data from "user"
"""
input user_order_by {
  name: order_by
  uid: order_by
  user_id: order_by
}

"""
primary key columns input for table: "user"
"""
input user_pk_columns_input {
  uid: Int!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  name

  """column name"""
  uid

  """column name"""
  user_id
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  name: String
  uid: Int
  user_id: String
}

"""aggregate stddev on columns"""
type user_stddev_fields {
  uid: Float
}

"""
order by stddev() on columns of table "user"
"""
input user_stddev_order_by {
  uid: order_by
}

"""aggregate stddev_pop on columns"""
type user_stddev_pop_fields {
  uid: Float
}

"""
order by stddev_pop() on columns of table "user"
"""
input user_stddev_pop_order_by {
  uid: order_by
}

"""aggregate stddev_samp on columns"""
type user_stddev_samp_fields {
  uid: Float
}

"""
order by stddev_samp() on columns of table "user"
"""
input user_stddev_samp_order_by {
  uid: order_by
}

"""aggregate sum on columns"""
type user_sum_fields {
  uid: Int
}

"""
order by sum() on columns of table "user"
"""
input user_sum_order_by {
  uid: order_by
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  name

  """column name"""
  uid

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type user_var_pop_fields {
  uid: Float
}

"""
order by var_pop() on columns of table "user"
"""
input user_var_pop_order_by {
  uid: order_by
}

"""aggregate var_samp on columns"""
type user_var_samp_fields {
  uid: Float
}

"""
order by var_samp() on columns of table "user"
"""
input user_var_samp_order_by {
  uid: order_by
}

"""aggregate variance on columns"""
type user_variance_fields {
  uid: Float
}

"""
order by variance() on columns of table "user"
"""
input user_variance_order_by {
  uid: order_by
}
