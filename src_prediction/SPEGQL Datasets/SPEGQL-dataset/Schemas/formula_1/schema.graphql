schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

scalar bigint

"""
expression to compare columns of type bigint. All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "circuits"
"""
type circuits {
  alt: String
  circuitid: bigint!
  circuitref: String
  country: String
  lat: Float
  lng: Float
  location: String
  name: String

  """An array relationship"""
  races(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): [races!]!

  """An aggregated array relationship"""
  races_aggregate(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): races_aggregate!
  url: String
}

"""
aggregated selection of "circuits"
"""
type circuits_aggregate {
  aggregate: circuits_aggregate_fields
  nodes: [circuits!]!
}

"""
aggregate fields of "circuits"
"""
type circuits_aggregate_fields {
  avg: circuits_avg_fields
  count(columns: [circuits_select_column!], distinct: Boolean): Int
  max: circuits_max_fields
  min: circuits_min_fields
  stddev: circuits_stddev_fields
  stddev_pop: circuits_stddev_pop_fields
  stddev_samp: circuits_stddev_samp_fields
  sum: circuits_sum_fields
  var_pop: circuits_var_pop_fields
  var_samp: circuits_var_samp_fields
  variance: circuits_variance_fields
}

"""
order by aggregate values of table "circuits"
"""
input circuits_aggregate_order_by {
  avg: circuits_avg_order_by
  count: order_by
  max: circuits_max_order_by
  min: circuits_min_order_by
  stddev: circuits_stddev_order_by
  stddev_pop: circuits_stddev_pop_order_by
  stddev_samp: circuits_stddev_samp_order_by
  sum: circuits_sum_order_by
  var_pop: circuits_var_pop_order_by
  var_samp: circuits_var_samp_order_by
  variance: circuits_variance_order_by
}

"""
input type for inserting array relation for remote table "circuits"
"""
input circuits_arr_rel_insert_input {
  data: [circuits_insert_input!]!
  on_conflict: circuits_on_conflict
}

"""aggregate avg on columns"""
type circuits_avg_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by avg() on columns of table "circuits"
"""
input circuits_avg_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""
Boolean expression to filter rows from the table "circuits". All fields are combined with a logical 'AND'.
"""
input circuits_bool_exp {
  _and: [circuits_bool_exp]
  _not: circuits_bool_exp
  _or: [circuits_bool_exp]
  alt: String_comparison_exp
  circuitid: bigint_comparison_exp
  circuitref: String_comparison_exp
  country: String_comparison_exp
  lat: Float_comparison_exp
  lng: Float_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  races: races_bool_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "circuits"
"""
enum circuits_constraint {
  """unique or primary key constraint"""
  idx_18889_circuits_pkey
}

"""
input type for incrementing integer column in table "circuits"
"""
input circuits_inc_input {
  circuitid: bigint
  lat: Float
  lng: Float
}

"""
input type for inserting data into table "circuits"
"""
input circuits_insert_input {
  alt: String
  circuitid: bigint
  circuitref: String
  country: String
  lat: Float
  lng: Float
  location: String
  name: String
  races: races_arr_rel_insert_input
  url: String
}

"""aggregate max on columns"""
type circuits_max_fields {
  alt: String
  circuitid: bigint
  circuitref: String
  country: String
  lat: Float
  lng: Float
  location: String
  name: String
  url: String
}

"""
order by max() on columns of table "circuits"
"""
input circuits_max_order_by {
  alt: order_by
  circuitid: order_by
  circuitref: order_by
  country: order_by
  lat: order_by
  lng: order_by
  location: order_by
  name: order_by
  url: order_by
}

"""aggregate min on columns"""
type circuits_min_fields {
  alt: String
  circuitid: bigint
  circuitref: String
  country: String
  lat: Float
  lng: Float
  location: String
  name: String
  url: String
}

"""
order by min() on columns of table "circuits"
"""
input circuits_min_order_by {
  alt: order_by
  circuitid: order_by
  circuitref: order_by
  country: order_by
  lat: order_by
  lng: order_by
  location: order_by
  name: order_by
  url: order_by
}

"""
response of any mutation on the table "circuits"
"""
type circuits_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [circuits!]!
}

"""
input type for inserting object relation for remote table "circuits"
"""
input circuits_obj_rel_insert_input {
  data: circuits_insert_input!
  on_conflict: circuits_on_conflict
}

"""
on conflict condition type for table "circuits"
"""
input circuits_on_conflict {
  constraint: circuits_constraint!
  update_columns: [circuits_update_column!]!
  where: circuits_bool_exp
}

"""
ordering options when selecting data from "circuits"
"""
input circuits_order_by {
  alt: order_by
  circuitid: order_by
  circuitref: order_by
  country: order_by
  lat: order_by
  lng: order_by
  location: order_by
  name: order_by
  races_aggregate: races_aggregate_order_by
  url: order_by
}

"""
primary key columns input for table: "circuits"
"""
input circuits_pk_columns_input {
  circuitid: bigint!
}

"""
select columns of table "circuits"
"""
enum circuits_select_column {
  """column name"""
  alt

  """column name"""
  circuitid

  """column name"""
  circuitref

  """column name"""
  country

  """column name"""
  lat

  """column name"""
  lng

  """column name"""
  location

  """column name"""
  name

  """column name"""
  url
}

"""
input type for updating data in table "circuits"
"""
input circuits_set_input {
  alt: String
  circuitid: bigint
  circuitref: String
  country: String
  lat: Float
  lng: Float
  location: String
  name: String
  url: String
}

"""aggregate stddev on columns"""
type circuits_stddev_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by stddev() on columns of table "circuits"
"""
input circuits_stddev_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""aggregate stddev_pop on columns"""
type circuits_stddev_pop_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by stddev_pop() on columns of table "circuits"
"""
input circuits_stddev_pop_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""aggregate stddev_samp on columns"""
type circuits_stddev_samp_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by stddev_samp() on columns of table "circuits"
"""
input circuits_stddev_samp_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""aggregate sum on columns"""
type circuits_sum_fields {
  circuitid: bigint
  lat: Float
  lng: Float
}

"""
order by sum() on columns of table "circuits"
"""
input circuits_sum_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""
update columns of table "circuits"
"""
enum circuits_update_column {
  """column name"""
  alt

  """column name"""
  circuitid

  """column name"""
  circuitref

  """column name"""
  country

  """column name"""
  lat

  """column name"""
  lng

  """column name"""
  location

  """column name"""
  name

  """column name"""
  url
}

"""aggregate var_pop on columns"""
type circuits_var_pop_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by var_pop() on columns of table "circuits"
"""
input circuits_var_pop_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""aggregate var_samp on columns"""
type circuits_var_samp_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by var_samp() on columns of table "circuits"
"""
input circuits_var_samp_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""aggregate variance on columns"""
type circuits_variance_fields {
  circuitid: Float
  lat: Float
  lng: Float
}

"""
order by variance() on columns of table "circuits"
"""
input circuits_variance_order_by {
  circuitid: order_by
  lat: order_by
  lng: order_by
}

"""
columns and relationships of "constructorresults"
"""
type constructorresults {
  """An object relationship"""
  constructor: constructors
  constructorid: bigint
  constructorresultsid: bigint!
  points: Float

  """An object relationship"""
  race: races
  raceid: bigint
  status: String
}

"""
aggregated selection of "constructorresults"
"""
type constructorresults_aggregate {
  aggregate: constructorresults_aggregate_fields
  nodes: [constructorresults!]!
}

"""
aggregate fields of "constructorresults"
"""
type constructorresults_aggregate_fields {
  avg: constructorresults_avg_fields
  count(columns: [constructorresults_select_column!], distinct: Boolean): Int
  max: constructorresults_max_fields
  min: constructorresults_min_fields
  stddev: constructorresults_stddev_fields
  stddev_pop: constructorresults_stddev_pop_fields
  stddev_samp: constructorresults_stddev_samp_fields
  sum: constructorresults_sum_fields
  var_pop: constructorresults_var_pop_fields
  var_samp: constructorresults_var_samp_fields
  variance: constructorresults_variance_fields
}

"""
order by aggregate values of table "constructorresults"
"""
input constructorresults_aggregate_order_by {
  avg: constructorresults_avg_order_by
  count: order_by
  max: constructorresults_max_order_by
  min: constructorresults_min_order_by
  stddev: constructorresults_stddev_order_by
  stddev_pop: constructorresults_stddev_pop_order_by
  stddev_samp: constructorresults_stddev_samp_order_by
  sum: constructorresults_sum_order_by
  var_pop: constructorresults_var_pop_order_by
  var_samp: constructorresults_var_samp_order_by
  variance: constructorresults_variance_order_by
}

"""
input type for inserting array relation for remote table "constructorresults"
"""
input constructorresults_arr_rel_insert_input {
  data: [constructorresults_insert_input!]!
  on_conflict: constructorresults_on_conflict
}

"""aggregate avg on columns"""
type constructorresults_avg_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by avg() on columns of table "constructorresults"
"""
input constructorresults_avg_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""
Boolean expression to filter rows from the table "constructorresults". All fields are combined with a logical 'AND'.
"""
input constructorresults_bool_exp {
  _and: [constructorresults_bool_exp]
  _not: constructorresults_bool_exp
  _or: [constructorresults_bool_exp]
  constructor: constructors_bool_exp
  constructorid: bigint_comparison_exp
  constructorresultsid: bigint_comparison_exp
  points: Float_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "constructorresults"
"""
enum constructorresults_constraint {
  """unique or primary key constraint"""
  idx_18943_constructorresults_pkey
}

"""
input type for incrementing integer column in table "constructorresults"
"""
input constructorresults_inc_input {
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  raceid: bigint
}

"""
input type for inserting data into table "constructorresults"
"""
input constructorresults_insert_input {
  constructor: constructors_obj_rel_insert_input
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  race: races_obj_rel_insert_input
  raceid: bigint
  status: String
}

"""aggregate max on columns"""
type constructorresults_max_fields {
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  raceid: bigint
  status: String
}

"""
order by max() on columns of table "constructorresults"
"""
input constructorresults_max_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
  status: order_by
}

"""aggregate min on columns"""
type constructorresults_min_fields {
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  raceid: bigint
  status: String
}

"""
order by min() on columns of table "constructorresults"
"""
input constructorresults_min_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
  status: order_by
}

"""
response of any mutation on the table "constructorresults"
"""
type constructorresults_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [constructorresults!]!
}

"""
input type for inserting object relation for remote table "constructorresults"
"""
input constructorresults_obj_rel_insert_input {
  data: constructorresults_insert_input!
  on_conflict: constructorresults_on_conflict
}

"""
on conflict condition type for table "constructorresults"
"""
input constructorresults_on_conflict {
  constraint: constructorresults_constraint!
  update_columns: [constructorresults_update_column!]!
  where: constructorresults_bool_exp
}

"""
ordering options when selecting data from "constructorresults"
"""
input constructorresults_order_by {
  constructor: constructors_order_by
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  race: races_order_by
  raceid: order_by
  status: order_by
}

"""
primary key columns input for table: "constructorresults"
"""
input constructorresults_pk_columns_input {
  constructorresultsid: bigint!
}

"""
select columns of table "constructorresults"
"""
enum constructorresults_select_column {
  """column name"""
  constructorid

  """column name"""
  constructorresultsid

  """column name"""
  points

  """column name"""
  raceid

  """column name"""
  status
}

"""
input type for updating data in table "constructorresults"
"""
input constructorresults_set_input {
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  raceid: bigint
  status: String
}

"""aggregate stddev on columns"""
type constructorresults_stddev_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by stddev() on columns of table "constructorresults"
"""
input constructorresults_stddev_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""aggregate stddev_pop on columns"""
type constructorresults_stddev_pop_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by stddev_pop() on columns of table "constructorresults"
"""
input constructorresults_stddev_pop_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""aggregate stddev_samp on columns"""
type constructorresults_stddev_samp_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by stddev_samp() on columns of table "constructorresults"
"""
input constructorresults_stddev_samp_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""aggregate sum on columns"""
type constructorresults_sum_fields {
  constructorid: bigint
  constructorresultsid: bigint
  points: Float
  raceid: bigint
}

"""
order by sum() on columns of table "constructorresults"
"""
input constructorresults_sum_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""
update columns of table "constructorresults"
"""
enum constructorresults_update_column {
  """column name"""
  constructorid

  """column name"""
  constructorresultsid

  """column name"""
  points

  """column name"""
  raceid

  """column name"""
  status
}

"""aggregate var_pop on columns"""
type constructorresults_var_pop_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by var_pop() on columns of table "constructorresults"
"""
input constructorresults_var_pop_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""aggregate var_samp on columns"""
type constructorresults_var_samp_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by var_samp() on columns of table "constructorresults"
"""
input constructorresults_var_samp_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""aggregate variance on columns"""
type constructorresults_variance_fields {
  constructorid: Float
  constructorresultsid: Float
  points: Float
  raceid: Float
}

"""
order by variance() on columns of table "constructorresults"
"""
input constructorresults_variance_order_by {
  constructorid: order_by
  constructorresultsid: order_by
  points: order_by
  raceid: order_by
}

"""
columns and relationships of "constructors"
"""
type constructors {
  constructorid: bigint!
  constructorref: String

  """An array relationship"""
  constructorresults(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): [constructorresults!]!

  """An aggregated array relationship"""
  constructorresults_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): constructorresults_aggregate!

  """An array relationship"""
  constructorstandings(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): [constructorstandings!]!

  """An aggregated array relationship"""
  constructorstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): constructorstandings_aggregate!
  name: String
  nationality: String

  """An array relationship"""
  qualifyings(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): [qualifying!]!

  """An aggregated array relationship"""
  qualifyings_aggregate(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): qualifying_aggregate!

  """An array relationship"""
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """An aggregated array relationship"""
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!
  url: String
}

"""
aggregated selection of "constructors"
"""
type constructors_aggregate {
  aggregate: constructors_aggregate_fields
  nodes: [constructors!]!
}

"""
aggregate fields of "constructors"
"""
type constructors_aggregate_fields {
  avg: constructors_avg_fields
  count(columns: [constructors_select_column!], distinct: Boolean): Int
  max: constructors_max_fields
  min: constructors_min_fields
  stddev: constructors_stddev_fields
  stddev_pop: constructors_stddev_pop_fields
  stddev_samp: constructors_stddev_samp_fields
  sum: constructors_sum_fields
  var_pop: constructors_var_pop_fields
  var_samp: constructors_var_samp_fields
  variance: constructors_variance_fields
}

"""
order by aggregate values of table "constructors"
"""
input constructors_aggregate_order_by {
  avg: constructors_avg_order_by
  count: order_by
  max: constructors_max_order_by
  min: constructors_min_order_by
  stddev: constructors_stddev_order_by
  stddev_pop: constructors_stddev_pop_order_by
  stddev_samp: constructors_stddev_samp_order_by
  sum: constructors_sum_order_by
  var_pop: constructors_var_pop_order_by
  var_samp: constructors_var_samp_order_by
  variance: constructors_variance_order_by
}

"""
input type for inserting array relation for remote table "constructors"
"""
input constructors_arr_rel_insert_input {
  data: [constructors_insert_input!]!
  on_conflict: constructors_on_conflict
}

"""aggregate avg on columns"""
type constructors_avg_fields {
  constructorid: Float
}

"""
order by avg() on columns of table "constructors"
"""
input constructors_avg_order_by {
  constructorid: order_by
}

"""
Boolean expression to filter rows from the table "constructors". All fields are combined with a logical 'AND'.
"""
input constructors_bool_exp {
  _and: [constructors_bool_exp]
  _not: constructors_bool_exp
  _or: [constructors_bool_exp]
  constructorid: bigint_comparison_exp
  constructorref: String_comparison_exp
  constructorresults: constructorresults_bool_exp
  constructorstandings: constructorstandings_bool_exp
  name: String_comparison_exp
  nationality: String_comparison_exp
  qualifyings: qualifying_bool_exp
  results: results_bool_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "constructors"
"""
enum constructors_constraint {
  """unique or primary key constraint"""
  idx_18919_constructors_pkey
}

"""
input type for incrementing integer column in table "constructors"
"""
input constructors_inc_input {
  constructorid: bigint
}

"""
input type for inserting data into table "constructors"
"""
input constructors_insert_input {
  constructorid: bigint
  constructorref: String
  constructorresults: constructorresults_arr_rel_insert_input
  constructorstandings: constructorstandings_arr_rel_insert_input
  name: String
  nationality: String
  qualifyings: qualifying_arr_rel_insert_input
  results: results_arr_rel_insert_input
  url: String
}

"""aggregate max on columns"""
type constructors_max_fields {
  constructorid: bigint
  constructorref: String
  name: String
  nationality: String
  url: String
}

"""
order by max() on columns of table "constructors"
"""
input constructors_max_order_by {
  constructorid: order_by
  constructorref: order_by
  name: order_by
  nationality: order_by
  url: order_by
}

"""aggregate min on columns"""
type constructors_min_fields {
  constructorid: bigint
  constructorref: String
  name: String
  nationality: String
  url: String
}

"""
order by min() on columns of table "constructors"
"""
input constructors_min_order_by {
  constructorid: order_by
  constructorref: order_by
  name: order_by
  nationality: order_by
  url: order_by
}

"""
response of any mutation on the table "constructors"
"""
type constructors_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [constructors!]!
}

"""
input type for inserting object relation for remote table "constructors"
"""
input constructors_obj_rel_insert_input {
  data: constructors_insert_input!
  on_conflict: constructors_on_conflict
}

"""
on conflict condition type for table "constructors"
"""
input constructors_on_conflict {
  constraint: constructors_constraint!
  update_columns: [constructors_update_column!]!
  where: constructors_bool_exp
}

"""
ordering options when selecting data from "constructors"
"""
input constructors_order_by {
  constructorid: order_by
  constructorref: order_by
  constructorresults_aggregate: constructorresults_aggregate_order_by
  constructorstandings_aggregate: constructorstandings_aggregate_order_by
  name: order_by
  nationality: order_by
  qualifyings_aggregate: qualifying_aggregate_order_by
  results_aggregate: results_aggregate_order_by
  url: order_by
}

"""
primary key columns input for table: "constructors"
"""
input constructors_pk_columns_input {
  constructorid: bigint!
}

"""
select columns of table "constructors"
"""
enum constructors_select_column {
  """column name"""
  constructorid

  """column name"""
  constructorref

  """column name"""
  name

  """column name"""
  nationality

  """column name"""
  url
}

"""
input type for updating data in table "constructors"
"""
input constructors_set_input {
  constructorid: bigint
  constructorref: String
  name: String
  nationality: String
  url: String
}

"""aggregate stddev on columns"""
type constructors_stddev_fields {
  constructorid: Float
}

"""
order by stddev() on columns of table "constructors"
"""
input constructors_stddev_order_by {
  constructorid: order_by
}

"""aggregate stddev_pop on columns"""
type constructors_stddev_pop_fields {
  constructorid: Float
}

"""
order by stddev_pop() on columns of table "constructors"
"""
input constructors_stddev_pop_order_by {
  constructorid: order_by
}

"""aggregate stddev_samp on columns"""
type constructors_stddev_samp_fields {
  constructorid: Float
}

"""
order by stddev_samp() on columns of table "constructors"
"""
input constructors_stddev_samp_order_by {
  constructorid: order_by
}

"""aggregate sum on columns"""
type constructors_sum_fields {
  constructorid: bigint
}

"""
order by sum() on columns of table "constructors"
"""
input constructors_sum_order_by {
  constructorid: order_by
}

"""
update columns of table "constructors"
"""
enum constructors_update_column {
  """column name"""
  constructorid

  """column name"""
  constructorref

  """column name"""
  name

  """column name"""
  nationality

  """column name"""
  url
}

"""aggregate var_pop on columns"""
type constructors_var_pop_fields {
  constructorid: Float
}

"""
order by var_pop() on columns of table "constructors"
"""
input constructors_var_pop_order_by {
  constructorid: order_by
}

"""aggregate var_samp on columns"""
type constructors_var_samp_fields {
  constructorid: Float
}

"""
order by var_samp() on columns of table "constructors"
"""
input constructors_var_samp_order_by {
  constructorid: order_by
}

"""aggregate variance on columns"""
type constructors_variance_fields {
  constructorid: Float
}

"""
order by variance() on columns of table "constructors"
"""
input constructors_variance_order_by {
  constructorid: order_by
}

"""
columns and relationships of "constructorstandings"
"""
type constructorstandings {
  """An object relationship"""
  constructor: constructors
  constructorid: bigint
  constructorstandingsid: bigint!
  points: Float
  position: bigint
  positiontext: String

  """An object relationship"""
  race: races
  raceid: bigint
  wins: bigint
}

"""
aggregated selection of "constructorstandings"
"""
type constructorstandings_aggregate {
  aggregate: constructorstandings_aggregate_fields
  nodes: [constructorstandings!]!
}

"""
aggregate fields of "constructorstandings"
"""
type constructorstandings_aggregate_fields {
  avg: constructorstandings_avg_fields
  count(columns: [constructorstandings_select_column!], distinct: Boolean): Int
  max: constructorstandings_max_fields
  min: constructorstandings_min_fields
  stddev: constructorstandings_stddev_fields
  stddev_pop: constructorstandings_stddev_pop_fields
  stddev_samp: constructorstandings_stddev_samp_fields
  sum: constructorstandings_sum_fields
  var_pop: constructorstandings_var_pop_fields
  var_samp: constructorstandings_var_samp_fields
  variance: constructorstandings_variance_fields
}

"""
order by aggregate values of table "constructorstandings"
"""
input constructorstandings_aggregate_order_by {
  avg: constructorstandings_avg_order_by
  count: order_by
  max: constructorstandings_max_order_by
  min: constructorstandings_min_order_by
  stddev: constructorstandings_stddev_order_by
  stddev_pop: constructorstandings_stddev_pop_order_by
  stddev_samp: constructorstandings_stddev_samp_order_by
  sum: constructorstandings_sum_order_by
  var_pop: constructorstandings_var_pop_order_by
  var_samp: constructorstandings_var_samp_order_by
  variance: constructorstandings_variance_order_by
}

"""
input type for inserting array relation for remote table "constructorstandings"
"""
input constructorstandings_arr_rel_insert_input {
  data: [constructorstandings_insert_input!]!
  on_conflict: constructorstandings_on_conflict
}

"""aggregate avg on columns"""
type constructorstandings_avg_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by avg() on columns of table "constructorstandings"
"""
input constructorstandings_avg_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "constructorstandings". All fields are combined with a logical 'AND'.
"""
input constructorstandings_bool_exp {
  _and: [constructorstandings_bool_exp]
  _not: constructorstandings_bool_exp
  _or: [constructorstandings_bool_exp]
  constructor: constructors_bool_exp
  constructorid: bigint_comparison_exp
  constructorstandingsid: bigint_comparison_exp
  points: Float_comparison_exp
  position: bigint_comparison_exp
  positiontext: String_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  wins: bigint_comparison_exp
}

"""
unique or primary key constraints on table "constructorstandings"
"""
enum constructorstandings_constraint {
  """unique or primary key constraint"""
  idx_18925_constructorstandings_pkey
}

"""
input type for incrementing integer column in table "constructorstandings"
"""
input constructorstandings_inc_input {
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  raceid: bigint
  wins: bigint
}

"""
input type for inserting data into table "constructorstandings"
"""
input constructorstandings_insert_input {
  constructor: constructors_obj_rel_insert_input
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  race: races_obj_rel_insert_input
  raceid: bigint
  wins: bigint
}

"""aggregate max on columns"""
type constructorstandings_max_fields {
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""
order by max() on columns of table "constructorstandings"
"""
input constructorstandings_max_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate min on columns"""
type constructorstandings_min_fields {
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""
order by min() on columns of table "constructorstandings"
"""
input constructorstandings_min_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  raceid: order_by
  wins: order_by
}

"""
response of any mutation on the table "constructorstandings"
"""
type constructorstandings_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [constructorstandings!]!
}

"""
input type for inserting object relation for remote table "constructorstandings"
"""
input constructorstandings_obj_rel_insert_input {
  data: constructorstandings_insert_input!
  on_conflict: constructorstandings_on_conflict
}

"""
on conflict condition type for table "constructorstandings"
"""
input constructorstandings_on_conflict {
  constraint: constructorstandings_constraint!
  update_columns: [constructorstandings_update_column!]!
  where: constructorstandings_bool_exp
}

"""
ordering options when selecting data from "constructorstandings"
"""
input constructorstandings_order_by {
  constructor: constructors_order_by
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  race: races_order_by
  raceid: order_by
  wins: order_by
}

"""
primary key columns input for table: "constructorstandings"
"""
input constructorstandings_pk_columns_input {
  constructorstandingsid: bigint!
}

"""
select columns of table "constructorstandings"
"""
enum constructorstandings_select_column {
  """column name"""
  constructorid

  """column name"""
  constructorstandingsid

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  wins
}

"""
input type for updating data in table "constructorstandings"
"""
input constructorstandings_set_input {
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""aggregate stddev on columns"""
type constructorstandings_stddev_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev() on columns of table "constructorstandings"
"""
input constructorstandings_stddev_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate stddev_pop on columns"""
type constructorstandings_stddev_pop_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "constructorstandings"
"""
input constructorstandings_stddev_pop_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate stddev_samp on columns"""
type constructorstandings_stddev_samp_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "constructorstandings"
"""
input constructorstandings_stddev_samp_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate sum on columns"""
type constructorstandings_sum_fields {
  constructorid: bigint
  constructorstandingsid: bigint
  points: Float
  position: bigint
  raceid: bigint
  wins: bigint
}

"""
order by sum() on columns of table "constructorstandings"
"""
input constructorstandings_sum_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
update columns of table "constructorstandings"
"""
enum constructorstandings_update_column {
  """column name"""
  constructorid

  """column name"""
  constructorstandingsid

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  wins
}

"""aggregate var_pop on columns"""
type constructorstandings_var_pop_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by var_pop() on columns of table "constructorstandings"
"""
input constructorstandings_var_pop_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate var_samp on columns"""
type constructorstandings_var_samp_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by var_samp() on columns of table "constructorstandings"
"""
input constructorstandings_var_samp_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate variance on columns"""
type constructorstandings_variance_fields {
  constructorid: Float
  constructorstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by variance() on columns of table "constructorstandings"
"""
input constructorstandings_variance_order_by {
  constructorid: order_by
  constructorstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
columns and relationships of "drivers"
"""
type drivers {
  code: String
  dob: String
  driverid: bigint!
  driverref: String

  """An array relationship"""
  driverstandings(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): [driverstandings!]!

  """An aggregated array relationship"""
  driverstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): driverstandings_aggregate!
  forename: String

  """An array relationship"""
  laptimes(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): [laptimes!]!

  """An aggregated array relationship"""
  laptimes_aggregate(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): laptimes_aggregate!
  nationality: String
  number: String

  """An array relationship"""
  pitstops(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): [pitstops!]!

  """An aggregated array relationship"""
  pitstops_aggregate(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): pitstops_aggregate!

  """An array relationship"""
  qualifyings(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): [qualifying!]!

  """An aggregated array relationship"""
  qualifyings_aggregate(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): qualifying_aggregate!

  """An array relationship"""
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """An aggregated array relationship"""
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!
  surname: String
  url: String
}

"""
aggregated selection of "drivers"
"""
type drivers_aggregate {
  aggregate: drivers_aggregate_fields
  nodes: [drivers!]!
}

"""
aggregate fields of "drivers"
"""
type drivers_aggregate_fields {
  avg: drivers_avg_fields
  count(columns: [drivers_select_column!], distinct: Boolean): Int
  max: drivers_max_fields
  min: drivers_min_fields
  stddev: drivers_stddev_fields
  stddev_pop: drivers_stddev_pop_fields
  stddev_samp: drivers_stddev_samp_fields
  sum: drivers_sum_fields
  var_pop: drivers_var_pop_fields
  var_samp: drivers_var_samp_fields
  variance: drivers_variance_fields
}

"""
order by aggregate values of table "drivers"
"""
input drivers_aggregate_order_by {
  avg: drivers_avg_order_by
  count: order_by
  max: drivers_max_order_by
  min: drivers_min_order_by
  stddev: drivers_stddev_order_by
  stddev_pop: drivers_stddev_pop_order_by
  stddev_samp: drivers_stddev_samp_order_by
  sum: drivers_sum_order_by
  var_pop: drivers_var_pop_order_by
  var_samp: drivers_var_samp_order_by
  variance: drivers_variance_order_by
}

"""
input type for inserting array relation for remote table "drivers"
"""
input drivers_arr_rel_insert_input {
  data: [drivers_insert_input!]!
  on_conflict: drivers_on_conflict
}

"""aggregate avg on columns"""
type drivers_avg_fields {
  driverid: Float
}

"""
order by avg() on columns of table "drivers"
"""
input drivers_avg_order_by {
  driverid: order_by
}

"""
Boolean expression to filter rows from the table "drivers". All fields are combined with a logical 'AND'.
"""
input drivers_bool_exp {
  _and: [drivers_bool_exp]
  _not: drivers_bool_exp
  _or: [drivers_bool_exp]
  code: String_comparison_exp
  dob: String_comparison_exp
  driverid: bigint_comparison_exp
  driverref: String_comparison_exp
  driverstandings: driverstandings_bool_exp
  forename: String_comparison_exp
  laptimes: laptimes_bool_exp
  nationality: String_comparison_exp
  number: String_comparison_exp
  pitstops: pitstops_bool_exp
  qualifyings: qualifying_bool_exp
  results: results_bool_exp
  surname: String_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "drivers"
"""
enum drivers_constraint {
  """unique or primary key constraint"""
  idx_18901_drivers_pkey
}

"""
input type for incrementing integer column in table "drivers"
"""
input drivers_inc_input {
  driverid: bigint
}

"""
input type for inserting data into table "drivers"
"""
input drivers_insert_input {
  code: String
  dob: String
  driverid: bigint
  driverref: String
  driverstandings: driverstandings_arr_rel_insert_input
  forename: String
  laptimes: laptimes_arr_rel_insert_input
  nationality: String
  number: String
  pitstops: pitstops_arr_rel_insert_input
  qualifyings: qualifying_arr_rel_insert_input
  results: results_arr_rel_insert_input
  surname: String
  url: String
}

"""aggregate max on columns"""
type drivers_max_fields {
  code: String
  dob: String
  driverid: bigint
  driverref: String
  forename: String
  nationality: String
  number: String
  surname: String
  url: String
}

"""
order by max() on columns of table "drivers"
"""
input drivers_max_order_by {
  code: order_by
  dob: order_by
  driverid: order_by
  driverref: order_by
  forename: order_by
  nationality: order_by
  number: order_by
  surname: order_by
  url: order_by
}

"""aggregate min on columns"""
type drivers_min_fields {
  code: String
  dob: String
  driverid: bigint
  driverref: String
  forename: String
  nationality: String
  number: String
  surname: String
  url: String
}

"""
order by min() on columns of table "drivers"
"""
input drivers_min_order_by {
  code: order_by
  dob: order_by
  driverid: order_by
  driverref: order_by
  forename: order_by
  nationality: order_by
  number: order_by
  surname: order_by
  url: order_by
}

"""
response of any mutation on the table "drivers"
"""
type drivers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [drivers!]!
}

"""
input type for inserting object relation for remote table "drivers"
"""
input drivers_obj_rel_insert_input {
  data: drivers_insert_input!
  on_conflict: drivers_on_conflict
}

"""
on conflict condition type for table "drivers"
"""
input drivers_on_conflict {
  constraint: drivers_constraint!
  update_columns: [drivers_update_column!]!
  where: drivers_bool_exp
}

"""
ordering options when selecting data from "drivers"
"""
input drivers_order_by {
  code: order_by
  dob: order_by
  driverid: order_by
  driverref: order_by
  driverstandings_aggregate: driverstandings_aggregate_order_by
  forename: order_by
  laptimes_aggregate: laptimes_aggregate_order_by
  nationality: order_by
  number: order_by
  pitstops_aggregate: pitstops_aggregate_order_by
  qualifyings_aggregate: qualifying_aggregate_order_by
  results_aggregate: results_aggregate_order_by
  surname: order_by
  url: order_by
}

"""
primary key columns input for table: "drivers"
"""
input drivers_pk_columns_input {
  driverid: bigint!
}

"""
select columns of table "drivers"
"""
enum drivers_select_column {
  """column name"""
  code

  """column name"""
  dob

  """column name"""
  driverid

  """column name"""
  driverref

  """column name"""
  forename

  """column name"""
  nationality

  """column name"""
  number

  """column name"""
  surname

  """column name"""
  url
}

"""
input type for updating data in table "drivers"
"""
input drivers_set_input {
  code: String
  dob: String
  driverid: bigint
  driverref: String
  forename: String
  nationality: String
  number: String
  surname: String
  url: String
}

"""aggregate stddev on columns"""
type drivers_stddev_fields {
  driverid: Float
}

"""
order by stddev() on columns of table "drivers"
"""
input drivers_stddev_order_by {
  driverid: order_by
}

"""aggregate stddev_pop on columns"""
type drivers_stddev_pop_fields {
  driverid: Float
}

"""
order by stddev_pop() on columns of table "drivers"
"""
input drivers_stddev_pop_order_by {
  driverid: order_by
}

"""aggregate stddev_samp on columns"""
type drivers_stddev_samp_fields {
  driverid: Float
}

"""
order by stddev_samp() on columns of table "drivers"
"""
input drivers_stddev_samp_order_by {
  driverid: order_by
}

"""aggregate sum on columns"""
type drivers_sum_fields {
  driverid: bigint
}

"""
order by sum() on columns of table "drivers"
"""
input drivers_sum_order_by {
  driverid: order_by
}

"""
update columns of table "drivers"
"""
enum drivers_update_column {
  """column name"""
  code

  """column name"""
  dob

  """column name"""
  driverid

  """column name"""
  driverref

  """column name"""
  forename

  """column name"""
  nationality

  """column name"""
  number

  """column name"""
  surname

  """column name"""
  url
}

"""aggregate var_pop on columns"""
type drivers_var_pop_fields {
  driverid: Float
}

"""
order by var_pop() on columns of table "drivers"
"""
input drivers_var_pop_order_by {
  driverid: order_by
}

"""aggregate var_samp on columns"""
type drivers_var_samp_fields {
  driverid: Float
}

"""
order by var_samp() on columns of table "drivers"
"""
input drivers_var_samp_order_by {
  driverid: order_by
}

"""aggregate variance on columns"""
type drivers_variance_fields {
  driverid: Float
}

"""
order by variance() on columns of table "drivers"
"""
input drivers_variance_order_by {
  driverid: order_by
}

"""
columns and relationships of "driverstandings"
"""
type driverstandings {
  """An object relationship"""
  driver: drivers
  driverid: bigint
  driverstandingsid: bigint!
  points: Float
  position: bigint
  positiontext: String

  """An object relationship"""
  race: races
  raceid: bigint
  wins: bigint
}

"""
aggregated selection of "driverstandings"
"""
type driverstandings_aggregate {
  aggregate: driverstandings_aggregate_fields
  nodes: [driverstandings!]!
}

"""
aggregate fields of "driverstandings"
"""
type driverstandings_aggregate_fields {
  avg: driverstandings_avg_fields
  count(columns: [driverstandings_select_column!], distinct: Boolean): Int
  max: driverstandings_max_fields
  min: driverstandings_min_fields
  stddev: driverstandings_stddev_fields
  stddev_pop: driverstandings_stddev_pop_fields
  stddev_samp: driverstandings_stddev_samp_fields
  sum: driverstandings_sum_fields
  var_pop: driverstandings_var_pop_fields
  var_samp: driverstandings_var_samp_fields
  variance: driverstandings_variance_fields
}

"""
order by aggregate values of table "driverstandings"
"""
input driverstandings_aggregate_order_by {
  avg: driverstandings_avg_order_by
  count: order_by
  max: driverstandings_max_order_by
  min: driverstandings_min_order_by
  stddev: driverstandings_stddev_order_by
  stddev_pop: driverstandings_stddev_pop_order_by
  stddev_samp: driverstandings_stddev_samp_order_by
  sum: driverstandings_sum_order_by
  var_pop: driverstandings_var_pop_order_by
  var_samp: driverstandings_var_samp_order_by
  variance: driverstandings_variance_order_by
}

"""
input type for inserting array relation for remote table "driverstandings"
"""
input driverstandings_arr_rel_insert_input {
  data: [driverstandings_insert_input!]!
  on_conflict: driverstandings_on_conflict
}

"""aggregate avg on columns"""
type driverstandings_avg_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by avg() on columns of table "driverstandings"
"""
input driverstandings_avg_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
Boolean expression to filter rows from the table "driverstandings". All fields are combined with a logical 'AND'.
"""
input driverstandings_bool_exp {
  _and: [driverstandings_bool_exp]
  _not: driverstandings_bool_exp
  _or: [driverstandings_bool_exp]
  driver: drivers_bool_exp
  driverid: bigint_comparison_exp
  driverstandingsid: bigint_comparison_exp
  points: Float_comparison_exp
  position: bigint_comparison_exp
  positiontext: String_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  wins: bigint_comparison_exp
}

"""
unique or primary key constraints on table "driverstandings"
"""
enum driverstandings_constraint {
  """unique or primary key constraint"""
  idx_18937_driverstandings_pkey
}

"""
input type for incrementing integer column in table "driverstandings"
"""
input driverstandings_inc_input {
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  raceid: bigint
  wins: bigint
}

"""
input type for inserting data into table "driverstandings"
"""
input driverstandings_insert_input {
  driver: drivers_obj_rel_insert_input
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  race: races_obj_rel_insert_input
  raceid: bigint
  wins: bigint
}

"""aggregate max on columns"""
type driverstandings_max_fields {
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""
order by max() on columns of table "driverstandings"
"""
input driverstandings_max_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate min on columns"""
type driverstandings_min_fields {
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""
order by min() on columns of table "driverstandings"
"""
input driverstandings_min_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  raceid: order_by
  wins: order_by
}

"""
response of any mutation on the table "driverstandings"
"""
type driverstandings_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [driverstandings!]!
}

"""
input type for inserting object relation for remote table "driverstandings"
"""
input driverstandings_obj_rel_insert_input {
  data: driverstandings_insert_input!
  on_conflict: driverstandings_on_conflict
}

"""
on conflict condition type for table "driverstandings"
"""
input driverstandings_on_conflict {
  constraint: driverstandings_constraint!
  update_columns: [driverstandings_update_column!]!
  where: driverstandings_bool_exp
}

"""
ordering options when selecting data from "driverstandings"
"""
input driverstandings_order_by {
  driver: drivers_order_by
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  positiontext: order_by
  race: races_order_by
  raceid: order_by
  wins: order_by
}

"""
primary key columns input for table: "driverstandings"
"""
input driverstandings_pk_columns_input {
  driverstandingsid: bigint!
}

"""
select columns of table "driverstandings"
"""
enum driverstandings_select_column {
  """column name"""
  driverid

  """column name"""
  driverstandingsid

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  wins
}

"""
input type for updating data in table "driverstandings"
"""
input driverstandings_set_input {
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  positiontext: String
  raceid: bigint
  wins: bigint
}

"""aggregate stddev on columns"""
type driverstandings_stddev_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev() on columns of table "driverstandings"
"""
input driverstandings_stddev_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate stddev_pop on columns"""
type driverstandings_stddev_pop_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev_pop() on columns of table "driverstandings"
"""
input driverstandings_stddev_pop_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate stddev_samp on columns"""
type driverstandings_stddev_samp_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by stddev_samp() on columns of table "driverstandings"
"""
input driverstandings_stddev_samp_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate sum on columns"""
type driverstandings_sum_fields {
  driverid: bigint
  driverstandingsid: bigint
  points: Float
  position: bigint
  raceid: bigint
  wins: bigint
}

"""
order by sum() on columns of table "driverstandings"
"""
input driverstandings_sum_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
update columns of table "driverstandings"
"""
enum driverstandings_update_column {
  """column name"""
  driverid

  """column name"""
  driverstandingsid

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  wins
}

"""aggregate var_pop on columns"""
type driverstandings_var_pop_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by var_pop() on columns of table "driverstandings"
"""
input driverstandings_var_pop_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate var_samp on columns"""
type driverstandings_var_samp_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by var_samp() on columns of table "driverstandings"
"""
input driverstandings_var_samp_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""aggregate variance on columns"""
type driverstandings_variance_fields {
  driverid: Float
  driverstandingsid: Float
  points: Float
  position: Float
  raceid: Float
  wins: Float
}

"""
order by variance() on columns of table "driverstandings"
"""
input driverstandings_variance_order_by {
  driverid: order_by
  driverstandingsid: order_by
  points: order_by
  position: order_by
  raceid: order_by
  wins: order_by
}

"""
expression to compare columns of type Float. All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

scalar float8

"""
expression to compare columns of type float8. All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "laptimes"
"""
type laptimes {
  """An object relationship"""
  driver: drivers!
  driverid: bigint!
  lap: bigint!
  milliseconds: bigint
  position: bigint

  """An object relationship"""
  race: races!
  raceid: bigint!
  time: String
}

"""
aggregated selection of "laptimes"
"""
type laptimes_aggregate {
  aggregate: laptimes_aggregate_fields
  nodes: [laptimes!]!
}

"""
aggregate fields of "laptimes"
"""
type laptimes_aggregate_fields {
  avg: laptimes_avg_fields
  count(columns: [laptimes_select_column!], distinct: Boolean): Int
  max: laptimes_max_fields
  min: laptimes_min_fields
  stddev: laptimes_stddev_fields
  stddev_pop: laptimes_stddev_pop_fields
  stddev_samp: laptimes_stddev_samp_fields
  sum: laptimes_sum_fields
  var_pop: laptimes_var_pop_fields
  var_samp: laptimes_var_samp_fields
  variance: laptimes_variance_fields
}

"""
order by aggregate values of table "laptimes"
"""
input laptimes_aggregate_order_by {
  avg: laptimes_avg_order_by
  count: order_by
  max: laptimes_max_order_by
  min: laptimes_min_order_by
  stddev: laptimes_stddev_order_by
  stddev_pop: laptimes_stddev_pop_order_by
  stddev_samp: laptimes_stddev_samp_order_by
  sum: laptimes_sum_order_by
  var_pop: laptimes_var_pop_order_by
  var_samp: laptimes_var_samp_order_by
  variance: laptimes_variance_order_by
}

"""
input type for inserting array relation for remote table "laptimes"
"""
input laptimes_arr_rel_insert_input {
  data: [laptimes_insert_input!]!
  on_conflict: laptimes_on_conflict
}

"""aggregate avg on columns"""
type laptimes_avg_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by avg() on columns of table "laptimes"
"""
input laptimes_avg_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""
Boolean expression to filter rows from the table "laptimes". All fields are combined with a logical 'AND'.
"""
input laptimes_bool_exp {
  _and: [laptimes_bool_exp]
  _not: laptimes_bool_exp
  _or: [laptimes_bool_exp]
  driver: drivers_bool_exp
  driverid: bigint_comparison_exp
  lap: bigint_comparison_exp
  milliseconds: bigint_comparison_exp
  position: bigint_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  time: String_comparison_exp
}

"""
unique or primary key constraints on table "laptimes"
"""
enum laptimes_constraint {
  """unique or primary key constraint"""
  idx_18961_laptimes_pkey

  """unique or primary key constraint"""
  idx_18961_sqlite_autoindex_laptimes_1
}

"""
input type for incrementing integer column in table "laptimes"
"""
input laptimes_inc_input {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  raceid: bigint
}

"""
input type for inserting data into table "laptimes"
"""
input laptimes_insert_input {
  driver: drivers_obj_rel_insert_input
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  race: races_obj_rel_insert_input
  raceid: bigint
  time: String
}

"""aggregate max on columns"""
type laptimes_max_fields {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  raceid: bigint
  time: String
}

"""
order by max() on columns of table "laptimes"
"""
input laptimes_max_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
  time: order_by
}

"""aggregate min on columns"""
type laptimes_min_fields {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  raceid: bigint
  time: String
}

"""
order by min() on columns of table "laptimes"
"""
input laptimes_min_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
  time: order_by
}

"""
response of any mutation on the table "laptimes"
"""
type laptimes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [laptimes!]!
}

"""
input type for inserting object relation for remote table "laptimes"
"""
input laptimes_obj_rel_insert_input {
  data: laptimes_insert_input!
  on_conflict: laptimes_on_conflict
}

"""
on conflict condition type for table "laptimes"
"""
input laptimes_on_conflict {
  constraint: laptimes_constraint!
  update_columns: [laptimes_update_column!]!
  where: laptimes_bool_exp
}

"""
ordering options when selecting data from "laptimes"
"""
input laptimes_order_by {
  driver: drivers_order_by
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  race: races_order_by
  raceid: order_by
  time: order_by
}

"""
primary key columns input for table: "laptimes"
"""
input laptimes_pk_columns_input {
  driverid: bigint!
  lap: bigint!
  raceid: bigint!
}

"""
select columns of table "laptimes"
"""
enum laptimes_select_column {
  """column name"""
  driverid

  """column name"""
  lap

  """column name"""
  milliseconds

  """column name"""
  position

  """column name"""
  raceid

  """column name"""
  time
}

"""
input type for updating data in table "laptimes"
"""
input laptimes_set_input {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  raceid: bigint
  time: String
}

"""aggregate stddev on columns"""
type laptimes_stddev_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by stddev() on columns of table "laptimes"
"""
input laptimes_stddev_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""aggregate stddev_pop on columns"""
type laptimes_stddev_pop_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by stddev_pop() on columns of table "laptimes"
"""
input laptimes_stddev_pop_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""aggregate stddev_samp on columns"""
type laptimes_stddev_samp_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by stddev_samp() on columns of table "laptimes"
"""
input laptimes_stddev_samp_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""aggregate sum on columns"""
type laptimes_sum_fields {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  position: bigint
  raceid: bigint
}

"""
order by sum() on columns of table "laptimes"
"""
input laptimes_sum_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""
update columns of table "laptimes"
"""
enum laptimes_update_column {
  """column name"""
  driverid

  """column name"""
  lap

  """column name"""
  milliseconds

  """column name"""
  position

  """column name"""
  raceid

  """column name"""
  time
}

"""aggregate var_pop on columns"""
type laptimes_var_pop_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by var_pop() on columns of table "laptimes"
"""
input laptimes_var_pop_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""aggregate var_samp on columns"""
type laptimes_var_samp_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by var_samp() on columns of table "laptimes"
"""
input laptimes_var_samp_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""aggregate variance on columns"""
type laptimes_variance_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  position: Float
  raceid: Float
}

"""
order by variance() on columns of table "laptimes"
"""
input laptimes_variance_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  position: order_by
  raceid: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "circuits"
  """
  delete_circuits(
    """filter the rows which have to be deleted"""
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  delete single row from the table: "circuits"
  """
  delete_circuits_by_pk(circuitid: bigint!): circuits

  """
  delete data from the table: "constructorresults"
  """
  delete_constructorresults(
    """filter the rows which have to be deleted"""
    where: constructorresults_bool_exp!
  ): constructorresults_mutation_response

  """
  delete single row from the table: "constructorresults"
  """
  delete_constructorresults_by_pk(constructorresultsid: bigint!): constructorresults

  """
  delete data from the table: "constructors"
  """
  delete_constructors(
    """filter the rows which have to be deleted"""
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  delete single row from the table: "constructors"
  """
  delete_constructors_by_pk(constructorid: bigint!): constructors

  """
  delete data from the table: "constructorstandings"
  """
  delete_constructorstandings(
    """filter the rows which have to be deleted"""
    where: constructorstandings_bool_exp!
  ): constructorstandings_mutation_response

  """
  delete single row from the table: "constructorstandings"
  """
  delete_constructorstandings_by_pk(constructorstandingsid: bigint!): constructorstandings

  """
  delete data from the table: "drivers"
  """
  delete_drivers(
    """filter the rows which have to be deleted"""
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  delete single row from the table: "drivers"
  """
  delete_drivers_by_pk(driverid: bigint!): drivers

  """
  delete data from the table: "driverstandings"
  """
  delete_driverstandings(
    """filter the rows which have to be deleted"""
    where: driverstandings_bool_exp!
  ): driverstandings_mutation_response

  """
  delete single row from the table: "driverstandings"
  """
  delete_driverstandings_by_pk(driverstandingsid: bigint!): driverstandings

  """
  delete data from the table: "laptimes"
  """
  delete_laptimes(
    """filter the rows which have to be deleted"""
    where: laptimes_bool_exp!
  ): laptimes_mutation_response

  """
  delete single row from the table: "laptimes"
  """
  delete_laptimes_by_pk(driverid: bigint!, lap: bigint!, raceid: bigint!): laptimes

  """
  delete data from the table: "pitstops"
  """
  delete_pitstops(
    """filter the rows which have to be deleted"""
    where: pitstops_bool_exp!
  ): pitstops_mutation_response

  """
  delete single row from the table: "pitstops"
  """
  delete_pitstops_by_pk(driverid: bigint!, raceid: bigint!, stop: bigint!): pitstops

  """
  delete data from the table: "qualifying"
  """
  delete_qualifying(
    """filter the rows which have to be deleted"""
    where: qualifying_bool_exp!
  ): qualifying_mutation_response

  """
  delete single row from the table: "qualifying"
  """
  delete_qualifying_by_pk(qualifyid: bigint!): qualifying

  """
  delete data from the table: "races"
  """
  delete_races(
    """filter the rows which have to be deleted"""
    where: races_bool_exp!
  ): races_mutation_response

  """
  delete single row from the table: "races"
  """
  delete_races_by_pk(raceid: bigint!): races

  """
  delete data from the table: "results"
  """
  delete_results(
    """filter the rows which have to be deleted"""
    where: results_bool_exp!
  ): results_mutation_response

  """
  delete single row from the table: "results"
  """
  delete_results_by_pk(resultid: bigint!): results

  """
  delete data from the table: "seasons"
  """
  delete_seasons(
    """filter the rows which have to be deleted"""
    where: seasons_bool_exp!
  ): seasons_mutation_response

  """
  delete single row from the table: "seasons"
  """
  delete_seasons_by_pk(year: bigint!): seasons

  """
  delete data from the table: "status"
  """
  delete_status(
    """filter the rows which have to be deleted"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  delete single row from the table: "status"
  """
  delete_status_by_pk(statusid: bigint!): status

  """
  insert data into the table: "circuits"
  """
  insert_circuits(
    """the rows to be inserted"""
    objects: [circuits_insert_input!]!

    """on conflict condition"""
    on_conflict: circuits_on_conflict
  ): circuits_mutation_response

  """
  insert a single row into the table: "circuits"
  """
  insert_circuits_one(
    """the row to be inserted"""
    object: circuits_insert_input!

    """on conflict condition"""
    on_conflict: circuits_on_conflict
  ): circuits

  """
  insert data into the table: "constructorresults"
  """
  insert_constructorresults(
    """the rows to be inserted"""
    objects: [constructorresults_insert_input!]!

    """on conflict condition"""
    on_conflict: constructorresults_on_conflict
  ): constructorresults_mutation_response

  """
  insert a single row into the table: "constructorresults"
  """
  insert_constructorresults_one(
    """the row to be inserted"""
    object: constructorresults_insert_input!

    """on conflict condition"""
    on_conflict: constructorresults_on_conflict
  ): constructorresults

  """
  insert data into the table: "constructors"
  """
  insert_constructors(
    """the rows to be inserted"""
    objects: [constructors_insert_input!]!

    """on conflict condition"""
    on_conflict: constructors_on_conflict
  ): constructors_mutation_response

  """
  insert a single row into the table: "constructors"
  """
  insert_constructors_one(
    """the row to be inserted"""
    object: constructors_insert_input!

    """on conflict condition"""
    on_conflict: constructors_on_conflict
  ): constructors

  """
  insert data into the table: "constructorstandings"
  """
  insert_constructorstandings(
    """the rows to be inserted"""
    objects: [constructorstandings_insert_input!]!

    """on conflict condition"""
    on_conflict: constructorstandings_on_conflict
  ): constructorstandings_mutation_response

  """
  insert a single row into the table: "constructorstandings"
  """
  insert_constructorstandings_one(
    """the row to be inserted"""
    object: constructorstandings_insert_input!

    """on conflict condition"""
    on_conflict: constructorstandings_on_conflict
  ): constructorstandings

  """
  insert data into the table: "drivers"
  """
  insert_drivers(
    """the rows to be inserted"""
    objects: [drivers_insert_input!]!

    """on conflict condition"""
    on_conflict: drivers_on_conflict
  ): drivers_mutation_response

  """
  insert a single row into the table: "drivers"
  """
  insert_drivers_one(
    """the row to be inserted"""
    object: drivers_insert_input!

    """on conflict condition"""
    on_conflict: drivers_on_conflict
  ): drivers

  """
  insert data into the table: "driverstandings"
  """
  insert_driverstandings(
    """the rows to be inserted"""
    objects: [driverstandings_insert_input!]!

    """on conflict condition"""
    on_conflict: driverstandings_on_conflict
  ): driverstandings_mutation_response

  """
  insert a single row into the table: "driverstandings"
  """
  insert_driverstandings_one(
    """the row to be inserted"""
    object: driverstandings_insert_input!

    """on conflict condition"""
    on_conflict: driverstandings_on_conflict
  ): driverstandings

  """
  insert data into the table: "laptimes"
  """
  insert_laptimes(
    """the rows to be inserted"""
    objects: [laptimes_insert_input!]!

    """on conflict condition"""
    on_conflict: laptimes_on_conflict
  ): laptimes_mutation_response

  """
  insert a single row into the table: "laptimes"
  """
  insert_laptimes_one(
    """the row to be inserted"""
    object: laptimes_insert_input!

    """on conflict condition"""
    on_conflict: laptimes_on_conflict
  ): laptimes

  """
  insert data into the table: "pitstops"
  """
  insert_pitstops(
    """the rows to be inserted"""
    objects: [pitstops_insert_input!]!

    """on conflict condition"""
    on_conflict: pitstops_on_conflict
  ): pitstops_mutation_response

  """
  insert a single row into the table: "pitstops"
  """
  insert_pitstops_one(
    """the row to be inserted"""
    object: pitstops_insert_input!

    """on conflict condition"""
    on_conflict: pitstops_on_conflict
  ): pitstops

  """
  insert data into the table: "qualifying"
  """
  insert_qualifying(
    """the rows to be inserted"""
    objects: [qualifying_insert_input!]!

    """on conflict condition"""
    on_conflict: qualifying_on_conflict
  ): qualifying_mutation_response

  """
  insert a single row into the table: "qualifying"
  """
  insert_qualifying_one(
    """the row to be inserted"""
    object: qualifying_insert_input!

    """on conflict condition"""
    on_conflict: qualifying_on_conflict
  ): qualifying

  """
  insert data into the table: "races"
  """
  insert_races(
    """the rows to be inserted"""
    objects: [races_insert_input!]!

    """on conflict condition"""
    on_conflict: races_on_conflict
  ): races_mutation_response

  """
  insert a single row into the table: "races"
  """
  insert_races_one(
    """the row to be inserted"""
    object: races_insert_input!

    """on conflict condition"""
    on_conflict: races_on_conflict
  ): races

  """
  insert data into the table: "results"
  """
  insert_results(
    """the rows to be inserted"""
    objects: [results_insert_input!]!

    """on conflict condition"""
    on_conflict: results_on_conflict
  ): results_mutation_response

  """
  insert a single row into the table: "results"
  """
  insert_results_one(
    """the row to be inserted"""
    object: results_insert_input!

    """on conflict condition"""
    on_conflict: results_on_conflict
  ): results

  """
  insert data into the table: "seasons"
  """
  insert_seasons(
    """the rows to be inserted"""
    objects: [seasons_insert_input!]!

    """on conflict condition"""
    on_conflict: seasons_on_conflict
  ): seasons_mutation_response

  """
  insert a single row into the table: "seasons"
  """
  insert_seasons_one(
    """the row to be inserted"""
    object: seasons_insert_input!

    """on conflict condition"""
    on_conflict: seasons_on_conflict
  ): seasons

  """
  insert data into the table: "status"
  """
  insert_status(
    """the rows to be inserted"""
    objects: [status_insert_input!]!

    """on conflict condition"""
    on_conflict: status_on_conflict
  ): status_mutation_response

  """
  insert a single row into the table: "status"
  """
  insert_status_one(
    """the row to be inserted"""
    object: status_insert_input!

    """on conflict condition"""
    on_conflict: status_on_conflict
  ): status

  """
  update data of the table: "circuits"
  """
  update_circuits(
    """increments the integer columns with given value of the filtered values"""
    _inc: circuits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: circuits_set_input

    """filter the rows which have to be updated"""
    where: circuits_bool_exp!
  ): circuits_mutation_response

  """
  update single row of the table: "circuits"
  """
  update_circuits_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: circuits_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: circuits_set_input
    pk_columns: circuits_pk_columns_input!
  ): circuits

  """
  update data of the table: "constructorresults"
  """
  update_constructorresults(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructorresults_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructorresults_set_input

    """filter the rows which have to be updated"""
    where: constructorresults_bool_exp!
  ): constructorresults_mutation_response

  """
  update single row of the table: "constructorresults"
  """
  update_constructorresults_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructorresults_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructorresults_set_input
    pk_columns: constructorresults_pk_columns_input!
  ): constructorresults

  """
  update data of the table: "constructors"
  """
  update_constructors(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructors_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructors_set_input

    """filter the rows which have to be updated"""
    where: constructors_bool_exp!
  ): constructors_mutation_response

  """
  update single row of the table: "constructors"
  """
  update_constructors_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructors_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructors_set_input
    pk_columns: constructors_pk_columns_input!
  ): constructors

  """
  update data of the table: "constructorstandings"
  """
  update_constructorstandings(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructorstandings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructorstandings_set_input

    """filter the rows which have to be updated"""
    where: constructorstandings_bool_exp!
  ): constructorstandings_mutation_response

  """
  update single row of the table: "constructorstandings"
  """
  update_constructorstandings_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: constructorstandings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: constructorstandings_set_input
    pk_columns: constructorstandings_pk_columns_input!
  ): constructorstandings

  """
  update data of the table: "drivers"
  """
  update_drivers(
    """increments the integer columns with given value of the filtered values"""
    _inc: drivers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: drivers_set_input

    """filter the rows which have to be updated"""
    where: drivers_bool_exp!
  ): drivers_mutation_response

  """
  update single row of the table: "drivers"
  """
  update_drivers_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: drivers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: drivers_set_input
    pk_columns: drivers_pk_columns_input!
  ): drivers

  """
  update data of the table: "driverstandings"
  """
  update_driverstandings(
    """increments the integer columns with given value of the filtered values"""
    _inc: driverstandings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: driverstandings_set_input

    """filter the rows which have to be updated"""
    where: driverstandings_bool_exp!
  ): driverstandings_mutation_response

  """
  update single row of the table: "driverstandings"
  """
  update_driverstandings_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: driverstandings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: driverstandings_set_input
    pk_columns: driverstandings_pk_columns_input!
  ): driverstandings

  """
  update data of the table: "laptimes"
  """
  update_laptimes(
    """increments the integer columns with given value of the filtered values"""
    _inc: laptimes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laptimes_set_input

    """filter the rows which have to be updated"""
    where: laptimes_bool_exp!
  ): laptimes_mutation_response

  """
  update single row of the table: "laptimes"
  """
  update_laptimes_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: laptimes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: laptimes_set_input
    pk_columns: laptimes_pk_columns_input!
  ): laptimes

  """
  update data of the table: "pitstops"
  """
  update_pitstops(
    """increments the integer columns with given value of the filtered values"""
    _inc: pitstops_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pitstops_set_input

    """filter the rows which have to be updated"""
    where: pitstops_bool_exp!
  ): pitstops_mutation_response

  """
  update single row of the table: "pitstops"
  """
  update_pitstops_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: pitstops_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pitstops_set_input
    pk_columns: pitstops_pk_columns_input!
  ): pitstops

  """
  update data of the table: "qualifying"
  """
  update_qualifying(
    """increments the integer columns with given value of the filtered values"""
    _inc: qualifying_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: qualifying_set_input

    """filter the rows which have to be updated"""
    where: qualifying_bool_exp!
  ): qualifying_mutation_response

  """
  update single row of the table: "qualifying"
  """
  update_qualifying_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: qualifying_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: qualifying_set_input
    pk_columns: qualifying_pk_columns_input!
  ): qualifying

  """
  update data of the table: "races"
  """
  update_races(
    """increments the integer columns with given value of the filtered values"""
    _inc: races_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: races_set_input

    """filter the rows which have to be updated"""
    where: races_bool_exp!
  ): races_mutation_response

  """
  update single row of the table: "races"
  """
  update_races_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: races_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: races_set_input
    pk_columns: races_pk_columns_input!
  ): races

  """
  update data of the table: "results"
  """
  update_results(
    """increments the integer columns with given value of the filtered values"""
    _inc: results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: results_set_input

    """filter the rows which have to be updated"""
    where: results_bool_exp!
  ): results_mutation_response

  """
  update single row of the table: "results"
  """
  update_results_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: results_set_input
    pk_columns: results_pk_columns_input!
  ): results

  """
  update data of the table: "seasons"
  """
  update_seasons(
    """increments the integer columns with given value of the filtered values"""
    _inc: seasons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: seasons_set_input

    """filter the rows which have to be updated"""
    where: seasons_bool_exp!
  ): seasons_mutation_response

  """
  update single row of the table: "seasons"
  """
  update_seasons_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: seasons_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: seasons_set_input
    pk_columns: seasons_pk_columns_input!
  ): seasons

  """
  update data of the table: "status"
  """
  update_status(
    """increments the integer columns with given value of the filtered values"""
    _inc: status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input

    """filter the rows which have to be updated"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  update single row of the table: "status"
  """
  update_status_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input
    pk_columns: status_pk_columns_input!
  ): status
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "pitstops"
"""
type pitstops {
  """An object relationship"""
  driver: drivers!
  driverid: bigint!
  duration: String
  lap: bigint
  milliseconds: bigint

  """An object relationship"""
  race: races!
  raceid: bigint!
  stop: bigint!
  time: String
}

"""
aggregated selection of "pitstops"
"""
type pitstops_aggregate {
  aggregate: pitstops_aggregate_fields
  nodes: [pitstops!]!
}

"""
aggregate fields of "pitstops"
"""
type pitstops_aggregate_fields {
  avg: pitstops_avg_fields
  count(columns: [pitstops_select_column!], distinct: Boolean): Int
  max: pitstops_max_fields
  min: pitstops_min_fields
  stddev: pitstops_stddev_fields
  stddev_pop: pitstops_stddev_pop_fields
  stddev_samp: pitstops_stddev_samp_fields
  sum: pitstops_sum_fields
  var_pop: pitstops_var_pop_fields
  var_samp: pitstops_var_samp_fields
  variance: pitstops_variance_fields
}

"""
order by aggregate values of table "pitstops"
"""
input pitstops_aggregate_order_by {
  avg: pitstops_avg_order_by
  count: order_by
  max: pitstops_max_order_by
  min: pitstops_min_order_by
  stddev: pitstops_stddev_order_by
  stddev_pop: pitstops_stddev_pop_order_by
  stddev_samp: pitstops_stddev_samp_order_by
  sum: pitstops_sum_order_by
  var_pop: pitstops_var_pop_order_by
  var_samp: pitstops_var_samp_order_by
  variance: pitstops_variance_order_by
}

"""
input type for inserting array relation for remote table "pitstops"
"""
input pitstops_arr_rel_insert_input {
  data: [pitstops_insert_input!]!
  on_conflict: pitstops_on_conflict
}

"""aggregate avg on columns"""
type pitstops_avg_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by avg() on columns of table "pitstops"
"""
input pitstops_avg_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""
Boolean expression to filter rows from the table "pitstops". All fields are combined with a logical 'AND'.
"""
input pitstops_bool_exp {
  _and: [pitstops_bool_exp]
  _not: pitstops_bool_exp
  _or: [pitstops_bool_exp]
  driver: drivers_bool_exp
  driverid: bigint_comparison_exp
  duration: String_comparison_exp
  lap: bigint_comparison_exp
  milliseconds: bigint_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  stop: bigint_comparison_exp
  time: String_comparison_exp
}

"""
unique or primary key constraints on table "pitstops"
"""
enum pitstops_constraint {
  """unique or primary key constraint"""
  idx_18955_pitstops_pkey

  """unique or primary key constraint"""
  idx_18955_sqlite_autoindex_pitstops_1
}

"""
input type for incrementing integer column in table "pitstops"
"""
input pitstops_inc_input {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  raceid: bigint
  stop: bigint
}

"""
input type for inserting data into table "pitstops"
"""
input pitstops_insert_input {
  driver: drivers_obj_rel_insert_input
  driverid: bigint
  duration: String
  lap: bigint
  milliseconds: bigint
  race: races_obj_rel_insert_input
  raceid: bigint
  stop: bigint
  time: String
}

"""aggregate max on columns"""
type pitstops_max_fields {
  driverid: bigint
  duration: String
  lap: bigint
  milliseconds: bigint
  raceid: bigint
  stop: bigint
  time: String
}

"""
order by max() on columns of table "pitstops"
"""
input pitstops_max_order_by {
  driverid: order_by
  duration: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
  time: order_by
}

"""aggregate min on columns"""
type pitstops_min_fields {
  driverid: bigint
  duration: String
  lap: bigint
  milliseconds: bigint
  raceid: bigint
  stop: bigint
  time: String
}

"""
order by min() on columns of table "pitstops"
"""
input pitstops_min_order_by {
  driverid: order_by
  duration: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
  time: order_by
}

"""
response of any mutation on the table "pitstops"
"""
type pitstops_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [pitstops!]!
}

"""
input type for inserting object relation for remote table "pitstops"
"""
input pitstops_obj_rel_insert_input {
  data: pitstops_insert_input!
  on_conflict: pitstops_on_conflict
}

"""
on conflict condition type for table "pitstops"
"""
input pitstops_on_conflict {
  constraint: pitstops_constraint!
  update_columns: [pitstops_update_column!]!
  where: pitstops_bool_exp
}

"""
ordering options when selecting data from "pitstops"
"""
input pitstops_order_by {
  driver: drivers_order_by
  driverid: order_by
  duration: order_by
  lap: order_by
  milliseconds: order_by
  race: races_order_by
  raceid: order_by
  stop: order_by
  time: order_by
}

"""
primary key columns input for table: "pitstops"
"""
input pitstops_pk_columns_input {
  driverid: bigint!
  raceid: bigint!
  stop: bigint!
}

"""
select columns of table "pitstops"
"""
enum pitstops_select_column {
  """column name"""
  driverid

  """column name"""
  duration

  """column name"""
  lap

  """column name"""
  milliseconds

  """column name"""
  raceid

  """column name"""
  stop

  """column name"""
  time
}

"""
input type for updating data in table "pitstops"
"""
input pitstops_set_input {
  driverid: bigint
  duration: String
  lap: bigint
  milliseconds: bigint
  raceid: bigint
  stop: bigint
  time: String
}

"""aggregate stddev on columns"""
type pitstops_stddev_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by stddev() on columns of table "pitstops"
"""
input pitstops_stddev_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""aggregate stddev_pop on columns"""
type pitstops_stddev_pop_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by stddev_pop() on columns of table "pitstops"
"""
input pitstops_stddev_pop_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""aggregate stddev_samp on columns"""
type pitstops_stddev_samp_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by stddev_samp() on columns of table "pitstops"
"""
input pitstops_stddev_samp_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""aggregate sum on columns"""
type pitstops_sum_fields {
  driverid: bigint
  lap: bigint
  milliseconds: bigint
  raceid: bigint
  stop: bigint
}

"""
order by sum() on columns of table "pitstops"
"""
input pitstops_sum_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""
update columns of table "pitstops"
"""
enum pitstops_update_column {
  """column name"""
  driverid

  """column name"""
  duration

  """column name"""
  lap

  """column name"""
  milliseconds

  """column name"""
  raceid

  """column name"""
  stop

  """column name"""
  time
}

"""aggregate var_pop on columns"""
type pitstops_var_pop_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by var_pop() on columns of table "pitstops"
"""
input pitstops_var_pop_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""aggregate var_samp on columns"""
type pitstops_var_samp_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by var_samp() on columns of table "pitstops"
"""
input pitstops_var_samp_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""aggregate variance on columns"""
type pitstops_variance_fields {
  driverid: Float
  lap: Float
  milliseconds: Float
  raceid: Float
  stop: Float
}

"""
order by variance() on columns of table "pitstops"
"""
input pitstops_variance_order_by {
  driverid: order_by
  lap: order_by
  milliseconds: order_by
  raceid: order_by
  stop: order_by
}

"""
columns and relationships of "qualifying"
"""
type qualifying {
  """An object relationship"""
  constructor: constructors
  constructorid: bigint

  """An object relationship"""
  driver: drivers
  driverid: bigint
  number: bigint
  position: bigint
  q1: String
  q2: String
  q3: String
  qualifyid: bigint!

  """An object relationship"""
  race: races
  raceid: bigint
}

"""
aggregated selection of "qualifying"
"""
type qualifying_aggregate {
  aggregate: qualifying_aggregate_fields
  nodes: [qualifying!]!
}

"""
aggregate fields of "qualifying"
"""
type qualifying_aggregate_fields {
  avg: qualifying_avg_fields
  count(columns: [qualifying_select_column!], distinct: Boolean): Int
  max: qualifying_max_fields
  min: qualifying_min_fields
  stddev: qualifying_stddev_fields
  stddev_pop: qualifying_stddev_pop_fields
  stddev_samp: qualifying_stddev_samp_fields
  sum: qualifying_sum_fields
  var_pop: qualifying_var_pop_fields
  var_samp: qualifying_var_samp_fields
  variance: qualifying_variance_fields
}

"""
order by aggregate values of table "qualifying"
"""
input qualifying_aggregate_order_by {
  avg: qualifying_avg_order_by
  count: order_by
  max: qualifying_max_order_by
  min: qualifying_min_order_by
  stddev: qualifying_stddev_order_by
  stddev_pop: qualifying_stddev_pop_order_by
  stddev_samp: qualifying_stddev_samp_order_by
  sum: qualifying_sum_order_by
  var_pop: qualifying_var_pop_order_by
  var_samp: qualifying_var_samp_order_by
  variance: qualifying_variance_order_by
}

"""
input type for inserting array relation for remote table "qualifying"
"""
input qualifying_arr_rel_insert_input {
  data: [qualifying_insert_input!]!
  on_conflict: qualifying_on_conflict
}

"""aggregate avg on columns"""
type qualifying_avg_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by avg() on columns of table "qualifying"
"""
input qualifying_avg_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""
Boolean expression to filter rows from the table "qualifying". All fields are combined with a logical 'AND'.
"""
input qualifying_bool_exp {
  _and: [qualifying_bool_exp]
  _not: qualifying_bool_exp
  _or: [qualifying_bool_exp]
  constructor: constructors_bool_exp
  constructorid: bigint_comparison_exp
  driver: drivers_bool_exp
  driverid: bigint_comparison_exp
  number: bigint_comparison_exp
  position: bigint_comparison_exp
  q1: String_comparison_exp
  q2: String_comparison_exp
  q3: String_comparison_exp
  qualifyid: bigint_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
}

"""
unique or primary key constraints on table "qualifying"
"""
enum qualifying_constraint {
  """unique or primary key constraint"""
  idx_18949_qualifying_pkey
}

"""
input type for incrementing integer column in table "qualifying"
"""
input qualifying_inc_input {
  constructorid: bigint
  driverid: bigint
  number: bigint
  position: bigint
  qualifyid: bigint
  raceid: bigint
}

"""
input type for inserting data into table "qualifying"
"""
input qualifying_insert_input {
  constructor: constructors_obj_rel_insert_input
  constructorid: bigint
  driver: drivers_obj_rel_insert_input
  driverid: bigint
  number: bigint
  position: bigint
  q1: String
  q2: String
  q3: String
  qualifyid: bigint
  race: races_obj_rel_insert_input
  raceid: bigint
}

"""aggregate max on columns"""
type qualifying_max_fields {
  constructorid: bigint
  driverid: bigint
  number: bigint
  position: bigint
  q1: String
  q2: String
  q3: String
  qualifyid: bigint
  raceid: bigint
}

"""
order by max() on columns of table "qualifying"
"""
input qualifying_max_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  q1: order_by
  q2: order_by
  q3: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate min on columns"""
type qualifying_min_fields {
  constructorid: bigint
  driverid: bigint
  number: bigint
  position: bigint
  q1: String
  q2: String
  q3: String
  qualifyid: bigint
  raceid: bigint
}

"""
order by min() on columns of table "qualifying"
"""
input qualifying_min_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  q1: order_by
  q2: order_by
  q3: order_by
  qualifyid: order_by
  raceid: order_by
}

"""
response of any mutation on the table "qualifying"
"""
type qualifying_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [qualifying!]!
}

"""
input type for inserting object relation for remote table "qualifying"
"""
input qualifying_obj_rel_insert_input {
  data: qualifying_insert_input!
  on_conflict: qualifying_on_conflict
}

"""
on conflict condition type for table "qualifying"
"""
input qualifying_on_conflict {
  constraint: qualifying_constraint!
  update_columns: [qualifying_update_column!]!
  where: qualifying_bool_exp
}

"""
ordering options when selecting data from "qualifying"
"""
input qualifying_order_by {
  constructor: constructors_order_by
  constructorid: order_by
  driver: drivers_order_by
  driverid: order_by
  number: order_by
  position: order_by
  q1: order_by
  q2: order_by
  q3: order_by
  qualifyid: order_by
  race: races_order_by
  raceid: order_by
}

"""
primary key columns input for table: "qualifying"
"""
input qualifying_pk_columns_input {
  qualifyid: bigint!
}

"""
select columns of table "qualifying"
"""
enum qualifying_select_column {
  """column name"""
  constructorid

  """column name"""
  driverid

  """column name"""
  number

  """column name"""
  position

  """column name"""
  q1

  """column name"""
  q2

  """column name"""
  q3

  """column name"""
  qualifyid

  """column name"""
  raceid
}

"""
input type for updating data in table "qualifying"
"""
input qualifying_set_input {
  constructorid: bigint
  driverid: bigint
  number: bigint
  position: bigint
  q1: String
  q2: String
  q3: String
  qualifyid: bigint
  raceid: bigint
}

"""aggregate stddev on columns"""
type qualifying_stddev_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by stddev() on columns of table "qualifying"
"""
input qualifying_stddev_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate stddev_pop on columns"""
type qualifying_stddev_pop_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by stddev_pop() on columns of table "qualifying"
"""
input qualifying_stddev_pop_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate stddev_samp on columns"""
type qualifying_stddev_samp_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by stddev_samp() on columns of table "qualifying"
"""
input qualifying_stddev_samp_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate sum on columns"""
type qualifying_sum_fields {
  constructorid: bigint
  driverid: bigint
  number: bigint
  position: bigint
  qualifyid: bigint
  raceid: bigint
}

"""
order by sum() on columns of table "qualifying"
"""
input qualifying_sum_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""
update columns of table "qualifying"
"""
enum qualifying_update_column {
  """column name"""
  constructorid

  """column name"""
  driverid

  """column name"""
  number

  """column name"""
  position

  """column name"""
  q1

  """column name"""
  q2

  """column name"""
  q3

  """column name"""
  qualifyid

  """column name"""
  raceid
}

"""aggregate var_pop on columns"""
type qualifying_var_pop_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by var_pop() on columns of table "qualifying"
"""
input qualifying_var_pop_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate var_samp on columns"""
type qualifying_var_samp_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by var_samp() on columns of table "qualifying"
"""
input qualifying_var_samp_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""aggregate variance on columns"""
type qualifying_variance_fields {
  constructorid: Float
  driverid: Float
  number: Float
  position: Float
  qualifyid: Float
  raceid: Float
}

"""
order by variance() on columns of table "qualifying"
"""
input qualifying_variance_order_by {
  constructorid: order_by
  driverid: order_by
  number: order_by
  position: order_by
  qualifyid: order_by
  raceid: order_by
}

"""query root"""
type query_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """distinct select on columns"""
    distinct_on: [circuits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circuits_order_by!]

    """filter the rows returned"""
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """distinct select on columns"""
    distinct_on: [circuits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circuits_order_by!]

    """filter the rows returned"""
    where: circuits_bool_exp
  ): circuits_aggregate!

  """fetch data from the table: "circuits" using primary key columns"""
  circuits_by_pk(circuitid: bigint!): circuits

  """
  fetch data from the table: "constructorresults"
  """
  constructorresults(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): [constructorresults!]!

  """
  fetch aggregated fields from the table: "constructorresults"
  """
  constructorresults_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): constructorresults_aggregate!

  """
  fetch data from the table: "constructorresults" using primary key columns
  """
  constructorresults_by_pk(constructorresultsid: bigint!): constructorresults

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """distinct select on columns"""
    distinct_on: [constructors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructors_order_by!]

    """filter the rows returned"""
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """distinct select on columns"""
    distinct_on: [constructors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructors_order_by!]

    """filter the rows returned"""
    where: constructors_bool_exp
  ): constructors_aggregate!

  """fetch data from the table: "constructors" using primary key columns"""
  constructors_by_pk(constructorid: bigint!): constructors

  """
  fetch data from the table: "constructorstandings"
  """
  constructorstandings(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): [constructorstandings!]!

  """
  fetch aggregated fields from the table: "constructorstandings"
  """
  constructorstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): constructorstandings_aggregate!

  """
  fetch data from the table: "constructorstandings" using primary key columns
  """
  constructorstandings_by_pk(constructorstandingsid: bigint!): constructorstandings

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """distinct select on columns"""
    distinct_on: [drivers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drivers_order_by!]

    """filter the rows returned"""
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [drivers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drivers_order_by!]

    """filter the rows returned"""
    where: drivers_bool_exp
  ): drivers_aggregate!

  """fetch data from the table: "drivers" using primary key columns"""
  drivers_by_pk(driverid: bigint!): drivers

  """
  fetch data from the table: "driverstandings"
  """
  driverstandings(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): [driverstandings!]!

  """
  fetch aggregated fields from the table: "driverstandings"
  """
  driverstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): driverstandings_aggregate!

  """fetch data from the table: "driverstandings" using primary key columns"""
  driverstandings_by_pk(driverstandingsid: bigint!): driverstandings

  """
  fetch data from the table: "laptimes"
  """
  laptimes(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): [laptimes!]!

  """
  fetch aggregated fields from the table: "laptimes"
  """
  laptimes_aggregate(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): laptimes_aggregate!

  """fetch data from the table: "laptimes" using primary key columns"""
  laptimes_by_pk(driverid: bigint!, lap: bigint!, raceid: bigint!): laptimes

  """
  fetch data from the table: "pitstops"
  """
  pitstops(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): [pitstops!]!

  """
  fetch aggregated fields from the table: "pitstops"
  """
  pitstops_aggregate(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): pitstops_aggregate!

  """fetch data from the table: "pitstops" using primary key columns"""
  pitstops_by_pk(driverid: bigint!, raceid: bigint!, stop: bigint!): pitstops

  """
  fetch data from the table: "qualifying"
  """
  qualifying(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): [qualifying!]!

  """
  fetch aggregated fields from the table: "qualifying"
  """
  qualifying_aggregate(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): qualifying_aggregate!

  """fetch data from the table: "qualifying" using primary key columns"""
  qualifying_by_pk(qualifyid: bigint!): qualifying

  """
  fetch data from the table: "races"
  """
  races(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): [races!]!

  """
  fetch aggregated fields from the table: "races"
  """
  races_aggregate(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): races_aggregate!

  """fetch data from the table: "races" using primary key columns"""
  races_by_pk(raceid: bigint!): races

  """
  fetch data from the table: "results"
  """
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """
  fetch aggregated fields from the table: "results"
  """
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!

  """fetch data from the table: "results" using primary key columns"""
  results_by_pk(resultid: bigint!): results

  """
  fetch data from the table: "seasons"
  """
  seasons(
    """distinct select on columns"""
    distinct_on: [seasons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seasons_order_by!]

    """filter the rows returned"""
    where: seasons_bool_exp
  ): [seasons!]!

  """
  fetch aggregated fields from the table: "seasons"
  """
  seasons_aggregate(
    """distinct select on columns"""
    distinct_on: [seasons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seasons_order_by!]

    """filter the rows returned"""
    where: seasons_bool_exp
  ): seasons_aggregate!

  """fetch data from the table: "seasons" using primary key columns"""
  seasons_by_pk(year: bigint!): seasons

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(statusid: bigint!): status
}

"""
columns and relationships of "races"
"""
type races {
  """An object relationship"""
  circuit: circuits
  circuitid: bigint

  """An array relationship"""
  constructorresults(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): [constructorresults!]!

  """An aggregated array relationship"""
  constructorresults_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): constructorresults_aggregate!

  """An array relationship"""
  constructorstandings(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): [constructorstandings!]!

  """An aggregated array relationship"""
  constructorstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): constructorstandings_aggregate!
  date: String

  """An array relationship"""
  driverstandings(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): [driverstandings!]!

  """An aggregated array relationship"""
  driverstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): driverstandings_aggregate!

  """An array relationship"""
  laptimes(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): [laptimes!]!

  """An aggregated array relationship"""
  laptimes_aggregate(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): laptimes_aggregate!
  name: String

  """An array relationship"""
  pitstops(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): [pitstops!]!

  """An aggregated array relationship"""
  pitstops_aggregate(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): pitstops_aggregate!

  """An array relationship"""
  qualifyings(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): [qualifying!]!

  """An aggregated array relationship"""
  qualifyings_aggregate(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): qualifying_aggregate!
  raceid: bigint!

  """An array relationship"""
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """An aggregated array relationship"""
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!
  round: bigint

  """An object relationship"""
  season: seasons
  time: String
  url: String
  year: bigint
}

"""
aggregated selection of "races"
"""
type races_aggregate {
  aggregate: races_aggregate_fields
  nodes: [races!]!
}

"""
aggregate fields of "races"
"""
type races_aggregate_fields {
  avg: races_avg_fields
  count(columns: [races_select_column!], distinct: Boolean): Int
  max: races_max_fields
  min: races_min_fields
  stddev: races_stddev_fields
  stddev_pop: races_stddev_pop_fields
  stddev_samp: races_stddev_samp_fields
  sum: races_sum_fields
  var_pop: races_var_pop_fields
  var_samp: races_var_samp_fields
  variance: races_variance_fields
}

"""
order by aggregate values of table "races"
"""
input races_aggregate_order_by {
  avg: races_avg_order_by
  count: order_by
  max: races_max_order_by
  min: races_min_order_by
  stddev: races_stddev_order_by
  stddev_pop: races_stddev_pop_order_by
  stddev_samp: races_stddev_samp_order_by
  sum: races_sum_order_by
  var_pop: races_var_pop_order_by
  var_samp: races_var_samp_order_by
  variance: races_variance_order_by
}

"""
input type for inserting array relation for remote table "races"
"""
input races_arr_rel_insert_input {
  data: [races_insert_input!]!
  on_conflict: races_on_conflict
}

"""aggregate avg on columns"""
type races_avg_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by avg() on columns of table "races"
"""
input races_avg_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""
Boolean expression to filter rows from the table "races". All fields are combined with a logical 'AND'.
"""
input races_bool_exp {
  _and: [races_bool_exp]
  _not: races_bool_exp
  _or: [races_bool_exp]
  circuit: circuits_bool_exp
  circuitid: bigint_comparison_exp
  constructorresults: constructorresults_bool_exp
  constructorstandings: constructorstandings_bool_exp
  date: String_comparison_exp
  driverstandings: driverstandings_bool_exp
  laptimes: laptimes_bool_exp
  name: String_comparison_exp
  pitstops: pitstops_bool_exp
  qualifyings: qualifying_bool_exp
  raceid: bigint_comparison_exp
  results: results_bool_exp
  round: bigint_comparison_exp
  season: seasons_bool_exp
  time: String_comparison_exp
  url: String_comparison_exp
  year: bigint_comparison_exp
}

"""
unique or primary key constraints on table "races"
"""
enum races_constraint {
  """unique or primary key constraint"""
  idx_18895_races_pkey
}

"""
input type for incrementing integer column in table "races"
"""
input races_inc_input {
  circuitid: bigint
  raceid: bigint
  round: bigint
  year: bigint
}

"""
input type for inserting data into table "races"
"""
input races_insert_input {
  circuit: circuits_obj_rel_insert_input
  circuitid: bigint
  constructorresults: constructorresults_arr_rel_insert_input
  constructorstandings: constructorstandings_arr_rel_insert_input
  date: String
  driverstandings: driverstandings_arr_rel_insert_input
  laptimes: laptimes_arr_rel_insert_input
  name: String
  pitstops: pitstops_arr_rel_insert_input
  qualifyings: qualifying_arr_rel_insert_input
  raceid: bigint
  results: results_arr_rel_insert_input
  round: bigint
  season: seasons_obj_rel_insert_input
  time: String
  url: String
  year: bigint
}

"""aggregate max on columns"""
type races_max_fields {
  circuitid: bigint
  date: String
  name: String
  raceid: bigint
  round: bigint
  time: String
  url: String
  year: bigint
}

"""
order by max() on columns of table "races"
"""
input races_max_order_by {
  circuitid: order_by
  date: order_by
  name: order_by
  raceid: order_by
  round: order_by
  time: order_by
  url: order_by
  year: order_by
}

"""aggregate min on columns"""
type races_min_fields {
  circuitid: bigint
  date: String
  name: String
  raceid: bigint
  round: bigint
  time: String
  url: String
  year: bigint
}

"""
order by min() on columns of table "races"
"""
input races_min_order_by {
  circuitid: order_by
  date: order_by
  name: order_by
  raceid: order_by
  round: order_by
  time: order_by
  url: order_by
  year: order_by
}

"""
response of any mutation on the table "races"
"""
type races_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [races!]!
}

"""
input type for inserting object relation for remote table "races"
"""
input races_obj_rel_insert_input {
  data: races_insert_input!
  on_conflict: races_on_conflict
}

"""
on conflict condition type for table "races"
"""
input races_on_conflict {
  constraint: races_constraint!
  update_columns: [races_update_column!]!
  where: races_bool_exp
}

"""
ordering options when selecting data from "races"
"""
input races_order_by {
  circuit: circuits_order_by
  circuitid: order_by
  constructorresults_aggregate: constructorresults_aggregate_order_by
  constructorstandings_aggregate: constructorstandings_aggregate_order_by
  date: order_by
  driverstandings_aggregate: driverstandings_aggregate_order_by
  laptimes_aggregate: laptimes_aggregate_order_by
  name: order_by
  pitstops_aggregate: pitstops_aggregate_order_by
  qualifyings_aggregate: qualifying_aggregate_order_by
  raceid: order_by
  results_aggregate: results_aggregate_order_by
  round: order_by
  season: seasons_order_by
  time: order_by
  url: order_by
  year: order_by
}

"""
primary key columns input for table: "races"
"""
input races_pk_columns_input {
  raceid: bigint!
}

"""
select columns of table "races"
"""
enum races_select_column {
  """column name"""
  circuitid

  """column name"""
  date

  """column name"""
  name

  """column name"""
  raceid

  """column name"""
  round

  """column name"""
  time

  """column name"""
  url

  """column name"""
  year
}

"""
input type for updating data in table "races"
"""
input races_set_input {
  circuitid: bigint
  date: String
  name: String
  raceid: bigint
  round: bigint
  time: String
  url: String
  year: bigint
}

"""aggregate stddev on columns"""
type races_stddev_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by stddev() on columns of table "races"
"""
input races_stddev_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""aggregate stddev_pop on columns"""
type races_stddev_pop_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by stddev_pop() on columns of table "races"
"""
input races_stddev_pop_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""aggregate stddev_samp on columns"""
type races_stddev_samp_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by stddev_samp() on columns of table "races"
"""
input races_stddev_samp_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""aggregate sum on columns"""
type races_sum_fields {
  circuitid: bigint
  raceid: bigint
  round: bigint
  year: bigint
}

"""
order by sum() on columns of table "races"
"""
input races_sum_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""
update columns of table "races"
"""
enum races_update_column {
  """column name"""
  circuitid

  """column name"""
  date

  """column name"""
  name

  """column name"""
  raceid

  """column name"""
  round

  """column name"""
  time

  """column name"""
  url

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type races_var_pop_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by var_pop() on columns of table "races"
"""
input races_var_pop_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""aggregate var_samp on columns"""
type races_var_samp_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by var_samp() on columns of table "races"
"""
input races_var_samp_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""aggregate variance on columns"""
type races_variance_fields {
  circuitid: Float
  raceid: Float
  round: Float
  year: Float
}

"""
order by variance() on columns of table "races"
"""
input races_variance_order_by {
  circuitid: order_by
  raceid: order_by
  round: order_by
  year: order_by
}

"""
columns and relationships of "results"
"""
type results {
  """An object relationship"""
  constructor: constructors
  constructorid: bigint

  """An object relationship"""
  driver: drivers
  driverid: bigint
  fastestlap: String
  fastestlapspeed: float8
  fastestlaptime: String
  grid: bigint
  laps: String
  milliseconds: String
  number: bigint
  points: Float
  position: String
  positionorder: bigint
  positiontext: String

  """An object relationship"""
  race: races
  raceid: bigint
  rank: String
  resultid: bigint!

  """An object relationship"""
  status: status
  statusid: bigint
  time: String
}

"""
aggregated selection of "results"
"""
type results_aggregate {
  aggregate: results_aggregate_fields
  nodes: [results!]!
}

"""
aggregate fields of "results"
"""
type results_aggregate_fields {
  avg: results_avg_fields
  count(columns: [results_select_column!], distinct: Boolean): Int
  max: results_max_fields
  min: results_min_fields
  stddev: results_stddev_fields
  stddev_pop: results_stddev_pop_fields
  stddev_samp: results_stddev_samp_fields
  sum: results_sum_fields
  var_pop: results_var_pop_fields
  var_samp: results_var_samp_fields
  variance: results_variance_fields
}

"""
order by aggregate values of table "results"
"""
input results_aggregate_order_by {
  avg: results_avg_order_by
  count: order_by
  max: results_max_order_by
  min: results_min_order_by
  stddev: results_stddev_order_by
  stddev_pop: results_stddev_pop_order_by
  stddev_samp: results_stddev_samp_order_by
  sum: results_sum_order_by
  var_pop: results_var_pop_order_by
  var_samp: results_var_samp_order_by
  variance: results_variance_order_by
}

"""
input type for inserting array relation for remote table "results"
"""
input results_arr_rel_insert_input {
  data: [results_insert_input!]!
  on_conflict: results_on_conflict
}

"""aggregate avg on columns"""
type results_avg_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by avg() on columns of table "results"
"""
input results_avg_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""
Boolean expression to filter rows from the table "results". All fields are combined with a logical 'AND'.
"""
input results_bool_exp {
  _and: [results_bool_exp]
  _not: results_bool_exp
  _or: [results_bool_exp]
  constructor: constructors_bool_exp
  constructorid: bigint_comparison_exp
  driver: drivers_bool_exp
  driverid: bigint_comparison_exp
  fastestlap: String_comparison_exp
  fastestlapspeed: float8_comparison_exp
  fastestlaptime: String_comparison_exp
  grid: bigint_comparison_exp
  laps: String_comparison_exp
  milliseconds: String_comparison_exp
  number: bigint_comparison_exp
  points: Float_comparison_exp
  position: String_comparison_exp
  positionorder: bigint_comparison_exp
  positiontext: String_comparison_exp
  race: races_bool_exp
  raceid: bigint_comparison_exp
  rank: String_comparison_exp
  resultid: bigint_comparison_exp
  status: status_bool_exp
  statusid: bigint_comparison_exp
  time: String_comparison_exp
}

"""
unique or primary key constraints on table "results"
"""
enum results_constraint {
  """unique or primary key constraint"""
  idx_18931_results_pkey
}

"""
input type for incrementing integer column in table "results"
"""
input results_inc_input {
  constructorid: bigint
  driverid: bigint
  fastestlapspeed: float8
  grid: bigint
  number: bigint
  points: Float
  positionorder: bigint
  raceid: bigint
  resultid: bigint
  statusid: bigint
}

"""
input type for inserting data into table "results"
"""
input results_insert_input {
  constructor: constructors_obj_rel_insert_input
  constructorid: bigint
  driver: drivers_obj_rel_insert_input
  driverid: bigint
  fastestlap: String
  fastestlapspeed: float8
  fastestlaptime: String
  grid: bigint
  laps: String
  milliseconds: String
  number: bigint
  points: Float
  position: String
  positionorder: bigint
  positiontext: String
  race: races_obj_rel_insert_input
  raceid: bigint
  rank: String
  resultid: bigint
  status: status_obj_rel_insert_input
  statusid: bigint
  time: String
}

"""aggregate max on columns"""
type results_max_fields {
  constructorid: bigint
  driverid: bigint
  fastestlap: String
  fastestlapspeed: float8
  fastestlaptime: String
  grid: bigint
  laps: String
  milliseconds: String
  number: bigint
  points: Float
  position: String
  positionorder: bigint
  positiontext: String
  raceid: bigint
  rank: String
  resultid: bigint
  statusid: bigint
  time: String
}

"""
order by max() on columns of table "results"
"""
input results_max_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlap: order_by
  fastestlapspeed: order_by
  fastestlaptime: order_by
  grid: order_by
  laps: order_by
  milliseconds: order_by
  number: order_by
  points: order_by
  position: order_by
  positionorder: order_by
  positiontext: order_by
  raceid: order_by
  rank: order_by
  resultid: order_by
  statusid: order_by
  time: order_by
}

"""aggregate min on columns"""
type results_min_fields {
  constructorid: bigint
  driverid: bigint
  fastestlap: String
  fastestlapspeed: float8
  fastestlaptime: String
  grid: bigint
  laps: String
  milliseconds: String
  number: bigint
  points: Float
  position: String
  positionorder: bigint
  positiontext: String
  raceid: bigint
  rank: String
  resultid: bigint
  statusid: bigint
  time: String
}

"""
order by min() on columns of table "results"
"""
input results_min_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlap: order_by
  fastestlapspeed: order_by
  fastestlaptime: order_by
  grid: order_by
  laps: order_by
  milliseconds: order_by
  number: order_by
  points: order_by
  position: order_by
  positionorder: order_by
  positiontext: order_by
  raceid: order_by
  rank: order_by
  resultid: order_by
  statusid: order_by
  time: order_by
}

"""
response of any mutation on the table "results"
"""
type results_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [results!]!
}

"""
input type for inserting object relation for remote table "results"
"""
input results_obj_rel_insert_input {
  data: results_insert_input!
  on_conflict: results_on_conflict
}

"""
on conflict condition type for table "results"
"""
input results_on_conflict {
  constraint: results_constraint!
  update_columns: [results_update_column!]!
  where: results_bool_exp
}

"""
ordering options when selecting data from "results"
"""
input results_order_by {
  constructor: constructors_order_by
  constructorid: order_by
  driver: drivers_order_by
  driverid: order_by
  fastestlap: order_by
  fastestlapspeed: order_by
  fastestlaptime: order_by
  grid: order_by
  laps: order_by
  milliseconds: order_by
  number: order_by
  points: order_by
  position: order_by
  positionorder: order_by
  positiontext: order_by
  race: races_order_by
  raceid: order_by
  rank: order_by
  resultid: order_by
  status: status_order_by
  statusid: order_by
  time: order_by
}

"""
primary key columns input for table: "results"
"""
input results_pk_columns_input {
  resultid: bigint!
}

"""
select columns of table "results"
"""
enum results_select_column {
  """column name"""
  constructorid

  """column name"""
  driverid

  """column name"""
  fastestlap

  """column name"""
  fastestlapspeed

  """column name"""
  fastestlaptime

  """column name"""
  grid

  """column name"""
  laps

  """column name"""
  milliseconds

  """column name"""
  number

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positionorder

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  rank

  """column name"""
  resultid

  """column name"""
  statusid

  """column name"""
  time
}

"""
input type for updating data in table "results"
"""
input results_set_input {
  constructorid: bigint
  driverid: bigint
  fastestlap: String
  fastestlapspeed: float8
  fastestlaptime: String
  grid: bigint
  laps: String
  milliseconds: String
  number: bigint
  points: Float
  position: String
  positionorder: bigint
  positiontext: String
  raceid: bigint
  rank: String
  resultid: bigint
  statusid: bigint
  time: String
}

"""aggregate stddev on columns"""
type results_stddev_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by stddev() on columns of table "results"
"""
input results_stddev_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""aggregate stddev_pop on columns"""
type results_stddev_pop_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by stddev_pop() on columns of table "results"
"""
input results_stddev_pop_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""aggregate stddev_samp on columns"""
type results_stddev_samp_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by stddev_samp() on columns of table "results"
"""
input results_stddev_samp_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""aggregate sum on columns"""
type results_sum_fields {
  constructorid: bigint
  driverid: bigint
  fastestlapspeed: float8
  grid: bigint
  number: bigint
  points: Float
  positionorder: bigint
  raceid: bigint
  resultid: bigint
  statusid: bigint
}

"""
order by sum() on columns of table "results"
"""
input results_sum_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""
update columns of table "results"
"""
enum results_update_column {
  """column name"""
  constructorid

  """column name"""
  driverid

  """column name"""
  fastestlap

  """column name"""
  fastestlapspeed

  """column name"""
  fastestlaptime

  """column name"""
  grid

  """column name"""
  laps

  """column name"""
  milliseconds

  """column name"""
  number

  """column name"""
  points

  """column name"""
  position

  """column name"""
  positionorder

  """column name"""
  positiontext

  """column name"""
  raceid

  """column name"""
  rank

  """column name"""
  resultid

  """column name"""
  statusid

  """column name"""
  time
}

"""aggregate var_pop on columns"""
type results_var_pop_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by var_pop() on columns of table "results"
"""
input results_var_pop_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""aggregate var_samp on columns"""
type results_var_samp_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by var_samp() on columns of table "results"
"""
input results_var_samp_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""aggregate variance on columns"""
type results_variance_fields {
  constructorid: Float
  driverid: Float
  fastestlapspeed: Float
  grid: Float
  number: Float
  points: Float
  positionorder: Float
  raceid: Float
  resultid: Float
  statusid: Float
}

"""
order by variance() on columns of table "results"
"""
input results_variance_order_by {
  constructorid: order_by
  driverid: order_by
  fastestlapspeed: order_by
  grid: order_by
  number: order_by
  points: order_by
  positionorder: order_by
  raceid: order_by
  resultid: order_by
  statusid: order_by
}

"""
columns and relationships of "seasons"
"""
type seasons {
  """An array relationship"""
  races(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): [races!]!

  """An aggregated array relationship"""
  races_aggregate(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): races_aggregate!
  url: String
  year: bigint!
}

"""
aggregated selection of "seasons"
"""
type seasons_aggregate {
  aggregate: seasons_aggregate_fields
  nodes: [seasons!]!
}

"""
aggregate fields of "seasons"
"""
type seasons_aggregate_fields {
  avg: seasons_avg_fields
  count(columns: [seasons_select_column!], distinct: Boolean): Int
  max: seasons_max_fields
  min: seasons_min_fields
  stddev: seasons_stddev_fields
  stddev_pop: seasons_stddev_pop_fields
  stddev_samp: seasons_stddev_samp_fields
  sum: seasons_sum_fields
  var_pop: seasons_var_pop_fields
  var_samp: seasons_var_samp_fields
  variance: seasons_variance_fields
}

"""
order by aggregate values of table "seasons"
"""
input seasons_aggregate_order_by {
  avg: seasons_avg_order_by
  count: order_by
  max: seasons_max_order_by
  min: seasons_min_order_by
  stddev: seasons_stddev_order_by
  stddev_pop: seasons_stddev_pop_order_by
  stddev_samp: seasons_stddev_samp_order_by
  sum: seasons_sum_order_by
  var_pop: seasons_var_pop_order_by
  var_samp: seasons_var_samp_order_by
  variance: seasons_variance_order_by
}

"""
input type for inserting array relation for remote table "seasons"
"""
input seasons_arr_rel_insert_input {
  data: [seasons_insert_input!]!
  on_conflict: seasons_on_conflict
}

"""aggregate avg on columns"""
type seasons_avg_fields {
  year: Float
}

"""
order by avg() on columns of table "seasons"
"""
input seasons_avg_order_by {
  year: order_by
}

"""
Boolean expression to filter rows from the table "seasons". All fields are combined with a logical 'AND'.
"""
input seasons_bool_exp {
  _and: [seasons_bool_exp]
  _not: seasons_bool_exp
  _or: [seasons_bool_exp]
  races: races_bool_exp
  url: String_comparison_exp
  year: bigint_comparison_exp
}

"""
unique or primary key constraints on table "seasons"
"""
enum seasons_constraint {
  """unique or primary key constraint"""
  idx_18913_seasons_pkey
}

"""
input type for incrementing integer column in table "seasons"
"""
input seasons_inc_input {
  year: bigint
}

"""
input type for inserting data into table "seasons"
"""
input seasons_insert_input {
  races: races_arr_rel_insert_input
  url: String
  year: bigint
}

"""aggregate max on columns"""
type seasons_max_fields {
  url: String
  year: bigint
}

"""
order by max() on columns of table "seasons"
"""
input seasons_max_order_by {
  url: order_by
  year: order_by
}

"""aggregate min on columns"""
type seasons_min_fields {
  url: String
  year: bigint
}

"""
order by min() on columns of table "seasons"
"""
input seasons_min_order_by {
  url: order_by
  year: order_by
}

"""
response of any mutation on the table "seasons"
"""
type seasons_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [seasons!]!
}

"""
input type for inserting object relation for remote table "seasons"
"""
input seasons_obj_rel_insert_input {
  data: seasons_insert_input!
  on_conflict: seasons_on_conflict
}

"""
on conflict condition type for table "seasons"
"""
input seasons_on_conflict {
  constraint: seasons_constraint!
  update_columns: [seasons_update_column!]!
  where: seasons_bool_exp
}

"""
ordering options when selecting data from "seasons"
"""
input seasons_order_by {
  races_aggregate: races_aggregate_order_by
  url: order_by
  year: order_by
}

"""
primary key columns input for table: "seasons"
"""
input seasons_pk_columns_input {
  year: bigint!
}

"""
select columns of table "seasons"
"""
enum seasons_select_column {
  """column name"""
  url

  """column name"""
  year
}

"""
input type for updating data in table "seasons"
"""
input seasons_set_input {
  url: String
  year: bigint
}

"""aggregate stddev on columns"""
type seasons_stddev_fields {
  year: Float
}

"""
order by stddev() on columns of table "seasons"
"""
input seasons_stddev_order_by {
  year: order_by
}

"""aggregate stddev_pop on columns"""
type seasons_stddev_pop_fields {
  year: Float
}

"""
order by stddev_pop() on columns of table "seasons"
"""
input seasons_stddev_pop_order_by {
  year: order_by
}

"""aggregate stddev_samp on columns"""
type seasons_stddev_samp_fields {
  year: Float
}

"""
order by stddev_samp() on columns of table "seasons"
"""
input seasons_stddev_samp_order_by {
  year: order_by
}

"""aggregate sum on columns"""
type seasons_sum_fields {
  year: bigint
}

"""
order by sum() on columns of table "seasons"
"""
input seasons_sum_order_by {
  year: order_by
}

"""
update columns of table "seasons"
"""
enum seasons_update_column {
  """column name"""
  url

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type seasons_var_pop_fields {
  year: Float
}

"""
order by var_pop() on columns of table "seasons"
"""
input seasons_var_pop_order_by {
  year: order_by
}

"""aggregate var_samp on columns"""
type seasons_var_samp_fields {
  year: Float
}

"""
order by var_samp() on columns of table "seasons"
"""
input seasons_var_samp_order_by {
  year: order_by
}

"""aggregate variance on columns"""
type seasons_variance_fields {
  year: Float
}

"""
order by variance() on columns of table "seasons"
"""
input seasons_variance_order_by {
  year: order_by
}

"""
columns and relationships of "status"
"""
type status {
  """An array relationship"""
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """An aggregated array relationship"""
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!
  status: String
  statusid: bigint!
}

"""
aggregated selection of "status"
"""
type status_aggregate {
  aggregate: status_aggregate_fields
  nodes: [status!]!
}

"""
aggregate fields of "status"
"""
type status_aggregate_fields {
  avg: status_avg_fields
  count(columns: [status_select_column!], distinct: Boolean): Int
  max: status_max_fields
  min: status_min_fields
  stddev: status_stddev_fields
  stddev_pop: status_stddev_pop_fields
  stddev_samp: status_stddev_samp_fields
  sum: status_sum_fields
  var_pop: status_var_pop_fields
  var_samp: status_var_samp_fields
  variance: status_variance_fields
}

"""
order by aggregate values of table "status"
"""
input status_aggregate_order_by {
  avg: status_avg_order_by
  count: order_by
  max: status_max_order_by
  min: status_min_order_by
  stddev: status_stddev_order_by
  stddev_pop: status_stddev_pop_order_by
  stddev_samp: status_stddev_samp_order_by
  sum: status_sum_order_by
  var_pop: status_var_pop_order_by
  var_samp: status_var_samp_order_by
  variance: status_variance_order_by
}

"""
input type for inserting array relation for remote table "status"
"""
input status_arr_rel_insert_input {
  data: [status_insert_input!]!
  on_conflict: status_on_conflict
}

"""aggregate avg on columns"""
type status_avg_fields {
  statusid: Float
}

"""
order by avg() on columns of table "status"
"""
input status_avg_order_by {
  statusid: order_by
}

"""
Boolean expression to filter rows from the table "status". All fields are combined with a logical 'AND'.
"""
input status_bool_exp {
  _and: [status_bool_exp]
  _not: status_bool_exp
  _or: [status_bool_exp]
  results: results_bool_exp
  status: String_comparison_exp
  statusid: bigint_comparison_exp
}

"""
unique or primary key constraints on table "status"
"""
enum status_constraint {
  """unique or primary key constraint"""
  idx_18907_status_pkey
}

"""
input type for incrementing integer column in table "status"
"""
input status_inc_input {
  statusid: bigint
}

"""
input type for inserting data into table "status"
"""
input status_insert_input {
  results: results_arr_rel_insert_input
  status: String
  statusid: bigint
}

"""aggregate max on columns"""
type status_max_fields {
  status: String
  statusid: bigint
}

"""
order by max() on columns of table "status"
"""
input status_max_order_by {
  status: order_by
  statusid: order_by
}

"""aggregate min on columns"""
type status_min_fields {
  status: String
  statusid: bigint
}

"""
order by min() on columns of table "status"
"""
input status_min_order_by {
  status: order_by
  statusid: order_by
}

"""
response of any mutation on the table "status"
"""
type status_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [status!]!
}

"""
input type for inserting object relation for remote table "status"
"""
input status_obj_rel_insert_input {
  data: status_insert_input!
  on_conflict: status_on_conflict
}

"""
on conflict condition type for table "status"
"""
input status_on_conflict {
  constraint: status_constraint!
  update_columns: [status_update_column!]!
  where: status_bool_exp
}

"""
ordering options when selecting data from "status"
"""
input status_order_by {
  results_aggregate: results_aggregate_order_by
  status: order_by
  statusid: order_by
}

"""
primary key columns input for table: "status"
"""
input status_pk_columns_input {
  statusid: bigint!
}

"""
select columns of table "status"
"""
enum status_select_column {
  """column name"""
  status

  """column name"""
  statusid
}

"""
input type for updating data in table "status"
"""
input status_set_input {
  status: String
  statusid: bigint
}

"""aggregate stddev on columns"""
type status_stddev_fields {
  statusid: Float
}

"""
order by stddev() on columns of table "status"
"""
input status_stddev_order_by {
  statusid: order_by
}

"""aggregate stddev_pop on columns"""
type status_stddev_pop_fields {
  statusid: Float
}

"""
order by stddev_pop() on columns of table "status"
"""
input status_stddev_pop_order_by {
  statusid: order_by
}

"""aggregate stddev_samp on columns"""
type status_stddev_samp_fields {
  statusid: Float
}

"""
order by stddev_samp() on columns of table "status"
"""
input status_stddev_samp_order_by {
  statusid: order_by
}

"""aggregate sum on columns"""
type status_sum_fields {
  statusid: bigint
}

"""
order by sum() on columns of table "status"
"""
input status_sum_order_by {
  statusid: order_by
}

"""
update columns of table "status"
"""
enum status_update_column {
  """column name"""
  status

  """column name"""
  statusid
}

"""aggregate var_pop on columns"""
type status_var_pop_fields {
  statusid: Float
}

"""
order by var_pop() on columns of table "status"
"""
input status_var_pop_order_by {
  statusid: order_by
}

"""aggregate var_samp on columns"""
type status_var_samp_fields {
  statusid: Float
}

"""
order by var_samp() on columns of table "status"
"""
input status_var_samp_order_by {
  statusid: order_by
}

"""aggregate variance on columns"""
type status_variance_fields {
  statusid: Float
}

"""
order by variance() on columns of table "status"
"""
input status_variance_order_by {
  statusid: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "circuits"
  """
  circuits(
    """distinct select on columns"""
    distinct_on: [circuits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circuits_order_by!]

    """filter the rows returned"""
    where: circuits_bool_exp
  ): [circuits!]!

  """
  fetch aggregated fields from the table: "circuits"
  """
  circuits_aggregate(
    """distinct select on columns"""
    distinct_on: [circuits_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [circuits_order_by!]

    """filter the rows returned"""
    where: circuits_bool_exp
  ): circuits_aggregate!

  """fetch data from the table: "circuits" using primary key columns"""
  circuits_by_pk(circuitid: bigint!): circuits

  """
  fetch data from the table: "constructorresults"
  """
  constructorresults(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): [constructorresults!]!

  """
  fetch aggregated fields from the table: "constructorresults"
  """
  constructorresults_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorresults_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorresults_order_by!]

    """filter the rows returned"""
    where: constructorresults_bool_exp
  ): constructorresults_aggregate!

  """
  fetch data from the table: "constructorresults" using primary key columns
  """
  constructorresults_by_pk(constructorresultsid: bigint!): constructorresults

  """
  fetch data from the table: "constructors"
  """
  constructors(
    """distinct select on columns"""
    distinct_on: [constructors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructors_order_by!]

    """filter the rows returned"""
    where: constructors_bool_exp
  ): [constructors!]!

  """
  fetch aggregated fields from the table: "constructors"
  """
  constructors_aggregate(
    """distinct select on columns"""
    distinct_on: [constructors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructors_order_by!]

    """filter the rows returned"""
    where: constructors_bool_exp
  ): constructors_aggregate!

  """fetch data from the table: "constructors" using primary key columns"""
  constructors_by_pk(constructorid: bigint!): constructors

  """
  fetch data from the table: "constructorstandings"
  """
  constructorstandings(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): [constructorstandings!]!

  """
  fetch aggregated fields from the table: "constructorstandings"
  """
  constructorstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [constructorstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [constructorstandings_order_by!]

    """filter the rows returned"""
    where: constructorstandings_bool_exp
  ): constructorstandings_aggregate!

  """
  fetch data from the table: "constructorstandings" using primary key columns
  """
  constructorstandings_by_pk(constructorstandingsid: bigint!): constructorstandings

  """
  fetch data from the table: "drivers"
  """
  drivers(
    """distinct select on columns"""
    distinct_on: [drivers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drivers_order_by!]

    """filter the rows returned"""
    where: drivers_bool_exp
  ): [drivers!]!

  """
  fetch aggregated fields from the table: "drivers"
  """
  drivers_aggregate(
    """distinct select on columns"""
    distinct_on: [drivers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drivers_order_by!]

    """filter the rows returned"""
    where: drivers_bool_exp
  ): drivers_aggregate!

  """fetch data from the table: "drivers" using primary key columns"""
  drivers_by_pk(driverid: bigint!): drivers

  """
  fetch data from the table: "driverstandings"
  """
  driverstandings(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): [driverstandings!]!

  """
  fetch aggregated fields from the table: "driverstandings"
  """
  driverstandings_aggregate(
    """distinct select on columns"""
    distinct_on: [driverstandings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driverstandings_order_by!]

    """filter the rows returned"""
    where: driverstandings_bool_exp
  ): driverstandings_aggregate!

  """fetch data from the table: "driverstandings" using primary key columns"""
  driverstandings_by_pk(driverstandingsid: bigint!): driverstandings

  """
  fetch data from the table: "laptimes"
  """
  laptimes(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): [laptimes!]!

  """
  fetch aggregated fields from the table: "laptimes"
  """
  laptimes_aggregate(
    """distinct select on columns"""
    distinct_on: [laptimes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [laptimes_order_by!]

    """filter the rows returned"""
    where: laptimes_bool_exp
  ): laptimes_aggregate!

  """fetch data from the table: "laptimes" using primary key columns"""
  laptimes_by_pk(driverid: bigint!, lap: bigint!, raceid: bigint!): laptimes

  """
  fetch data from the table: "pitstops"
  """
  pitstops(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): [pitstops!]!

  """
  fetch aggregated fields from the table: "pitstops"
  """
  pitstops_aggregate(
    """distinct select on columns"""
    distinct_on: [pitstops_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pitstops_order_by!]

    """filter the rows returned"""
    where: pitstops_bool_exp
  ): pitstops_aggregate!

  """fetch data from the table: "pitstops" using primary key columns"""
  pitstops_by_pk(driverid: bigint!, raceid: bigint!, stop: bigint!): pitstops

  """
  fetch data from the table: "qualifying"
  """
  qualifying(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): [qualifying!]!

  """
  fetch aggregated fields from the table: "qualifying"
  """
  qualifying_aggregate(
    """distinct select on columns"""
    distinct_on: [qualifying_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [qualifying_order_by!]

    """filter the rows returned"""
    where: qualifying_bool_exp
  ): qualifying_aggregate!

  """fetch data from the table: "qualifying" using primary key columns"""
  qualifying_by_pk(qualifyid: bigint!): qualifying

  """
  fetch data from the table: "races"
  """
  races(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): [races!]!

  """
  fetch aggregated fields from the table: "races"
  """
  races_aggregate(
    """distinct select on columns"""
    distinct_on: [races_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [races_order_by!]

    """filter the rows returned"""
    where: races_bool_exp
  ): races_aggregate!

  """fetch data from the table: "races" using primary key columns"""
  races_by_pk(raceid: bigint!): races

  """
  fetch data from the table: "results"
  """
  results(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): [results!]!

  """
  fetch aggregated fields from the table: "results"
  """
  results_aggregate(
    """distinct select on columns"""
    distinct_on: [results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [results_order_by!]

    """filter the rows returned"""
    where: results_bool_exp
  ): results_aggregate!

  """fetch data from the table: "results" using primary key columns"""
  results_by_pk(resultid: bigint!): results

  """
  fetch data from the table: "seasons"
  """
  seasons(
    """distinct select on columns"""
    distinct_on: [seasons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seasons_order_by!]

    """filter the rows returned"""
    where: seasons_bool_exp
  ): [seasons!]!

  """
  fetch aggregated fields from the table: "seasons"
  """
  seasons_aggregate(
    """distinct select on columns"""
    distinct_on: [seasons_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [seasons_order_by!]

    """filter the rows returned"""
    where: seasons_bool_exp
  ): seasons_aggregate!

  """fetch data from the table: "seasons" using primary key columns"""
  seasons_by_pk(year: bigint!): seasons

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(statusid: bigint!): status
}
