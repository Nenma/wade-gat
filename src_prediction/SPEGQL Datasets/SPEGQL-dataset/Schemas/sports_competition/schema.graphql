schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "club"
"""
type club {
  club_id: Int

  """An array relationship"""
  club_ranks(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): [club_rank!]!

  """An aggregated array relationship"""
  club_ranks_aggregate(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): club_rank_aggregate!

  """An array relationship"""
  competitionResultsByClubId1(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): [competition_result!]!

  """An aggregated array relationship"""
  competitionResultsByClubId1_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): competition_result_aggregate!

  """An array relationship"""
  competition_results(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): [competition_result!]!

  """An aggregated array relationship"""
  competition_results_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): competition_result_aggregate!
  name: String

  """An array relationship"""
  players(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): [player!]!

  """An aggregated array relationship"""
  players_aggregate(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): player_aggregate!
  region: String
  start_year: String
}

"""
aggregated selection of "club"
"""
type club_aggregate {
  aggregate: club_aggregate_fields
  nodes: [club!]!
}

"""
aggregate fields of "club"
"""
type club_aggregate_fields {
  avg: club_avg_fields
  count(columns: [club_select_column!], distinct: Boolean): Int
  max: club_max_fields
  min: club_min_fields
  stddev: club_stddev_fields
  stddev_pop: club_stddev_pop_fields
  stddev_samp: club_stddev_samp_fields
  sum: club_sum_fields
  var_pop: club_var_pop_fields
  var_samp: club_var_samp_fields
  variance: club_variance_fields
}

"""
order by aggregate values of table "club"
"""
input club_aggregate_order_by {
  avg: club_avg_order_by
  count: order_by
  max: club_max_order_by
  min: club_min_order_by
  stddev: club_stddev_order_by
  stddev_pop: club_stddev_pop_order_by
  stddev_samp: club_stddev_samp_order_by
  sum: club_sum_order_by
  var_pop: club_var_pop_order_by
  var_samp: club_var_samp_order_by
  variance: club_variance_order_by
}

"""
input type for inserting array relation for remote table "club"
"""
input club_arr_rel_insert_input {
  data: [club_insert_input!]!
  on_conflict: club_on_conflict
}

"""aggregate avg on columns"""
type club_avg_fields {
  club_id: Float
}

"""
order by avg() on columns of table "club"
"""
input club_avg_order_by {
  club_id: order_by
}

"""
Boolean expression to filter rows from the table "club". All fields are combined with a logical 'AND'.
"""
input club_bool_exp {
  _and: [club_bool_exp]
  _not: club_bool_exp
  _or: [club_bool_exp]
  club_id: Int_comparison_exp
  club_ranks: club_rank_bool_exp
  competitionResultsByClubId1: competition_result_bool_exp
  competition_results: competition_result_bool_exp
  name: String_comparison_exp
  players: player_bool_exp
  region: String_comparison_exp
  start_year: String_comparison_exp
}

"""
unique or primary key constraints on table "club"
"""
enum club_constraint {
  """unique or primary key constraint"""
  idx_24375_sqlite_autoindex_club_1
}

"""
input type for incrementing integer column in table "club"
"""
input club_inc_input {
  club_id: Int
}

"""
input type for inserting data into table "club"
"""
input club_insert_input {
  club_id: Int
  club_ranks: club_rank_arr_rel_insert_input
  competitionResultsByClubId1: competition_result_arr_rel_insert_input
  competition_results: competition_result_arr_rel_insert_input
  name: String
  players: player_arr_rel_insert_input
  region: String
  start_year: String
}

"""aggregate max on columns"""
type club_max_fields {
  club_id: Int
  name: String
  region: String
  start_year: String
}

"""
order by max() on columns of table "club"
"""
input club_max_order_by {
  club_id: order_by
  name: order_by
  region: order_by
  start_year: order_by
}

"""aggregate min on columns"""
type club_min_fields {
  club_id: Int
  name: String
  region: String
  start_year: String
}

"""
order by min() on columns of table "club"
"""
input club_min_order_by {
  club_id: order_by
  name: order_by
  region: order_by
  start_year: order_by
}

"""
response of any mutation on the table "club"
"""
type club_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [club!]!
}

"""
input type for inserting object relation for remote table "club"
"""
input club_obj_rel_insert_input {
  data: club_insert_input!
  on_conflict: club_on_conflict
}

"""
on conflict condition type for table "club"
"""
input club_on_conflict {
  constraint: club_constraint!
  update_columns: [club_update_column!]!
  where: club_bool_exp
}

"""
ordering options when selecting data from "club"
"""
input club_order_by {
  club_id: order_by
  club_ranks_aggregate: club_rank_aggregate_order_by
  competitionResultsByClubId1_aggregate: competition_result_aggregate_order_by
  competition_results_aggregate: competition_result_aggregate_order_by
  name: order_by
  players_aggregate: player_aggregate_order_by
  region: order_by
  start_year: order_by
}

"""
columns and relationships of "club_rank"
"""
type club_rank {
  bronze: Float

  """An object relationship"""
  club: club
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
aggregated selection of "club_rank"
"""
type club_rank_aggregate {
  aggregate: club_rank_aggregate_fields
  nodes: [club_rank!]!
}

"""
aggregate fields of "club_rank"
"""
type club_rank_aggregate_fields {
  avg: club_rank_avg_fields
  count(columns: [club_rank_select_column!], distinct: Boolean): Int
  max: club_rank_max_fields
  min: club_rank_min_fields
  stddev: club_rank_stddev_fields
  stddev_pop: club_rank_stddev_pop_fields
  stddev_samp: club_rank_stddev_samp_fields
  sum: club_rank_sum_fields
  var_pop: club_rank_var_pop_fields
  var_samp: club_rank_var_samp_fields
  variance: club_rank_variance_fields
}

"""
order by aggregate values of table "club_rank"
"""
input club_rank_aggregate_order_by {
  avg: club_rank_avg_order_by
  count: order_by
  max: club_rank_max_order_by
  min: club_rank_min_order_by
  stddev: club_rank_stddev_order_by
  stddev_pop: club_rank_stddev_pop_order_by
  stddev_samp: club_rank_stddev_samp_order_by
  sum: club_rank_sum_order_by
  var_pop: club_rank_var_pop_order_by
  var_samp: club_rank_var_samp_order_by
  variance: club_rank_variance_order_by
}

"""
input type for inserting array relation for remote table "club_rank"
"""
input club_rank_arr_rel_insert_input {
  data: [club_rank_insert_input!]!
  on_conflict: club_rank_on_conflict
}

"""aggregate avg on columns"""
type club_rank_avg_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by avg() on columns of table "club_rank"
"""
input club_rank_avg_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""
Boolean expression to filter rows from the table "club_rank". All fields are combined with a logical 'AND'.
"""
input club_rank_bool_exp {
  _and: [club_rank_bool_exp]
  _not: club_rank_bool_exp
  _or: [club_rank_bool_exp]
  bronze: Float_comparison_exp
  club: club_bool_exp
  club_id: Int_comparison_exp
  gold: Float_comparison_exp
  rank: Float_comparison_exp
  silver: Float_comparison_exp
  total: Float_comparison_exp
}

"""
unique or primary key constraints on table "club_rank"
"""
enum club_rank_constraint {
  """unique or primary key constraint"""
  idx_24381_sqlite_autoindex_club_rank_1
}

"""
input type for incrementing integer column in table "club_rank"
"""
input club_rank_inc_input {
  bronze: Float
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
input type for inserting data into table "club_rank"
"""
input club_rank_insert_input {
  bronze: Float
  club: club_obj_rel_insert_input
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""aggregate max on columns"""
type club_rank_max_fields {
  bronze: Float
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by max() on columns of table "club_rank"
"""
input club_rank_max_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate min on columns"""
type club_rank_min_fields {
  bronze: Float
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by min() on columns of table "club_rank"
"""
input club_rank_min_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""
response of any mutation on the table "club_rank"
"""
type club_rank_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [club_rank!]!
}

"""
input type for inserting object relation for remote table "club_rank"
"""
input club_rank_obj_rel_insert_input {
  data: club_rank_insert_input!
  on_conflict: club_rank_on_conflict
}

"""
on conflict condition type for table "club_rank"
"""
input club_rank_on_conflict {
  constraint: club_rank_constraint!
  update_columns: [club_rank_update_column!]!
  where: club_rank_bool_exp
}

"""
ordering options when selecting data from "club_rank"
"""
input club_rank_order_by {
  bronze: order_by
  club: club_order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""
select columns of table "club_rank"
"""
enum club_rank_select_column {
  """column name"""
  bronze

  """column name"""
  club_id

  """column name"""
  gold

  """column name"""
  rank

  """column name"""
  silver

  """column name"""
  total
}

"""
input type for updating data in table "club_rank"
"""
input club_rank_set_input {
  bronze: Float
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""aggregate stddev on columns"""
type club_rank_stddev_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by stddev() on columns of table "club_rank"
"""
input club_rank_stddev_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate stddev_pop on columns"""
type club_rank_stddev_pop_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by stddev_pop() on columns of table "club_rank"
"""
input club_rank_stddev_pop_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate stddev_samp on columns"""
type club_rank_stddev_samp_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by stddev_samp() on columns of table "club_rank"
"""
input club_rank_stddev_samp_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate sum on columns"""
type club_rank_sum_fields {
  bronze: Float
  club_id: Int
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by sum() on columns of table "club_rank"
"""
input club_rank_sum_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""
update columns of table "club_rank"
"""
enum club_rank_update_column {
  """column name"""
  bronze

  """column name"""
  club_id

  """column name"""
  gold

  """column name"""
  rank

  """column name"""
  silver

  """column name"""
  total
}

"""aggregate var_pop on columns"""
type club_rank_var_pop_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by var_pop() on columns of table "club_rank"
"""
input club_rank_var_pop_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate var_samp on columns"""
type club_rank_var_samp_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by var_samp() on columns of table "club_rank"
"""
input club_rank_var_samp_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""aggregate variance on columns"""
type club_rank_variance_fields {
  bronze: Float
  club_id: Float
  gold: Float
  rank: Float
  silver: Float
  total: Float
}

"""
order by variance() on columns of table "club_rank"
"""
input club_rank_variance_order_by {
  bronze: order_by
  club_id: order_by
  gold: order_by
  rank: order_by
  silver: order_by
  total: order_by
}

"""
select columns of table "club"
"""
enum club_select_column {
  """column name"""
  club_id

  """column name"""
  name

  """column name"""
  region

  """column name"""
  start_year
}

"""
input type for updating data in table "club"
"""
input club_set_input {
  club_id: Int
  name: String
  region: String
  start_year: String
}

"""aggregate stddev on columns"""
type club_stddev_fields {
  club_id: Float
}

"""
order by stddev() on columns of table "club"
"""
input club_stddev_order_by {
  club_id: order_by
}

"""aggregate stddev_pop on columns"""
type club_stddev_pop_fields {
  club_id: Float
}

"""
order by stddev_pop() on columns of table "club"
"""
input club_stddev_pop_order_by {
  club_id: order_by
}

"""aggregate stddev_samp on columns"""
type club_stddev_samp_fields {
  club_id: Float
}

"""
order by stddev_samp() on columns of table "club"
"""
input club_stddev_samp_order_by {
  club_id: order_by
}

"""aggregate sum on columns"""
type club_sum_fields {
  club_id: Int
}

"""
order by sum() on columns of table "club"
"""
input club_sum_order_by {
  club_id: order_by
}

"""
update columns of table "club"
"""
enum club_update_column {
  """column name"""
  club_id

  """column name"""
  name

  """column name"""
  region

  """column name"""
  start_year
}

"""aggregate var_pop on columns"""
type club_var_pop_fields {
  club_id: Float
}

"""
order by var_pop() on columns of table "club"
"""
input club_var_pop_order_by {
  club_id: order_by
}

"""aggregate var_samp on columns"""
type club_var_samp_fields {
  club_id: Float
}

"""
order by var_samp() on columns of table "club"
"""
input club_var_samp_order_by {
  club_id: order_by
}

"""aggregate variance on columns"""
type club_variance_fields {
  club_id: Float
}

"""
order by variance() on columns of table "club"
"""
input club_variance_order_by {
  club_id: order_by
}

"""
columns and relationships of "competition"
"""
type competition {
  competition_id: Int

  """An array relationship"""
  competition_results(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): [competition_result!]!

  """An aggregated array relationship"""
  competition_results_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): competition_result_aggregate!
  competition_type: String
  country: String
  year: Float
}

"""
aggregated selection of "competition"
"""
type competition_aggregate {
  aggregate: competition_aggregate_fields
  nodes: [competition!]!
}

"""
aggregate fields of "competition"
"""
type competition_aggregate_fields {
  avg: competition_avg_fields
  count(columns: [competition_select_column!], distinct: Boolean): Int
  max: competition_max_fields
  min: competition_min_fields
  stddev: competition_stddev_fields
  stddev_pop: competition_stddev_pop_fields
  stddev_samp: competition_stddev_samp_fields
  sum: competition_sum_fields
  var_pop: competition_var_pop_fields
  var_samp: competition_var_samp_fields
  variance: competition_variance_fields
}

"""
order by aggregate values of table "competition"
"""
input competition_aggregate_order_by {
  avg: competition_avg_order_by
  count: order_by
  max: competition_max_order_by
  min: competition_min_order_by
  stddev: competition_stddev_order_by
  stddev_pop: competition_stddev_pop_order_by
  stddev_samp: competition_stddev_samp_order_by
  sum: competition_sum_order_by
  var_pop: competition_var_pop_order_by
  var_samp: competition_var_samp_order_by
  variance: competition_variance_order_by
}

"""
input type for inserting array relation for remote table "competition"
"""
input competition_arr_rel_insert_input {
  data: [competition_insert_input!]!
  on_conflict: competition_on_conflict
}

"""aggregate avg on columns"""
type competition_avg_fields {
  competition_id: Float
  year: Float
}

"""
order by avg() on columns of table "competition"
"""
input competition_avg_order_by {
  competition_id: order_by
  year: order_by
}

"""
Boolean expression to filter rows from the table "competition". All fields are combined with a logical 'AND'.
"""
input competition_bool_exp {
  _and: [competition_bool_exp]
  _not: competition_bool_exp
  _or: [competition_bool_exp]
  competition_id: Int_comparison_exp
  competition_results: competition_result_bool_exp
  competition_type: String_comparison_exp
  country: String_comparison_exp
  year: Float_comparison_exp
}

"""
unique or primary key constraints on table "competition"
"""
enum competition_constraint {
  """unique or primary key constraint"""
  idx_24390_sqlite_autoindex_competition_1
}

"""
input type for incrementing integer column in table "competition"
"""
input competition_inc_input {
  competition_id: Int
  year: Float
}

"""
input type for inserting data into table "competition"
"""
input competition_insert_input {
  competition_id: Int
  competition_results: competition_result_arr_rel_insert_input
  competition_type: String
  country: String
  year: Float
}

"""aggregate max on columns"""
type competition_max_fields {
  competition_id: Int
  competition_type: String
  country: String
  year: Float
}

"""
order by max() on columns of table "competition"
"""
input competition_max_order_by {
  competition_id: order_by
  competition_type: order_by
  country: order_by
  year: order_by
}

"""aggregate min on columns"""
type competition_min_fields {
  competition_id: Int
  competition_type: String
  country: String
  year: Float
}

"""
order by min() on columns of table "competition"
"""
input competition_min_order_by {
  competition_id: order_by
  competition_type: order_by
  country: order_by
  year: order_by
}

"""
response of any mutation on the table "competition"
"""
type competition_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [competition!]!
}

"""
input type for inserting object relation for remote table "competition"
"""
input competition_obj_rel_insert_input {
  data: competition_insert_input!
  on_conflict: competition_on_conflict
}

"""
on conflict condition type for table "competition"
"""
input competition_on_conflict {
  constraint: competition_constraint!
  update_columns: [competition_update_column!]!
  where: competition_bool_exp
}

"""
ordering options when selecting data from "competition"
"""
input competition_order_by {
  competition_id: order_by
  competition_results_aggregate: competition_result_aggregate_order_by
  competition_type: order_by
  country: order_by
  year: order_by
}

"""
columns and relationships of "competition_result"
"""
type competition_result {
  """An object relationship"""
  club1: club

  """An object relationship"""
  club2: club
  club_id_1: Int
  club_id_2: Int

  """An object relationship"""
  competition: competition
  competition_id: Int
  score: String
}

"""
aggregated selection of "competition_result"
"""
type competition_result_aggregate {
  aggregate: competition_result_aggregate_fields
  nodes: [competition_result!]!
}

"""
aggregate fields of "competition_result"
"""
type competition_result_aggregate_fields {
  avg: competition_result_avg_fields
  count(columns: [competition_result_select_column!], distinct: Boolean): Int
  max: competition_result_max_fields
  min: competition_result_min_fields
  stddev: competition_result_stddev_fields
  stddev_pop: competition_result_stddev_pop_fields
  stddev_samp: competition_result_stddev_samp_fields
  sum: competition_result_sum_fields
  var_pop: competition_result_var_pop_fields
  var_samp: competition_result_var_samp_fields
  variance: competition_result_variance_fields
}

"""
order by aggregate values of table "competition_result"
"""
input competition_result_aggregate_order_by {
  avg: competition_result_avg_order_by
  count: order_by
  max: competition_result_max_order_by
  min: competition_result_min_order_by
  stddev: competition_result_stddev_order_by
  stddev_pop: competition_result_stddev_pop_order_by
  stddev_samp: competition_result_stddev_samp_order_by
  sum: competition_result_sum_order_by
  var_pop: competition_result_var_pop_order_by
  var_samp: competition_result_var_samp_order_by
  variance: competition_result_variance_order_by
}

"""
input type for inserting array relation for remote table "competition_result"
"""
input competition_result_arr_rel_insert_input {
  data: [competition_result_insert_input!]!
  on_conflict: competition_result_on_conflict
}

"""aggregate avg on columns"""
type competition_result_avg_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by avg() on columns of table "competition_result"
"""
input competition_result_avg_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""
Boolean expression to filter rows from the table "competition_result". All fields are combined with a logical 'AND'.
"""
input competition_result_bool_exp {
  _and: [competition_result_bool_exp]
  _not: competition_result_bool_exp
  _or: [competition_result_bool_exp]
  club1: club_bool_exp
  club2: club_bool_exp
  club_id_1: Int_comparison_exp
  club_id_2: Int_comparison_exp
  competition: competition_bool_exp
  competition_id: Int_comparison_exp
  score: String_comparison_exp
}

"""
unique or primary key constraints on table "competition_result"
"""
enum competition_result_constraint {
  """unique or primary key constraint"""
  idx_24396_sqlite_autoindex_competition_result_1
}

"""
input type for incrementing integer column in table "competition_result"
"""
input competition_result_inc_input {
  club_id_1: Int
  club_id_2: Int
  competition_id: Int
}

"""
input type for inserting data into table "competition_result"
"""
input competition_result_insert_input {
  club1: club_obj_rel_insert_input
  club2: club_obj_rel_insert_input
  club_id_1: Int
  club_id_2: Int
  competition: competition_obj_rel_insert_input
  competition_id: Int
  score: String
}

"""aggregate max on columns"""
type competition_result_max_fields {
  club_id_1: Int
  club_id_2: Int
  competition_id: Int
  score: String
}

"""
order by max() on columns of table "competition_result"
"""
input competition_result_max_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
  score: order_by
}

"""aggregate min on columns"""
type competition_result_min_fields {
  club_id_1: Int
  club_id_2: Int
  competition_id: Int
  score: String
}

"""
order by min() on columns of table "competition_result"
"""
input competition_result_min_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
  score: order_by
}

"""
response of any mutation on the table "competition_result"
"""
type competition_result_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [competition_result!]!
}

"""
input type for inserting object relation for remote table "competition_result"
"""
input competition_result_obj_rel_insert_input {
  data: competition_result_insert_input!
  on_conflict: competition_result_on_conflict
}

"""
on conflict condition type for table "competition_result"
"""
input competition_result_on_conflict {
  constraint: competition_result_constraint!
  update_columns: [competition_result_update_column!]!
  where: competition_result_bool_exp
}

"""
ordering options when selecting data from "competition_result"
"""
input competition_result_order_by {
  club1: club_order_by
  club2: club_order_by
  club_id_1: order_by
  club_id_2: order_by
  competition: competition_order_by
  competition_id: order_by
  score: order_by
}

"""
select columns of table "competition_result"
"""
enum competition_result_select_column {
  """column name"""
  club_id_1

  """column name"""
  club_id_2

  """column name"""
  competition_id

  """column name"""
  score
}

"""
input type for updating data in table "competition_result"
"""
input competition_result_set_input {
  club_id_1: Int
  club_id_2: Int
  competition_id: Int
  score: String
}

"""aggregate stddev on columns"""
type competition_result_stddev_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by stddev() on columns of table "competition_result"
"""
input competition_result_stddev_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""aggregate stddev_pop on columns"""
type competition_result_stddev_pop_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by stddev_pop() on columns of table "competition_result"
"""
input competition_result_stddev_pop_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""aggregate stddev_samp on columns"""
type competition_result_stddev_samp_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by stddev_samp() on columns of table "competition_result"
"""
input competition_result_stddev_samp_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""aggregate sum on columns"""
type competition_result_sum_fields {
  club_id_1: Int
  club_id_2: Int
  competition_id: Int
}

"""
order by sum() on columns of table "competition_result"
"""
input competition_result_sum_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""
update columns of table "competition_result"
"""
enum competition_result_update_column {
  """column name"""
  club_id_1

  """column name"""
  club_id_2

  """column name"""
  competition_id

  """column name"""
  score
}

"""aggregate var_pop on columns"""
type competition_result_var_pop_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by var_pop() on columns of table "competition_result"
"""
input competition_result_var_pop_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""aggregate var_samp on columns"""
type competition_result_var_samp_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by var_samp() on columns of table "competition_result"
"""
input competition_result_var_samp_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""aggregate variance on columns"""
type competition_result_variance_fields {
  club_id_1: Float
  club_id_2: Float
  competition_id: Float
}

"""
order by variance() on columns of table "competition_result"
"""
input competition_result_variance_order_by {
  club_id_1: order_by
  club_id_2: order_by
  competition_id: order_by
}

"""
select columns of table "competition"
"""
enum competition_select_column {
  """column name"""
  competition_id

  """column name"""
  competition_type

  """column name"""
  country

  """column name"""
  year
}

"""
input type for updating data in table "competition"
"""
input competition_set_input {
  competition_id: Int
  competition_type: String
  country: String
  year: Float
}

"""aggregate stddev on columns"""
type competition_stddev_fields {
  competition_id: Float
  year: Float
}

"""
order by stddev() on columns of table "competition"
"""
input competition_stddev_order_by {
  competition_id: order_by
  year: order_by
}

"""aggregate stddev_pop on columns"""
type competition_stddev_pop_fields {
  competition_id: Float
  year: Float
}

"""
order by stddev_pop() on columns of table "competition"
"""
input competition_stddev_pop_order_by {
  competition_id: order_by
  year: order_by
}

"""aggregate stddev_samp on columns"""
type competition_stddev_samp_fields {
  competition_id: Float
  year: Float
}

"""
order by stddev_samp() on columns of table "competition"
"""
input competition_stddev_samp_order_by {
  competition_id: order_by
  year: order_by
}

"""aggregate sum on columns"""
type competition_sum_fields {
  competition_id: Int
  year: Float
}

"""
order by sum() on columns of table "competition"
"""
input competition_sum_order_by {
  competition_id: order_by
  year: order_by
}

"""
update columns of table "competition"
"""
enum competition_update_column {
  """column name"""
  competition_id

  """column name"""
  competition_type

  """column name"""
  country

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type competition_var_pop_fields {
  competition_id: Float
  year: Float
}

"""
order by var_pop() on columns of table "competition"
"""
input competition_var_pop_order_by {
  competition_id: order_by
  year: order_by
}

"""aggregate var_samp on columns"""
type competition_var_samp_fields {
  competition_id: Float
  year: Float
}

"""
order by var_samp() on columns of table "competition"
"""
input competition_var_samp_order_by {
  competition_id: order_by
  year: order_by
}

"""aggregate variance on columns"""
type competition_variance_fields {
  competition_id: Float
  year: Float
}

"""
order by variance() on columns of table "competition"
"""
input competition_variance_order_by {
  competition_id: order_by
  year: order_by
}

"""
expression to compare columns of type Float. All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "club"
  """
  delete_club(
    """filter the rows which have to be deleted"""
    where: club_bool_exp!
  ): club_mutation_response

  """
  delete data from the table: "club_rank"
  """
  delete_club_rank(
    """filter the rows which have to be deleted"""
    where: club_rank_bool_exp!
  ): club_rank_mutation_response

  """
  delete data from the table: "competition"
  """
  delete_competition(
    """filter the rows which have to be deleted"""
    where: competition_bool_exp!
  ): competition_mutation_response

  """
  delete data from the table: "competition_result"
  """
  delete_competition_result(
    """filter the rows which have to be deleted"""
    where: competition_result_bool_exp!
  ): competition_result_mutation_response

  """
  delete data from the table: "player"
  """
  delete_player(
    """filter the rows which have to be deleted"""
    where: player_bool_exp!
  ): player_mutation_response

  """
  insert data into the table: "club"
  """
  insert_club(
    """the rows to be inserted"""
    objects: [club_insert_input!]!

    """on conflict condition"""
    on_conflict: club_on_conflict
  ): club_mutation_response

  """
  insert a single row into the table: "club"
  """
  insert_club_one(
    """the row to be inserted"""
    object: club_insert_input!

    """on conflict condition"""
    on_conflict: club_on_conflict
  ): club

  """
  insert data into the table: "club_rank"
  """
  insert_club_rank(
    """the rows to be inserted"""
    objects: [club_rank_insert_input!]!

    """on conflict condition"""
    on_conflict: club_rank_on_conflict
  ): club_rank_mutation_response

  """
  insert a single row into the table: "club_rank"
  """
  insert_club_rank_one(
    """the row to be inserted"""
    object: club_rank_insert_input!

    """on conflict condition"""
    on_conflict: club_rank_on_conflict
  ): club_rank

  """
  insert data into the table: "competition"
  """
  insert_competition(
    """the rows to be inserted"""
    objects: [competition_insert_input!]!

    """on conflict condition"""
    on_conflict: competition_on_conflict
  ): competition_mutation_response

  """
  insert a single row into the table: "competition"
  """
  insert_competition_one(
    """the row to be inserted"""
    object: competition_insert_input!

    """on conflict condition"""
    on_conflict: competition_on_conflict
  ): competition

  """
  insert data into the table: "competition_result"
  """
  insert_competition_result(
    """the rows to be inserted"""
    objects: [competition_result_insert_input!]!

    """on conflict condition"""
    on_conflict: competition_result_on_conflict
  ): competition_result_mutation_response

  """
  insert a single row into the table: "competition_result"
  """
  insert_competition_result_one(
    """the row to be inserted"""
    object: competition_result_insert_input!

    """on conflict condition"""
    on_conflict: competition_result_on_conflict
  ): competition_result

  """
  insert data into the table: "player"
  """
  insert_player(
    """the rows to be inserted"""
    objects: [player_insert_input!]!

    """on conflict condition"""
    on_conflict: player_on_conflict
  ): player_mutation_response

  """
  insert a single row into the table: "player"
  """
  insert_player_one(
    """the row to be inserted"""
    object: player_insert_input!

    """on conflict condition"""
    on_conflict: player_on_conflict
  ): player

  """
  update data of the table: "club"
  """
  update_club(
    """increments the integer columns with given value of the filtered values"""
    _inc: club_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_set_input

    """filter the rows which have to be updated"""
    where: club_bool_exp!
  ): club_mutation_response

  """
  update data of the table: "club_rank"
  """
  update_club_rank(
    """increments the integer columns with given value of the filtered values"""
    _inc: club_rank_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_rank_set_input

    """filter the rows which have to be updated"""
    where: club_rank_bool_exp!
  ): club_rank_mutation_response

  """
  update data of the table: "competition"
  """
  update_competition(
    """increments the integer columns with given value of the filtered values"""
    _inc: competition_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: competition_set_input

    """filter the rows which have to be updated"""
    where: competition_bool_exp!
  ): competition_mutation_response

  """
  update data of the table: "competition_result"
  """
  update_competition_result(
    """increments the integer columns with given value of the filtered values"""
    _inc: competition_result_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: competition_result_set_input

    """filter the rows which have to be updated"""
    where: competition_result_bool_exp!
  ): competition_result_mutation_response

  """
  update data of the table: "player"
  """
  update_player(
    """increments the integer columns with given value of the filtered values"""
    _inc: player_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: player_set_input

    """filter the rows which have to be updated"""
    where: player_bool_exp!
  ): player_mutation_response
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "player"
"""
type player {
  apps: Float

  """An object relationship"""
  club: club
  club_id: Int
  goals: String
  name: String
  player_id: Int
  points: Float
  position: String
  tries: Float
}

"""
aggregated selection of "player"
"""
type player_aggregate {
  aggregate: player_aggregate_fields
  nodes: [player!]!
}

"""
aggregate fields of "player"
"""
type player_aggregate_fields {
  avg: player_avg_fields
  count(columns: [player_select_column!], distinct: Boolean): Int
  max: player_max_fields
  min: player_min_fields
  stddev: player_stddev_fields
  stddev_pop: player_stddev_pop_fields
  stddev_samp: player_stddev_samp_fields
  sum: player_sum_fields
  var_pop: player_var_pop_fields
  var_samp: player_var_samp_fields
  variance: player_variance_fields
}

"""
order by aggregate values of table "player"
"""
input player_aggregate_order_by {
  avg: player_avg_order_by
  count: order_by
  max: player_max_order_by
  min: player_min_order_by
  stddev: player_stddev_order_by
  stddev_pop: player_stddev_pop_order_by
  stddev_samp: player_stddev_samp_order_by
  sum: player_sum_order_by
  var_pop: player_var_pop_order_by
  var_samp: player_var_samp_order_by
  variance: player_variance_order_by
}

"""
input type for inserting array relation for remote table "player"
"""
input player_arr_rel_insert_input {
  data: [player_insert_input!]!
  on_conflict: player_on_conflict
}

"""aggregate avg on columns"""
type player_avg_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by avg() on columns of table "player"
"""
input player_avg_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""
Boolean expression to filter rows from the table "player". All fields are combined with a logical 'AND'.
"""
input player_bool_exp {
  _and: [player_bool_exp]
  _not: player_bool_exp
  _or: [player_bool_exp]
  apps: Float_comparison_exp
  club: club_bool_exp
  club_id: Int_comparison_exp
  goals: String_comparison_exp
  name: String_comparison_exp
  player_id: Int_comparison_exp
  points: Float_comparison_exp
  position: String_comparison_exp
  tries: Float_comparison_exp
}

"""
unique or primary key constraints on table "player"
"""
enum player_constraint {
  """unique or primary key constraint"""
  idx_24384_sqlite_autoindex_player_1
}

"""
input type for incrementing integer column in table "player"
"""
input player_inc_input {
  apps: Float
  club_id: Int
  player_id: Int
  points: Float
  tries: Float
}

"""
input type for inserting data into table "player"
"""
input player_insert_input {
  apps: Float
  club: club_obj_rel_insert_input
  club_id: Int
  goals: String
  name: String
  player_id: Int
  points: Float
  position: String
  tries: Float
}

"""aggregate max on columns"""
type player_max_fields {
  apps: Float
  club_id: Int
  goals: String
  name: String
  player_id: Int
  points: Float
  position: String
  tries: Float
}

"""
order by max() on columns of table "player"
"""
input player_max_order_by {
  apps: order_by
  club_id: order_by
  goals: order_by
  name: order_by
  player_id: order_by
  points: order_by
  position: order_by
  tries: order_by
}

"""aggregate min on columns"""
type player_min_fields {
  apps: Float
  club_id: Int
  goals: String
  name: String
  player_id: Int
  points: Float
  position: String
  tries: Float
}

"""
order by min() on columns of table "player"
"""
input player_min_order_by {
  apps: order_by
  club_id: order_by
  goals: order_by
  name: order_by
  player_id: order_by
  points: order_by
  position: order_by
  tries: order_by
}

"""
response of any mutation on the table "player"
"""
type player_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [player!]!
}

"""
input type for inserting object relation for remote table "player"
"""
input player_obj_rel_insert_input {
  data: player_insert_input!
  on_conflict: player_on_conflict
}

"""
on conflict condition type for table "player"
"""
input player_on_conflict {
  constraint: player_constraint!
  update_columns: [player_update_column!]!
  where: player_bool_exp
}

"""
ordering options when selecting data from "player"
"""
input player_order_by {
  apps: order_by
  club: club_order_by
  club_id: order_by
  goals: order_by
  name: order_by
  player_id: order_by
  points: order_by
  position: order_by
  tries: order_by
}

"""
select columns of table "player"
"""
enum player_select_column {
  """column name"""
  apps

  """column name"""
  club_id

  """column name"""
  goals

  """column name"""
  name

  """column name"""
  player_id

  """column name"""
  points

  """column name"""
  position

  """column name"""
  tries
}

"""
input type for updating data in table "player"
"""
input player_set_input {
  apps: Float
  club_id: Int
  goals: String
  name: String
  player_id: Int
  points: Float
  position: String
  tries: Float
}

"""aggregate stddev on columns"""
type player_stddev_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by stddev() on columns of table "player"
"""
input player_stddev_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""aggregate stddev_pop on columns"""
type player_stddev_pop_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by stddev_pop() on columns of table "player"
"""
input player_stddev_pop_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""aggregate stddev_samp on columns"""
type player_stddev_samp_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by stddev_samp() on columns of table "player"
"""
input player_stddev_samp_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""aggregate sum on columns"""
type player_sum_fields {
  apps: Float
  club_id: Int
  player_id: Int
  points: Float
  tries: Float
}

"""
order by sum() on columns of table "player"
"""
input player_sum_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""
update columns of table "player"
"""
enum player_update_column {
  """column name"""
  apps

  """column name"""
  club_id

  """column name"""
  goals

  """column name"""
  name

  """column name"""
  player_id

  """column name"""
  points

  """column name"""
  position

  """column name"""
  tries
}

"""aggregate var_pop on columns"""
type player_var_pop_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by var_pop() on columns of table "player"
"""
input player_var_pop_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""aggregate var_samp on columns"""
type player_var_samp_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by var_samp() on columns of table "player"
"""
input player_var_samp_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""aggregate variance on columns"""
type player_variance_fields {
  apps: Float
  club_id: Float
  player_id: Float
  points: Float
  tries: Float
}

"""
order by variance() on columns of table "player"
"""
input player_variance_order_by {
  apps: order_by
  club_id: order_by
  player_id: order_by
  points: order_by
  tries: order_by
}

"""query root"""
type query_root {
  """
  fetch data from the table: "club"
  """
  club(
    """distinct select on columns"""
    distinct_on: [club_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_order_by!]

    """filter the rows returned"""
    where: club_bool_exp
  ): [club!]!

  """
  fetch aggregated fields from the table: "club"
  """
  club_aggregate(
    """distinct select on columns"""
    distinct_on: [club_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_order_by!]

    """filter the rows returned"""
    where: club_bool_exp
  ): club_aggregate!

  """
  fetch data from the table: "club_rank"
  """
  club_rank(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): [club_rank!]!

  """
  fetch aggregated fields from the table: "club_rank"
  """
  club_rank_aggregate(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): club_rank_aggregate!

  """
  fetch data from the table: "competition"
  """
  competition(
    """distinct select on columns"""
    distinct_on: [competition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_order_by!]

    """filter the rows returned"""
    where: competition_bool_exp
  ): [competition!]!

  """
  fetch aggregated fields from the table: "competition"
  """
  competition_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_order_by!]

    """filter the rows returned"""
    where: competition_bool_exp
  ): competition_aggregate!

  """
  fetch data from the table: "competition_result"
  """
  competition_result(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): [competition_result!]!

  """
  fetch aggregated fields from the table: "competition_result"
  """
  competition_result_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): competition_result_aggregate!

  """
  fetch data from the table: "player"
  """
  player(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): [player!]!

  """
  fetch aggregated fields from the table: "player"
  """
  player_aggregate(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): player_aggregate!
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "club"
  """
  club(
    """distinct select on columns"""
    distinct_on: [club_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_order_by!]

    """filter the rows returned"""
    where: club_bool_exp
  ): [club!]!

  """
  fetch aggregated fields from the table: "club"
  """
  club_aggregate(
    """distinct select on columns"""
    distinct_on: [club_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_order_by!]

    """filter the rows returned"""
    where: club_bool_exp
  ): club_aggregate!

  """
  fetch data from the table: "club_rank"
  """
  club_rank(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): [club_rank!]!

  """
  fetch aggregated fields from the table: "club_rank"
  """
  club_rank_aggregate(
    """distinct select on columns"""
    distinct_on: [club_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_rank_order_by!]

    """filter the rows returned"""
    where: club_rank_bool_exp
  ): club_rank_aggregate!

  """
  fetch data from the table: "competition"
  """
  competition(
    """distinct select on columns"""
    distinct_on: [competition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_order_by!]

    """filter the rows returned"""
    where: competition_bool_exp
  ): [competition!]!

  """
  fetch aggregated fields from the table: "competition"
  """
  competition_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_order_by!]

    """filter the rows returned"""
    where: competition_bool_exp
  ): competition_aggregate!

  """
  fetch data from the table: "competition_result"
  """
  competition_result(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): [competition_result!]!

  """
  fetch aggregated fields from the table: "competition_result"
  """
  competition_result_aggregate(
    """distinct select on columns"""
    distinct_on: [competition_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [competition_result_order_by!]

    """filter the rows returned"""
    where: competition_result_bool_exp
  ): competition_result_aggregate!

  """
  fetch data from the table: "player"
  """
  player(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): [player!]!

  """
  fetch aggregated fields from the table: "player"
  """
  player_aggregate(
    """distinct select on columns"""
    distinct_on: [player_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [player_order_by!]

    """filter the rows returned"""
    where: player_bool_exp
  ): player_aggregate!
}
