schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "addresses"
"""
type addresses {
  address_id: String
  city_town: String
  line_1: String
  line_2: String
  other_details: String
  state_county: String
}

"""
aggregated selection of "addresses"
"""
type addresses_aggregate {
  aggregate: addresses_aggregate_fields
  nodes: [addresses!]!
}

"""
aggregate fields of "addresses"
"""
type addresses_aggregate_fields {
  count(columns: [addresses_select_column!], distinct: Boolean): Int
  max: addresses_max_fields
  min: addresses_min_fields
}

"""
order by aggregate values of table "addresses"
"""
input addresses_aggregate_order_by {
  count: order_by
  max: addresses_max_order_by
  min: addresses_min_order_by
}

"""
input type for inserting array relation for remote table "addresses"
"""
input addresses_arr_rel_insert_input {
  data: [addresses_insert_input!]!
  on_conflict: addresses_on_conflict
}

"""
Boolean expression to filter rows from the table "addresses". All fields are combined with a logical 'AND'.
"""
input addresses_bool_exp {
  _and: [addresses_bool_exp]
  _not: addresses_bool_exp
  _or: [addresses_bool_exp]
  address_id: String_comparison_exp
  city_town: String_comparison_exp
  line_1: String_comparison_exp
  line_2: String_comparison_exp
  other_details: String_comparison_exp
  state_county: String_comparison_exp
}

"""
unique or primary key constraints on table "addresses"
"""
enum addresses_constraint {
  """unique or primary key constraint"""
  idx_23955_sqlite_autoindex_addresses_1
}

"""
input type for inserting data into table "addresses"
"""
input addresses_insert_input {
  address_id: String
  city_town: String
  line_1: String
  line_2: String
  other_details: String
  state_county: String
}

"""aggregate max on columns"""
type addresses_max_fields {
  address_id: String
  city_town: String
  line_1: String
  line_2: String
  other_details: String
  state_county: String
}

"""
order by max() on columns of table "addresses"
"""
input addresses_max_order_by {
  address_id: order_by
  city_town: order_by
  line_1: order_by
  line_2: order_by
  other_details: order_by
  state_county: order_by
}

"""aggregate min on columns"""
type addresses_min_fields {
  address_id: String
  city_town: String
  line_1: String
  line_2: String
  other_details: String
  state_county: String
}

"""
order by min() on columns of table "addresses"
"""
input addresses_min_order_by {
  address_id: order_by
  city_town: order_by
  line_1: order_by
  line_2: order_by
  other_details: order_by
  state_county: order_by
}

"""
response of any mutation on the table "addresses"
"""
type addresses_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [addresses!]!
}

"""
input type for inserting object relation for remote table "addresses"
"""
input addresses_obj_rel_insert_input {
  data: addresses_insert_input!
  on_conflict: addresses_on_conflict
}

"""
on conflict condition type for table "addresses"
"""
input addresses_on_conflict {
  constraint: addresses_constraint!
  update_columns: [addresses_update_column!]!
  where: addresses_bool_exp
}

"""
ordering options when selecting data from "addresses"
"""
input addresses_order_by {
  address_id: order_by
  city_town: order_by
  line_1: order_by
  line_2: order_by
  other_details: order_by
  state_county: order_by
}

"""
select columns of table "addresses"
"""
enum addresses_select_column {
  """column name"""
  address_id

  """column name"""
  city_town

  """column name"""
  line_1

  """column name"""
  line_2

  """column name"""
  other_details

  """column name"""
  state_county
}

"""
input type for updating data in table "addresses"
"""
input addresses_set_input {
  address_id: String
  city_town: String
  line_1: String
  line_2: String
  other_details: String
  state_county: String
}

"""
update columns of table "addresses"
"""
enum addresses_update_column {
  """column name"""
  address_id

  """column name"""
  city_town

  """column name"""
  line_1

  """column name"""
  line_2

  """column name"""
  other_details

  """column name"""
  state_county
}

scalar bigint

"""
expression to compare columns of type bigint. All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "bookings"
"""
type bookings {
  actual_delivery_date: timestamptz
  booking_id: bigint!

  """An array relationship"""
  bookings_services(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): [bookings_services!]!

  """An aggregated array relationship"""
  bookings_services_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): bookings_services_aggregate!

  """An object relationship"""
  client: clients
  customer_id: bigint
  order_date: timestamptz
  other_order_details: String

  """An array relationship"""
  performers_in_bookings(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): [performers_in_bookings!]!

  """An aggregated array relationship"""
  performers_in_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): performers_in_bookings_aggregate!
  planned_delivery_date: timestamptz
  status_code: String
  store_id: bigint
  workshop_group_id: String
}

"""
aggregated selection of "bookings"
"""
type bookings_aggregate {
  aggregate: bookings_aggregate_fields
  nodes: [bookings!]!
}

"""
aggregate fields of "bookings"
"""
type bookings_aggregate_fields {
  avg: bookings_avg_fields
  count(columns: [bookings_select_column!], distinct: Boolean): Int
  max: bookings_max_fields
  min: bookings_min_fields
  stddev: bookings_stddev_fields
  stddev_pop: bookings_stddev_pop_fields
  stddev_samp: bookings_stddev_samp_fields
  sum: bookings_sum_fields
  var_pop: bookings_var_pop_fields
  var_samp: bookings_var_samp_fields
  variance: bookings_variance_fields
}

"""
order by aggregate values of table "bookings"
"""
input bookings_aggregate_order_by {
  avg: bookings_avg_order_by
  count: order_by
  max: bookings_max_order_by
  min: bookings_min_order_by
  stddev: bookings_stddev_order_by
  stddev_pop: bookings_stddev_pop_order_by
  stddev_samp: bookings_stddev_samp_order_by
  sum: bookings_sum_order_by
  var_pop: bookings_var_pop_order_by
  var_samp: bookings_var_samp_order_by
  variance: bookings_variance_order_by
}

"""
input type for inserting array relation for remote table "bookings"
"""
input bookings_arr_rel_insert_input {
  data: [bookings_insert_input!]!
  on_conflict: bookings_on_conflict
}

"""aggregate avg on columns"""
type bookings_avg_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by avg() on columns of table "bookings"
"""
input bookings_avg_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""
Boolean expression to filter rows from the table "bookings". All fields are combined with a logical 'AND'.
"""
input bookings_bool_exp {
  _and: [bookings_bool_exp]
  _not: bookings_bool_exp
  _or: [bookings_bool_exp]
  actual_delivery_date: timestamptz_comparison_exp
  booking_id: bigint_comparison_exp
  bookings_services: bookings_services_bool_exp
  client: clients_bool_exp
  customer_id: bigint_comparison_exp
  order_date: timestamptz_comparison_exp
  other_order_details: String_comparison_exp
  performers_in_bookings: performers_in_bookings_bool_exp
  planned_delivery_date: timestamptz_comparison_exp
  status_code: String_comparison_exp
  store_id: bigint_comparison_exp
  workshop_group_id: String_comparison_exp
}

"""
unique or primary key constraints on table "bookings"
"""
enum bookings_constraint {
  """unique or primary key constraint"""
  idx_24003_bookings_pkey

  """unique or primary key constraint"""
  idx_24003_sqlite_autoindex_bookings_1
}

"""
input type for incrementing integer column in table "bookings"
"""
input bookings_inc_input {
  booking_id: bigint
  customer_id: bigint
  store_id: bigint
}

"""
input type for inserting data into table "bookings"
"""
input bookings_insert_input {
  actual_delivery_date: timestamptz
  booking_id: bigint
  bookings_services: bookings_services_arr_rel_insert_input
  client: clients_obj_rel_insert_input
  customer_id: bigint
  order_date: timestamptz
  other_order_details: String
  performers_in_bookings: performers_in_bookings_arr_rel_insert_input
  planned_delivery_date: timestamptz
  status_code: String
  store_id: bigint
  workshop_group_id: String
}

"""aggregate max on columns"""
type bookings_max_fields {
  actual_delivery_date: timestamptz
  booking_id: bigint
  customer_id: bigint
  order_date: timestamptz
  other_order_details: String
  planned_delivery_date: timestamptz
  status_code: String
  store_id: bigint
  workshop_group_id: String
}

"""
order by max() on columns of table "bookings"
"""
input bookings_max_order_by {
  actual_delivery_date: order_by
  booking_id: order_by
  customer_id: order_by
  order_date: order_by
  other_order_details: order_by
  planned_delivery_date: order_by
  status_code: order_by
  store_id: order_by
  workshop_group_id: order_by
}

"""aggregate min on columns"""
type bookings_min_fields {
  actual_delivery_date: timestamptz
  booking_id: bigint
  customer_id: bigint
  order_date: timestamptz
  other_order_details: String
  planned_delivery_date: timestamptz
  status_code: String
  store_id: bigint
  workshop_group_id: String
}

"""
order by min() on columns of table "bookings"
"""
input bookings_min_order_by {
  actual_delivery_date: order_by
  booking_id: order_by
  customer_id: order_by
  order_date: order_by
  other_order_details: order_by
  planned_delivery_date: order_by
  status_code: order_by
  store_id: order_by
  workshop_group_id: order_by
}

"""
response of any mutation on the table "bookings"
"""
type bookings_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [bookings!]!
}

"""
input type for inserting object relation for remote table "bookings"
"""
input bookings_obj_rel_insert_input {
  data: bookings_insert_input!
  on_conflict: bookings_on_conflict
}

"""
on conflict condition type for table "bookings"
"""
input bookings_on_conflict {
  constraint: bookings_constraint!
  update_columns: [bookings_update_column!]!
  where: bookings_bool_exp
}

"""
ordering options when selecting data from "bookings"
"""
input bookings_order_by {
  actual_delivery_date: order_by
  booking_id: order_by
  bookings_services_aggregate: bookings_services_aggregate_order_by
  client: clients_order_by
  customer_id: order_by
  order_date: order_by
  other_order_details: order_by
  performers_in_bookings_aggregate: performers_in_bookings_aggregate_order_by
  planned_delivery_date: order_by
  status_code: order_by
  store_id: order_by
  workshop_group_id: order_by
}

"""
primary key columns input for table: "bookings"
"""
input bookings_pk_columns_input {
  booking_id: bigint!
}

"""
select columns of table "bookings"
"""
enum bookings_select_column {
  """column name"""
  actual_delivery_date

  """column name"""
  booking_id

  """column name"""
  customer_id

  """column name"""
  order_date

  """column name"""
  other_order_details

  """column name"""
  planned_delivery_date

  """column name"""
  status_code

  """column name"""
  store_id

  """column name"""
  workshop_group_id
}

"""
columns and relationships of "bookings_services"
"""
type bookings_services {
  """An object relationship"""
  booking: bookings!

  """An array relationship"""
  invoice_items(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): [invoice_items!]!

  """An aggregated array relationship"""
  invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): invoice_items_aggregate!
  order_id: bigint!
  product_id: bigint!

  """An object relationship"""
  service: services!
}

"""
aggregated selection of "bookings_services"
"""
type bookings_services_aggregate {
  aggregate: bookings_services_aggregate_fields
  nodes: [bookings_services!]!
}

"""
aggregate fields of "bookings_services"
"""
type bookings_services_aggregate_fields {
  avg: bookings_services_avg_fields
  count(columns: [bookings_services_select_column!], distinct: Boolean): Int
  max: bookings_services_max_fields
  min: bookings_services_min_fields
  stddev: bookings_services_stddev_fields
  stddev_pop: bookings_services_stddev_pop_fields
  stddev_samp: bookings_services_stddev_samp_fields
  sum: bookings_services_sum_fields
  var_pop: bookings_services_var_pop_fields
  var_samp: bookings_services_var_samp_fields
  variance: bookings_services_variance_fields
}

"""
order by aggregate values of table "bookings_services"
"""
input bookings_services_aggregate_order_by {
  avg: bookings_services_avg_order_by
  count: order_by
  max: bookings_services_max_order_by
  min: bookings_services_min_order_by
  stddev: bookings_services_stddev_order_by
  stddev_pop: bookings_services_stddev_pop_order_by
  stddev_samp: bookings_services_stddev_samp_order_by
  sum: bookings_services_sum_order_by
  var_pop: bookings_services_var_pop_order_by
  var_samp: bookings_services_var_samp_order_by
  variance: bookings_services_variance_order_by
}

"""
input type for inserting array relation for remote table "bookings_services"
"""
input bookings_services_arr_rel_insert_input {
  data: [bookings_services_insert_input!]!
  on_conflict: bookings_services_on_conflict
}

"""aggregate avg on columns"""
type bookings_services_avg_fields {
  order_id: Float
  product_id: Float
}

"""
order by avg() on columns of table "bookings_services"
"""
input bookings_services_avg_order_by {
  order_id: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "bookings_services". All fields are combined with a logical 'AND'.
"""
input bookings_services_bool_exp {
  _and: [bookings_services_bool_exp]
  _not: bookings_services_bool_exp
  _or: [bookings_services_bool_exp]
  booking: bookings_bool_exp
  invoice_items: invoice_items_bool_exp
  order_id: bigint_comparison_exp
  product_id: bigint_comparison_exp
  service: services_bool_exp
}

"""
unique or primary key constraints on table "bookings_services"
"""
enum bookings_services_constraint {
  """unique or primary key constraint"""
  idx_24036_bookings_services_pkey

  """unique or primary key constraint"""
  idx_24036_sqlite_autoindex_bookings_services_1
}

"""
input type for incrementing integer column in table "bookings_services"
"""
input bookings_services_inc_input {
  order_id: bigint
  product_id: bigint
}

"""
input type for inserting data into table "bookings_services"
"""
input bookings_services_insert_input {
  booking: bookings_obj_rel_insert_input
  invoice_items: invoice_items_arr_rel_insert_input
  order_id: bigint
  product_id: bigint
  service: services_obj_rel_insert_input
}

"""aggregate max on columns"""
type bookings_services_max_fields {
  order_id: bigint
  product_id: bigint
}

"""
order by max() on columns of table "bookings_services"
"""
input bookings_services_max_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type bookings_services_min_fields {
  order_id: bigint
  product_id: bigint
}

"""
order by min() on columns of table "bookings_services"
"""
input bookings_services_min_order_by {
  order_id: order_by
  product_id: order_by
}

"""
response of any mutation on the table "bookings_services"
"""
type bookings_services_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [bookings_services!]!
}

"""
input type for inserting object relation for remote table "bookings_services"
"""
input bookings_services_obj_rel_insert_input {
  data: bookings_services_insert_input!
  on_conflict: bookings_services_on_conflict
}

"""
on conflict condition type for table "bookings_services"
"""
input bookings_services_on_conflict {
  constraint: bookings_services_constraint!
  update_columns: [bookings_services_update_column!]!
  where: bookings_services_bool_exp
}

"""
ordering options when selecting data from "bookings_services"
"""
input bookings_services_order_by {
  booking: bookings_order_by
  invoice_items_aggregate: invoice_items_aggregate_order_by
  order_id: order_by
  product_id: order_by
  service: services_order_by
}

"""
primary key columns input for table: "bookings_services"
"""
input bookings_services_pk_columns_input {
  order_id: bigint!
  product_id: bigint!
}

"""
select columns of table "bookings_services"
"""
enum bookings_services_select_column {
  """column name"""
  order_id

  """column name"""
  product_id
}

"""
input type for updating data in table "bookings_services"
"""
input bookings_services_set_input {
  order_id: bigint
  product_id: bigint
}

"""aggregate stddev on columns"""
type bookings_services_stddev_fields {
  order_id: Float
  product_id: Float
}

"""
order by stddev() on columns of table "bookings_services"
"""
input bookings_services_stddev_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type bookings_services_stddev_pop_fields {
  order_id: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "bookings_services"
"""
input bookings_services_stddev_pop_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type bookings_services_stddev_samp_fields {
  order_id: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "bookings_services"
"""
input bookings_services_stddev_samp_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate sum on columns"""
type bookings_services_sum_fields {
  order_id: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "bookings_services"
"""
input bookings_services_sum_order_by {
  order_id: order_by
  product_id: order_by
}

"""
update columns of table "bookings_services"
"""
enum bookings_services_update_column {
  """column name"""
  order_id

  """column name"""
  product_id
}

"""aggregate var_pop on columns"""
type bookings_services_var_pop_fields {
  order_id: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "bookings_services"
"""
input bookings_services_var_pop_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type bookings_services_var_samp_fields {
  order_id: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "bookings_services"
"""
input bookings_services_var_samp_order_by {
  order_id: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type bookings_services_variance_fields {
  order_id: Float
  product_id: Float
}

"""
order by variance() on columns of table "bookings_services"
"""
input bookings_services_variance_order_by {
  order_id: order_by
  product_id: order_by
}

"""
input type for updating data in table "bookings"
"""
input bookings_set_input {
  actual_delivery_date: timestamptz
  booking_id: bigint
  customer_id: bigint
  order_date: timestamptz
  other_order_details: String
  planned_delivery_date: timestamptz
  status_code: String
  store_id: bigint
  workshop_group_id: String
}

"""aggregate stddev on columns"""
type bookings_stddev_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by stddev() on columns of table "bookings"
"""
input bookings_stddev_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""aggregate stddev_pop on columns"""
type bookings_stddev_pop_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by stddev_pop() on columns of table "bookings"
"""
input bookings_stddev_pop_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""aggregate stddev_samp on columns"""
type bookings_stddev_samp_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by stddev_samp() on columns of table "bookings"
"""
input bookings_stddev_samp_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""aggregate sum on columns"""
type bookings_sum_fields {
  booking_id: bigint
  customer_id: bigint
  store_id: bigint
}

"""
order by sum() on columns of table "bookings"
"""
input bookings_sum_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""
update columns of table "bookings"
"""
enum bookings_update_column {
  """column name"""
  actual_delivery_date

  """column name"""
  booking_id

  """column name"""
  customer_id

  """column name"""
  order_date

  """column name"""
  other_order_details

  """column name"""
  planned_delivery_date

  """column name"""
  status_code

  """column name"""
  store_id

  """column name"""
  workshop_group_id
}

"""aggregate var_pop on columns"""
type bookings_var_pop_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by var_pop() on columns of table "bookings"
"""
input bookings_var_pop_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""aggregate var_samp on columns"""
type bookings_var_samp_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by var_samp() on columns of table "bookings"
"""
input bookings_var_samp_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""aggregate variance on columns"""
type bookings_variance_fields {
  booking_id: Float
  customer_id: Float
  store_id: Float
}

"""
order by variance() on columns of table "bookings"
"""
input bookings_variance_order_by {
  booking_id: order_by
  customer_id: order_by
  store_id: order_by
}

"""
columns and relationships of "clients"
"""
type clients {
  address_id: bigint

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """An aggregated array relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!
  client_id: bigint!
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
aggregated selection of "clients"
"""
type clients_aggregate {
  aggregate: clients_aggregate_fields
  nodes: [clients!]!
}

"""
aggregate fields of "clients"
"""
type clients_aggregate_fields {
  avg: clients_avg_fields
  count(columns: [clients_select_column!], distinct: Boolean): Int
  max: clients_max_fields
  min: clients_min_fields
  stddev: clients_stddev_fields
  stddev_pop: clients_stddev_pop_fields
  stddev_samp: clients_stddev_samp_fields
  sum: clients_sum_fields
  var_pop: clients_var_pop_fields
  var_samp: clients_var_samp_fields
  variance: clients_variance_fields
}

"""
order by aggregate values of table "clients"
"""
input clients_aggregate_order_by {
  avg: clients_avg_order_by
  count: order_by
  max: clients_max_order_by
  min: clients_min_order_by
  stddev: clients_stddev_order_by
  stddev_pop: clients_stddev_pop_order_by
  stddev_samp: clients_stddev_samp_order_by
  sum: clients_sum_order_by
  var_pop: clients_var_pop_order_by
  var_samp: clients_var_samp_order_by
  variance: clients_variance_order_by
}

"""
input type for inserting array relation for remote table "clients"
"""
input clients_arr_rel_insert_input {
  data: [clients_insert_input!]!
  on_conflict: clients_on_conflict
}

"""aggregate avg on columns"""
type clients_avg_fields {
  address_id: Float
  client_id: Float
}

"""
order by avg() on columns of table "clients"
"""
input clients_avg_order_by {
  address_id: order_by
  client_id: order_by
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input clients_bool_exp {
  _and: [clients_bool_exp]
  _not: clients_bool_exp
  _or: [clients_bool_exp]
  address_id: bigint_comparison_exp
  bookings: bookings_bool_exp
  client_id: bigint_comparison_exp
  customer_email_address: String_comparison_exp
  customer_name: String_comparison_exp
  customer_phone: String_comparison_exp
  other_details: String_comparison_exp
}

"""
unique or primary key constraints on table "clients"
"""
enum clients_constraint {
  """unique or primary key constraint"""
  idx_23973_clients_pkey

  """unique or primary key constraint"""
  idx_23973_sqlite_autoindex_clients_1
}

"""
input type for incrementing integer column in table "clients"
"""
input clients_inc_input {
  address_id: bigint
  client_id: bigint
}

"""
input type for inserting data into table "clients"
"""
input clients_insert_input {
  address_id: bigint
  bookings: bookings_arr_rel_insert_input
  client_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""aggregate max on columns"""
type clients_max_fields {
  address_id: bigint
  client_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
order by max() on columns of table "clients"
"""
input clients_max_order_by {
  address_id: order_by
  client_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""aggregate min on columns"""
type clients_min_fields {
  address_id: bigint
  client_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
order by min() on columns of table "clients"
"""
input clients_min_order_by {
  address_id: order_by
  client_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""
response of any mutation on the table "clients"
"""
type clients_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input clients_obj_rel_insert_input {
  data: clients_insert_input!
  on_conflict: clients_on_conflict
}

"""
on conflict condition type for table "clients"
"""
input clients_on_conflict {
  constraint: clients_constraint!
  update_columns: [clients_update_column!]!
  where: clients_bool_exp
}

"""
ordering options when selecting data from "clients"
"""
input clients_order_by {
  address_id: order_by
  bookings_aggregate: bookings_aggregate_order_by
  client_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""
primary key columns input for table: "clients"
"""
input clients_pk_columns_input {
  client_id: bigint!
}

"""
select columns of table "clients"
"""
enum clients_select_column {
  """column name"""
  address_id

  """column name"""
  client_id

  """column name"""
  customer_email_address

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details
}

"""
input type for updating data in table "clients"
"""
input clients_set_input {
  address_id: bigint
  client_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""aggregate stddev on columns"""
type clients_stddev_fields {
  address_id: Float
  client_id: Float
}

"""
order by stddev() on columns of table "clients"
"""
input clients_stddev_order_by {
  address_id: order_by
  client_id: order_by
}

"""aggregate stddev_pop on columns"""
type clients_stddev_pop_fields {
  address_id: Float
  client_id: Float
}

"""
order by stddev_pop() on columns of table "clients"
"""
input clients_stddev_pop_order_by {
  address_id: order_by
  client_id: order_by
}

"""aggregate stddev_samp on columns"""
type clients_stddev_samp_fields {
  address_id: Float
  client_id: Float
}

"""
order by stddev_samp() on columns of table "clients"
"""
input clients_stddev_samp_order_by {
  address_id: order_by
  client_id: order_by
}

"""aggregate sum on columns"""
type clients_sum_fields {
  address_id: bigint
  client_id: bigint
}

"""
order by sum() on columns of table "clients"
"""
input clients_sum_order_by {
  address_id: order_by
  client_id: order_by
}

"""
update columns of table "clients"
"""
enum clients_update_column {
  """column name"""
  address_id

  """column name"""
  client_id

  """column name"""
  customer_email_address

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details
}

"""aggregate var_pop on columns"""
type clients_var_pop_fields {
  address_id: Float
  client_id: Float
}

"""
order by var_pop() on columns of table "clients"
"""
input clients_var_pop_order_by {
  address_id: order_by
  client_id: order_by
}

"""aggregate var_samp on columns"""
type clients_var_samp_fields {
  address_id: Float
  client_id: Float
}

"""
order by var_samp() on columns of table "clients"
"""
input clients_var_samp_order_by {
  address_id: order_by
  client_id: order_by
}

"""aggregate variance on columns"""
type clients_variance_fields {
  address_id: Float
  client_id: Float
}

"""
order by variance() on columns of table "clients"
"""
input clients_variance_order_by {
  address_id: order_by
  client_id: order_by
}

"""
columns and relationships of "customer_orders"
"""
type customer_orders {
  actual_delivery_date: timestamptz
  customer_id: bigint

  """An array relationship"""
  invoices(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): [invoices!]!

  """An aggregated array relationship"""
  invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): invoices_aggregate!
  order_date: timestamptz
  order_id: bigint!

  """An array relationship"""
  order_items(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """An aggregated array relationship"""
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): order_items_aggregate!
  other_order_details: String
  planned_delivery_date: timestamptz
  store_id: bigint
}

"""
aggregated selection of "customer_orders"
"""
type customer_orders_aggregate {
  aggregate: customer_orders_aggregate_fields
  nodes: [customer_orders!]!
}

"""
aggregate fields of "customer_orders"
"""
type customer_orders_aggregate_fields {
  avg: customer_orders_avg_fields
  count(columns: [customer_orders_select_column!], distinct: Boolean): Int
  max: customer_orders_max_fields
  min: customer_orders_min_fields
  stddev: customer_orders_stddev_fields
  stddev_pop: customer_orders_stddev_pop_fields
  stddev_samp: customer_orders_stddev_samp_fields
  sum: customer_orders_sum_fields
  var_pop: customer_orders_var_pop_fields
  var_samp: customer_orders_var_samp_fields
  variance: customer_orders_variance_fields
}

"""
order by aggregate values of table "customer_orders"
"""
input customer_orders_aggregate_order_by {
  avg: customer_orders_avg_order_by
  count: order_by
  max: customer_orders_max_order_by
  min: customer_orders_min_order_by
  stddev: customer_orders_stddev_order_by
  stddev_pop: customer_orders_stddev_pop_order_by
  stddev_samp: customer_orders_stddev_samp_order_by
  sum: customer_orders_sum_order_by
  var_pop: customer_orders_var_pop_order_by
  var_samp: customer_orders_var_samp_order_by
  variance: customer_orders_variance_order_by
}

"""
input type for inserting array relation for remote table "customer_orders"
"""
input customer_orders_arr_rel_insert_input {
  data: [customer_orders_insert_input!]!
  on_conflict: customer_orders_on_conflict
}

"""aggregate avg on columns"""
type customer_orders_avg_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by avg() on columns of table "customer_orders"
"""
input customer_orders_avg_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""
Boolean expression to filter rows from the table "customer_orders". All fields are combined with a logical 'AND'.
"""
input customer_orders_bool_exp {
  _and: [customer_orders_bool_exp]
  _not: customer_orders_bool_exp
  _or: [customer_orders_bool_exp]
  actual_delivery_date: timestamptz_comparison_exp
  customer_id: bigint_comparison_exp
  invoices: invoices_bool_exp
  order_date: timestamptz_comparison_exp
  order_id: bigint_comparison_exp
  order_items: order_items_bool_exp
  other_order_details: String_comparison_exp
  planned_delivery_date: timestamptz_comparison_exp
  store_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "customer_orders"
"""
enum customer_orders_constraint {
  """unique or primary key constraint"""
  idx_24012_customer_orders_pkey

  """unique or primary key constraint"""
  idx_24012_sqlite_autoindex_customer_orders_1
}

"""
input type for incrementing integer column in table "customer_orders"
"""
input customer_orders_inc_input {
  customer_id: bigint
  order_id: bigint
  store_id: bigint
}

"""
input type for inserting data into table "customer_orders"
"""
input customer_orders_insert_input {
  actual_delivery_date: timestamptz
  customer_id: bigint
  invoices: invoices_arr_rel_insert_input
  order_date: timestamptz
  order_id: bigint
  order_items: order_items_arr_rel_insert_input
  other_order_details: String
  planned_delivery_date: timestamptz
  store_id: bigint
}

"""aggregate max on columns"""
type customer_orders_max_fields {
  actual_delivery_date: timestamptz
  customer_id: bigint
  order_date: timestamptz
  order_id: bigint
  other_order_details: String
  planned_delivery_date: timestamptz
  store_id: bigint
}

"""
order by max() on columns of table "customer_orders"
"""
input customer_orders_max_order_by {
  actual_delivery_date: order_by
  customer_id: order_by
  order_date: order_by
  order_id: order_by
  other_order_details: order_by
  planned_delivery_date: order_by
  store_id: order_by
}

"""aggregate min on columns"""
type customer_orders_min_fields {
  actual_delivery_date: timestamptz
  customer_id: bigint
  order_date: timestamptz
  order_id: bigint
  other_order_details: String
  planned_delivery_date: timestamptz
  store_id: bigint
}

"""
order by min() on columns of table "customer_orders"
"""
input customer_orders_min_order_by {
  actual_delivery_date: order_by
  customer_id: order_by
  order_date: order_by
  order_id: order_by
  other_order_details: order_by
  planned_delivery_date: order_by
  store_id: order_by
}

"""
response of any mutation on the table "customer_orders"
"""
type customer_orders_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [customer_orders!]!
}

"""
input type for inserting object relation for remote table "customer_orders"
"""
input customer_orders_obj_rel_insert_input {
  data: customer_orders_insert_input!
  on_conflict: customer_orders_on_conflict
}

"""
on conflict condition type for table "customer_orders"
"""
input customer_orders_on_conflict {
  constraint: customer_orders_constraint!
  update_columns: [customer_orders_update_column!]!
  where: customer_orders_bool_exp
}

"""
ordering options when selecting data from "customer_orders"
"""
input customer_orders_order_by {
  actual_delivery_date: order_by
  customer_id: order_by
  invoices_aggregate: invoices_aggregate_order_by
  order_date: order_by
  order_id: order_by
  order_items_aggregate: order_items_aggregate_order_by
  other_order_details: order_by
  planned_delivery_date: order_by
  store_id: order_by
}

"""
primary key columns input for table: "customer_orders"
"""
input customer_orders_pk_columns_input {
  order_id: bigint!
}

"""
select columns of table "customer_orders"
"""
enum customer_orders_select_column {
  """column name"""
  actual_delivery_date

  """column name"""
  customer_id

  """column name"""
  order_date

  """column name"""
  order_id

  """column name"""
  other_order_details

  """column name"""
  planned_delivery_date

  """column name"""
  store_id
}

"""
input type for updating data in table "customer_orders"
"""
input customer_orders_set_input {
  actual_delivery_date: timestamptz
  customer_id: bigint
  order_date: timestamptz
  order_id: bigint
  other_order_details: String
  planned_delivery_date: timestamptz
  store_id: bigint
}

"""aggregate stddev on columns"""
type customer_orders_stddev_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by stddev() on columns of table "customer_orders"
"""
input customer_orders_stddev_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""aggregate stddev_pop on columns"""
type customer_orders_stddev_pop_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by stddev_pop() on columns of table "customer_orders"
"""
input customer_orders_stddev_pop_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""aggregate stddev_samp on columns"""
type customer_orders_stddev_samp_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by stddev_samp() on columns of table "customer_orders"
"""
input customer_orders_stddev_samp_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""aggregate sum on columns"""
type customer_orders_sum_fields {
  customer_id: bigint
  order_id: bigint
  store_id: bigint
}

"""
order by sum() on columns of table "customer_orders"
"""
input customer_orders_sum_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""
update columns of table "customer_orders"
"""
enum customer_orders_update_column {
  """column name"""
  actual_delivery_date

  """column name"""
  customer_id

  """column name"""
  order_date

  """column name"""
  order_id

  """column name"""
  other_order_details

  """column name"""
  planned_delivery_date

  """column name"""
  store_id
}

"""aggregate var_pop on columns"""
type customer_orders_var_pop_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by var_pop() on columns of table "customer_orders"
"""
input customer_orders_var_pop_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""aggregate var_samp on columns"""
type customer_orders_var_samp_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by var_samp() on columns of table "customer_orders"
"""
input customer_orders_var_samp_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""aggregate variance on columns"""
type customer_orders_variance_fields {
  customer_id: Float
  order_id: Float
  store_id: Float
}

"""
order by variance() on columns of table "customer_orders"
"""
input customer_orders_variance_order_by {
  customer_id: order_by
  order_id: order_by
  store_id: order_by
}

"""
columns and relationships of "customers"
"""
type customers {
  address_id: bigint
  customer_email_address: String
  customer_id: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
aggregated selection of "customers"
"""
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

"""
aggregate fields of "customers"
"""
type customers_aggregate_fields {
  avg: customers_avg_fields
  count(columns: [customers_select_column!], distinct: Boolean): Int
  max: customers_max_fields
  min: customers_min_fields
  stddev: customers_stddev_fields
  stddev_pop: customers_stddev_pop_fields
  stddev_samp: customers_stddev_samp_fields
  sum: customers_sum_fields
  var_pop: customers_var_pop_fields
  var_samp: customers_var_samp_fields
  variance: customers_variance_fields
}

"""
order by aggregate values of table "customers"
"""
input customers_aggregate_order_by {
  avg: customers_avg_order_by
  count: order_by
  max: customers_max_order_by
  min: customers_min_order_by
  stddev: customers_stddev_order_by
  stddev_pop: customers_stddev_pop_order_by
  stddev_samp: customers_stddev_samp_order_by
  sum: customers_sum_order_by
  var_pop: customers_var_pop_order_by
  var_samp: customers_var_samp_order_by
  variance: customers_variance_order_by
}

"""
input type for inserting array relation for remote table "customers"
"""
input customers_arr_rel_insert_input {
  data: [customers_insert_input!]!
  on_conflict: customers_on_conflict
}

"""aggregate avg on columns"""
type customers_avg_fields {
  address_id: Float
}

"""
order by avg() on columns of table "customers"
"""
input customers_avg_order_by {
  address_id: order_by
}

"""
Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'.
"""
input customers_bool_exp {
  _and: [customers_bool_exp]
  _not: customers_bool_exp
  _or: [customers_bool_exp]
  address_id: bigint_comparison_exp
  customer_email_address: String_comparison_exp
  customer_id: String_comparison_exp
  customer_name: String_comparison_exp
  customer_phone: String_comparison_exp
  other_details: String_comparison_exp
}

"""
unique or primary key constraints on table "customers"
"""
enum customers_constraint {
  """unique or primary key constraint"""
  idx_23991_sqlite_autoindex_customers_1
}

"""
input type for incrementing integer column in table "customers"
"""
input customers_inc_input {
  address_id: bigint
}

"""
input type for inserting data into table "customers"
"""
input customers_insert_input {
  address_id: bigint
  customer_email_address: String
  customer_id: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""aggregate max on columns"""
type customers_max_fields {
  address_id: bigint
  customer_email_address: String
  customer_id: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
order by max() on columns of table "customers"
"""
input customers_max_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_id: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""aggregate min on columns"""
type customers_min_fields {
  address_id: bigint
  customer_email_address: String
  customer_id: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""
order by min() on columns of table "customers"
"""
input customers_min_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_id: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""
response of any mutation on the table "customers"
"""
type customers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [customers!]!
}

"""
input type for inserting object relation for remote table "customers"
"""
input customers_obj_rel_insert_input {
  data: customers_insert_input!
  on_conflict: customers_on_conflict
}

"""
on conflict condition type for table "customers"
"""
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]!
  where: customers_bool_exp
}

"""
ordering options when selecting data from "customers"
"""
input customers_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_id: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
}

"""
select columns of table "customers"
"""
enum customers_select_column {
  """column name"""
  address_id

  """column name"""
  customer_email_address

  """column name"""
  customer_id

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details
}

"""
input type for updating data in table "customers"
"""
input customers_set_input {
  address_id: bigint
  customer_email_address: String
  customer_id: String
  customer_name: String
  customer_phone: String
  other_details: String
}

"""aggregate stddev on columns"""
type customers_stddev_fields {
  address_id: Float
}

"""
order by stddev() on columns of table "customers"
"""
input customers_stddev_order_by {
  address_id: order_by
}

"""aggregate stddev_pop on columns"""
type customers_stddev_pop_fields {
  address_id: Float
}

"""
order by stddev_pop() on columns of table "customers"
"""
input customers_stddev_pop_order_by {
  address_id: order_by
}

"""aggregate stddev_samp on columns"""
type customers_stddev_samp_fields {
  address_id: Float
}

"""
order by stddev_samp() on columns of table "customers"
"""
input customers_stddev_samp_order_by {
  address_id: order_by
}

"""aggregate sum on columns"""
type customers_sum_fields {
  address_id: bigint
}

"""
order by sum() on columns of table "customers"
"""
input customers_sum_order_by {
  address_id: order_by
}

"""
update columns of table "customers"
"""
enum customers_update_column {
  """column name"""
  address_id

  """column name"""
  customer_email_address

  """column name"""
  customer_id

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details
}

"""aggregate var_pop on columns"""
type customers_var_pop_fields {
  address_id: Float
}

"""
order by var_pop() on columns of table "customers"
"""
input customers_var_pop_order_by {
  address_id: order_by
}

"""aggregate var_samp on columns"""
type customers_var_samp_fields {
  address_id: Float
}

"""
order by var_samp() on columns of table "customers"
"""
input customers_var_samp_order_by {
  address_id: order_by
}

"""aggregate variance on columns"""
type customers_variance_fields {
  address_id: Float
}

"""
order by variance() on columns of table "customers"
"""
input customers_variance_order_by {
  address_id: order_by
}

"""
columns and relationships of "drama_workshop_groups"
"""
type drama_workshop_groups {
  address_id: bigint
  currency_code: String
  marketing_region_code: String
  other_details: String

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregated array relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  store_email_address: String
  store_name: String
  store_phone: String
  workshop_group_id: bigint!
}

"""
aggregated selection of "drama_workshop_groups"
"""
type drama_workshop_groups_aggregate {
  aggregate: drama_workshop_groups_aggregate_fields
  nodes: [drama_workshop_groups!]!
}

"""
aggregate fields of "drama_workshop_groups"
"""
type drama_workshop_groups_aggregate_fields {
  avg: drama_workshop_groups_avg_fields
  count(columns: [drama_workshop_groups_select_column!], distinct: Boolean): Int
  max: drama_workshop_groups_max_fields
  min: drama_workshop_groups_min_fields
  stddev: drama_workshop_groups_stddev_fields
  stddev_pop: drama_workshop_groups_stddev_pop_fields
  stddev_samp: drama_workshop_groups_stddev_samp_fields
  sum: drama_workshop_groups_sum_fields
  var_pop: drama_workshop_groups_var_pop_fields
  var_samp: drama_workshop_groups_var_samp_fields
  variance: drama_workshop_groups_variance_fields
}

"""
order by aggregate values of table "drama_workshop_groups"
"""
input drama_workshop_groups_aggregate_order_by {
  avg: drama_workshop_groups_avg_order_by
  count: order_by
  max: drama_workshop_groups_max_order_by
  min: drama_workshop_groups_min_order_by
  stddev: drama_workshop_groups_stddev_order_by
  stddev_pop: drama_workshop_groups_stddev_pop_order_by
  stddev_samp: drama_workshop_groups_stddev_samp_order_by
  sum: drama_workshop_groups_sum_order_by
  var_pop: drama_workshop_groups_var_pop_order_by
  var_samp: drama_workshop_groups_var_samp_order_by
  variance: drama_workshop_groups_variance_order_by
}

"""
input type for inserting array relation for remote table "drama_workshop_groups"
"""
input drama_workshop_groups_arr_rel_insert_input {
  data: [drama_workshop_groups_insert_input!]!
  on_conflict: drama_workshop_groups_on_conflict
}

"""aggregate avg on columns"""
type drama_workshop_groups_avg_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by avg() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_avg_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""
Boolean expression to filter rows from the table "drama_workshop_groups". All fields are combined with a logical 'AND'.
"""
input drama_workshop_groups_bool_exp {
  _and: [drama_workshop_groups_bool_exp]
  _not: drama_workshop_groups_bool_exp
  _or: [drama_workshop_groups_bool_exp]
  address_id: bigint_comparison_exp
  currency_code: String_comparison_exp
  marketing_region_code: String_comparison_exp
  other_details: String_comparison_exp
  services: services_bool_exp
  store_email_address: String_comparison_exp
  store_name: String_comparison_exp
  store_phone: String_comparison_exp
  workshop_group_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "drama_workshop_groups"
"""
enum drama_workshop_groups_constraint {
  """unique or primary key constraint"""
  idx_23979_drama_workshop_groups_pkey

  """unique or primary key constraint"""
  idx_23979_sqlite_autoindex_drama_workshop_groups_1
}

"""
input type for incrementing integer column in table "drama_workshop_groups"
"""
input drama_workshop_groups_inc_input {
  address_id: bigint
  workshop_group_id: bigint
}

"""
input type for inserting data into table "drama_workshop_groups"
"""
input drama_workshop_groups_insert_input {
  address_id: bigint
  currency_code: String
  marketing_region_code: String
  other_details: String
  services: services_arr_rel_insert_input
  store_email_address: String
  store_name: String
  store_phone: String
  workshop_group_id: bigint
}

"""aggregate max on columns"""
type drama_workshop_groups_max_fields {
  address_id: bigint
  currency_code: String
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_name: String
  store_phone: String
  workshop_group_id: bigint
}

"""
order by max() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_max_order_by {
  address_id: order_by
  currency_code: order_by
  marketing_region_code: order_by
  other_details: order_by
  store_email_address: order_by
  store_name: order_by
  store_phone: order_by
  workshop_group_id: order_by
}

"""aggregate min on columns"""
type drama_workshop_groups_min_fields {
  address_id: bigint
  currency_code: String
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_name: String
  store_phone: String
  workshop_group_id: bigint
}

"""
order by min() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_min_order_by {
  address_id: order_by
  currency_code: order_by
  marketing_region_code: order_by
  other_details: order_by
  store_email_address: order_by
  store_name: order_by
  store_phone: order_by
  workshop_group_id: order_by
}

"""
response of any mutation on the table "drama_workshop_groups"
"""
type drama_workshop_groups_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [drama_workshop_groups!]!
}

"""
input type for inserting object relation for remote table "drama_workshop_groups"
"""
input drama_workshop_groups_obj_rel_insert_input {
  data: drama_workshop_groups_insert_input!
  on_conflict: drama_workshop_groups_on_conflict
}

"""
on conflict condition type for table "drama_workshop_groups"
"""
input drama_workshop_groups_on_conflict {
  constraint: drama_workshop_groups_constraint!
  update_columns: [drama_workshop_groups_update_column!]!
  where: drama_workshop_groups_bool_exp
}

"""
ordering options when selecting data from "drama_workshop_groups"
"""
input drama_workshop_groups_order_by {
  address_id: order_by
  currency_code: order_by
  marketing_region_code: order_by
  other_details: order_by
  services_aggregate: services_aggregate_order_by
  store_email_address: order_by
  store_name: order_by
  store_phone: order_by
  workshop_group_id: order_by
}

"""
primary key columns input for table: "drama_workshop_groups"
"""
input drama_workshop_groups_pk_columns_input {
  workshop_group_id: bigint!
}

"""
select columns of table "drama_workshop_groups"
"""
enum drama_workshop_groups_select_column {
  """column name"""
  address_id

  """column name"""
  currency_code

  """column name"""
  marketing_region_code

  """column name"""
  other_details

  """column name"""
  store_email_address

  """column name"""
  store_name

  """column name"""
  store_phone

  """column name"""
  workshop_group_id
}

"""
input type for updating data in table "drama_workshop_groups"
"""
input drama_workshop_groups_set_input {
  address_id: bigint
  currency_code: String
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_name: String
  store_phone: String
  workshop_group_id: bigint
}

"""aggregate stddev on columns"""
type drama_workshop_groups_stddev_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by stddev() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_stddev_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""aggregate stddev_pop on columns"""
type drama_workshop_groups_stddev_pop_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by stddev_pop() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_stddev_pop_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""aggregate stddev_samp on columns"""
type drama_workshop_groups_stddev_samp_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by stddev_samp() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_stddev_samp_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""aggregate sum on columns"""
type drama_workshop_groups_sum_fields {
  address_id: bigint
  workshop_group_id: bigint
}

"""
order by sum() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_sum_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""
update columns of table "drama_workshop_groups"
"""
enum drama_workshop_groups_update_column {
  """column name"""
  address_id

  """column name"""
  currency_code

  """column name"""
  marketing_region_code

  """column name"""
  other_details

  """column name"""
  store_email_address

  """column name"""
  store_name

  """column name"""
  store_phone

  """column name"""
  workshop_group_id
}

"""aggregate var_pop on columns"""
type drama_workshop_groups_var_pop_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by var_pop() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_var_pop_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""aggregate var_samp on columns"""
type drama_workshop_groups_var_samp_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by var_samp() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_var_samp_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""aggregate variance on columns"""
type drama_workshop_groups_variance_fields {
  address_id: Float
  workshop_group_id: Float
}

"""
order by variance() on columns of table "drama_workshop_groups"
"""
input drama_workshop_groups_variance_order_by {
  address_id: order_by
  workshop_group_id: order_by
}

"""
columns and relationships of "invoice_items"
"""
type invoice_items {
  """An object relationship"""
  bookings_service: bookings_services

  """An object relationship"""
  invoice: invoices
  invoice_id: bigint
  invoice_item_id: bigint!
  order_id: bigint

  """An object relationship"""
  order_item: order_items
  order_item_id: bigint
  order_quantity: bigint
  other_item_details: String
  product_id: bigint
}

"""
aggregated selection of "invoice_items"
"""
type invoice_items_aggregate {
  aggregate: invoice_items_aggregate_fields
  nodes: [invoice_items!]!
}

"""
aggregate fields of "invoice_items"
"""
type invoice_items_aggregate_fields {
  avg: invoice_items_avg_fields
  count(columns: [invoice_items_select_column!], distinct: Boolean): Int
  max: invoice_items_max_fields
  min: invoice_items_min_fields
  stddev: invoice_items_stddev_fields
  stddev_pop: invoice_items_stddev_pop_fields
  stddev_samp: invoice_items_stddev_samp_fields
  sum: invoice_items_sum_fields
  var_pop: invoice_items_var_pop_fields
  var_samp: invoice_items_var_samp_fields
  variance: invoice_items_variance_fields
}

"""
order by aggregate values of table "invoice_items"
"""
input invoice_items_aggregate_order_by {
  avg: invoice_items_avg_order_by
  count: order_by
  max: invoice_items_max_order_by
  min: invoice_items_min_order_by
  stddev: invoice_items_stddev_order_by
  stddev_pop: invoice_items_stddev_pop_order_by
  stddev_samp: invoice_items_stddev_samp_order_by
  sum: invoice_items_sum_order_by
  var_pop: invoice_items_var_pop_order_by
  var_samp: invoice_items_var_samp_order_by
  variance: invoice_items_variance_order_by
}

"""
input type for inserting array relation for remote table "invoice_items"
"""
input invoice_items_arr_rel_insert_input {
  data: [invoice_items_insert_input!]!
  on_conflict: invoice_items_on_conflict
}

"""aggregate avg on columns"""
type invoice_items_avg_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by avg() on columns of table "invoice_items"
"""
input invoice_items_avg_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "invoice_items". All fields are combined with a logical 'AND'.
"""
input invoice_items_bool_exp {
  _and: [invoice_items_bool_exp]
  _not: invoice_items_bool_exp
  _or: [invoice_items_bool_exp]
  bookings_service: bookings_services_bool_exp
  invoice: invoices_bool_exp
  invoice_id: bigint_comparison_exp
  invoice_item_id: bigint_comparison_exp
  order_id: bigint_comparison_exp
  order_item: order_items_bool_exp
  order_item_id: bigint_comparison_exp
  order_quantity: bigint_comparison_exp
  other_item_details: String_comparison_exp
  product_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "invoice_items"
"""
enum invoice_items_constraint {
  """unique or primary key constraint"""
  idx_24039_invoice_items_pkey
}

"""
input type for incrementing integer column in table "invoice_items"
"""
input invoice_items_inc_input {
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: bigint
  product_id: bigint
}

"""
input type for inserting data into table "invoice_items"
"""
input invoice_items_insert_input {
  bookings_service: bookings_services_obj_rel_insert_input
  invoice: invoices_obj_rel_insert_input
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item: order_items_obj_rel_insert_input
  order_item_id: bigint
  order_quantity: bigint
  other_item_details: String
  product_id: bigint
}

"""aggregate max on columns"""
type invoice_items_max_fields {
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: bigint
  other_item_details: String
  product_id: bigint
}

"""
order by max() on columns of table "invoice_items"
"""
input invoice_items_max_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type invoice_items_min_fields {
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: bigint
  other_item_details: String
  product_id: bigint
}

"""
order by min() on columns of table "invoice_items"
"""
input invoice_items_min_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""
response of any mutation on the table "invoice_items"
"""
type invoice_items_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [invoice_items!]!
}

"""
input type for inserting object relation for remote table "invoice_items"
"""
input invoice_items_obj_rel_insert_input {
  data: invoice_items_insert_input!
  on_conflict: invoice_items_on_conflict
}

"""
on conflict condition type for table "invoice_items"
"""
input invoice_items_on_conflict {
  constraint: invoice_items_constraint!
  update_columns: [invoice_items_update_column!]!
  where: invoice_items_bool_exp
}

"""
ordering options when selecting data from "invoice_items"
"""
input invoice_items_order_by {
  bookings_service: bookings_services_order_by
  invoice: invoices_order_by
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item: order_items_order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""
primary key columns input for table: "invoice_items"
"""
input invoice_items_pk_columns_input {
  invoice_item_id: bigint!
}

"""
select columns of table "invoice_items"
"""
enum invoice_items_select_column {
  """column name"""
  invoice_id

  """column name"""
  invoice_item_id

  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  product_id
}

"""
input type for updating data in table "invoice_items"
"""
input invoice_items_set_input {
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: bigint
  other_item_details: String
  product_id: bigint
}

"""aggregate stddev on columns"""
type invoice_items_stddev_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev() on columns of table "invoice_items"
"""
input invoice_items_stddev_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type invoice_items_stddev_pop_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "invoice_items"
"""
input invoice_items_stddev_pop_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type invoice_items_stddev_samp_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "invoice_items"
"""
input invoice_items_stddev_samp_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate sum on columns"""
type invoice_items_sum_fields {
  invoice_id: bigint
  invoice_item_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "invoice_items"
"""
input invoice_items_sum_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
update columns of table "invoice_items"
"""
enum invoice_items_update_column {
  """column name"""
  invoice_id

  """column name"""
  invoice_item_id

  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  product_id
}

"""aggregate var_pop on columns"""
type invoice_items_var_pop_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "invoice_items"
"""
input invoice_items_var_pop_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type invoice_items_var_samp_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "invoice_items"
"""
input invoice_items_var_samp_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type invoice_items_variance_fields {
  invoice_id: Float
  invoice_item_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by variance() on columns of table "invoice_items"
"""
input invoice_items_variance_order_by {
  invoice_id: order_by
  invoice_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
columns and relationships of "invoices"
"""
type invoices {
  """An object relationship"""
  customer_order: customer_orders
  invoice_id: bigint!

  """An array relationship"""
  invoice_items(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): [invoice_items!]!

  """An aggregated array relationship"""
  invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): invoice_items_aggregate!
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  other_item_details: String
  payment_method_code: String
  product_id: bigint

  """An object relationship"""
  ref_payment_method: ref_payment_methods
}

"""
aggregated selection of "invoices"
"""
type invoices_aggregate {
  aggregate: invoices_aggregate_fields
  nodes: [invoices!]!
}

"""
aggregate fields of "invoices"
"""
type invoices_aggregate_fields {
  avg: invoices_avg_fields
  count(columns: [invoices_select_column!], distinct: Boolean): Int
  max: invoices_max_fields
  min: invoices_min_fields
  stddev: invoices_stddev_fields
  stddev_pop: invoices_stddev_pop_fields
  stddev_samp: invoices_stddev_samp_fields
  sum: invoices_sum_fields
  var_pop: invoices_var_pop_fields
  var_samp: invoices_var_samp_fields
  variance: invoices_variance_fields
}

"""
order by aggregate values of table "invoices"
"""
input invoices_aggregate_order_by {
  avg: invoices_avg_order_by
  count: order_by
  max: invoices_max_order_by
  min: invoices_min_order_by
  stddev: invoices_stddev_order_by
  stddev_pop: invoices_stddev_pop_order_by
  stddev_samp: invoices_stddev_samp_order_by
  sum: invoices_sum_order_by
  var_pop: invoices_var_pop_order_by
  var_samp: invoices_var_samp_order_by
  variance: invoices_variance_order_by
}

"""
input type for inserting array relation for remote table "invoices"
"""
input invoices_arr_rel_insert_input {
  data: [invoices_insert_input!]!
  on_conflict: invoices_on_conflict
}

"""aggregate avg on columns"""
type invoices_avg_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by avg() on columns of table "invoices"
"""
input invoices_avg_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "invoices". All fields are combined with a logical 'AND'.
"""
input invoices_bool_exp {
  _and: [invoices_bool_exp]
  _not: invoices_bool_exp
  _or: [invoices_bool_exp]
  customer_order: customer_orders_bool_exp
  invoice_id: bigint_comparison_exp
  invoice_items: invoice_items_bool_exp
  order_id: bigint_comparison_exp
  order_item_id: bigint_comparison_exp
  order_quantity: smallint_comparison_exp
  other_item_details: String_comparison_exp
  payment_method_code: String_comparison_exp
  product_id: bigint_comparison_exp
  ref_payment_method: ref_payment_methods_bool_exp
}

"""
unique or primary key constraints on table "invoices"
"""
enum invoices_constraint {
  """unique or primary key constraint"""
  idx_24024_invoices_pkey
}

"""
input type for incrementing integer column in table "invoices"
"""
input invoices_inc_input {
  invoice_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  product_id: bigint
}

"""
input type for inserting data into table "invoices"
"""
input invoices_insert_input {
  customer_order: customer_orders_obj_rel_insert_input
  invoice_id: bigint
  invoice_items: invoice_items_arr_rel_insert_input
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  other_item_details: String
  payment_method_code: String
  product_id: bigint
  ref_payment_method: ref_payment_methods_obj_rel_insert_input
}

"""aggregate max on columns"""
type invoices_max_fields {
  invoice_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  other_item_details: String
  payment_method_code: String
  product_id: bigint
}

"""
order by max() on columns of table "invoices"
"""
input invoices_max_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  payment_method_code: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type invoices_min_fields {
  invoice_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  other_item_details: String
  payment_method_code: String
  product_id: bigint
}

"""
order by min() on columns of table "invoices"
"""
input invoices_min_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  payment_method_code: order_by
  product_id: order_by
}

"""
response of any mutation on the table "invoices"
"""
type invoices_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [invoices!]!
}

"""
input type for inserting object relation for remote table "invoices"
"""
input invoices_obj_rel_insert_input {
  data: invoices_insert_input!
  on_conflict: invoices_on_conflict
}

"""
on conflict condition type for table "invoices"
"""
input invoices_on_conflict {
  constraint: invoices_constraint!
  update_columns: [invoices_update_column!]!
  where: invoices_bool_exp
}

"""
ordering options when selecting data from "invoices"
"""
input invoices_order_by {
  customer_order: customer_orders_order_by
  invoice_id: order_by
  invoice_items_aggregate: invoice_items_aggregate_order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  payment_method_code: order_by
  product_id: order_by
  ref_payment_method: ref_payment_methods_order_by
}

"""
primary key columns input for table: "invoices"
"""
input invoices_pk_columns_input {
  invoice_id: bigint!
}

"""
select columns of table "invoices"
"""
enum invoices_select_column {
  """column name"""
  invoice_id

  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  payment_method_code

  """column name"""
  product_id
}

"""
input type for updating data in table "invoices"
"""
input invoices_set_input {
  invoice_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  other_item_details: String
  payment_method_code: String
  product_id: bigint
}

"""aggregate stddev on columns"""
type invoices_stddev_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev() on columns of table "invoices"
"""
input invoices_stddev_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type invoices_stddev_pop_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "invoices"
"""
input invoices_stddev_pop_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type invoices_stddev_samp_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "invoices"
"""
input invoices_stddev_samp_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate sum on columns"""
type invoices_sum_fields {
  invoice_id: bigint
  order_id: bigint
  order_item_id: bigint
  order_quantity: smallint
  product_id: bigint
}

"""
order by sum() on columns of table "invoices"
"""
input invoices_sum_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
update columns of table "invoices"
"""
enum invoices_update_column {
  """column name"""
  invoice_id

  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  payment_method_code

  """column name"""
  product_id
}

"""aggregate var_pop on columns"""
type invoices_var_pop_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "invoices"
"""
input invoices_var_pop_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type invoices_var_samp_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "invoices"
"""
input invoices_var_samp_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type invoices_variance_fields {
  invoice_id: Float
  order_id: Float
  order_item_id: Float
  order_quantity: Float
  product_id: Float
}

"""
order by variance() on columns of table "invoices"
"""
input invoices_variance_order_by {
  invoice_id: order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  product_id: order_by
}

"""
columns and relationships of "marketing_regions"
"""
type marketing_regions {
  marketing_region_code: String
  marketing_region_descriptrion: String
  marketing_region_name: String
  other_details: String

  """An array relationship"""
  stores(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """An aggregated array relationship"""
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): stores_aggregate!
}

"""
aggregated selection of "marketing_regions"
"""
type marketing_regions_aggregate {
  aggregate: marketing_regions_aggregate_fields
  nodes: [marketing_regions!]!
}

"""
aggregate fields of "marketing_regions"
"""
type marketing_regions_aggregate_fields {
  count(columns: [marketing_regions_select_column!], distinct: Boolean): Int
  max: marketing_regions_max_fields
  min: marketing_regions_min_fields
}

"""
order by aggregate values of table "marketing_regions"
"""
input marketing_regions_aggregate_order_by {
  count: order_by
  max: marketing_regions_max_order_by
  min: marketing_regions_min_order_by
}

"""
input type for inserting array relation for remote table "marketing_regions"
"""
input marketing_regions_arr_rel_insert_input {
  data: [marketing_regions_insert_input!]!
  on_conflict: marketing_regions_on_conflict
}

"""
Boolean expression to filter rows from the table "marketing_regions". All fields are combined with a logical 'AND'.
"""
input marketing_regions_bool_exp {
  _and: [marketing_regions_bool_exp]
  _not: marketing_regions_bool_exp
  _or: [marketing_regions_bool_exp]
  marketing_region_code: String_comparison_exp
  marketing_region_descriptrion: String_comparison_exp
  marketing_region_name: String_comparison_exp
  other_details: String_comparison_exp
  stores: stores_bool_exp
}

"""
unique or primary key constraints on table "marketing_regions"
"""
enum marketing_regions_constraint {
  """unique or primary key constraint"""
  idx_23967_sqlite_autoindex_marketing_regions_1
}

"""
input type for inserting data into table "marketing_regions"
"""
input marketing_regions_insert_input {
  marketing_region_code: String
  marketing_region_descriptrion: String
  marketing_region_name: String
  other_details: String
  stores: stores_arr_rel_insert_input
}

"""aggregate max on columns"""
type marketing_regions_max_fields {
  marketing_region_code: String
  marketing_region_descriptrion: String
  marketing_region_name: String
  other_details: String
}

"""
order by max() on columns of table "marketing_regions"
"""
input marketing_regions_max_order_by {
  marketing_region_code: order_by
  marketing_region_descriptrion: order_by
  marketing_region_name: order_by
  other_details: order_by
}

"""aggregate min on columns"""
type marketing_regions_min_fields {
  marketing_region_code: String
  marketing_region_descriptrion: String
  marketing_region_name: String
  other_details: String
}

"""
order by min() on columns of table "marketing_regions"
"""
input marketing_regions_min_order_by {
  marketing_region_code: order_by
  marketing_region_descriptrion: order_by
  marketing_region_name: order_by
  other_details: order_by
}

"""
response of any mutation on the table "marketing_regions"
"""
type marketing_regions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [marketing_regions!]!
}

"""
input type for inserting object relation for remote table "marketing_regions"
"""
input marketing_regions_obj_rel_insert_input {
  data: marketing_regions_insert_input!
  on_conflict: marketing_regions_on_conflict
}

"""
on conflict condition type for table "marketing_regions"
"""
input marketing_regions_on_conflict {
  constraint: marketing_regions_constraint!
  update_columns: [marketing_regions_update_column!]!
  where: marketing_regions_bool_exp
}

"""
ordering options when selecting data from "marketing_regions"
"""
input marketing_regions_order_by {
  marketing_region_code: order_by
  marketing_region_descriptrion: order_by
  marketing_region_name: order_by
  other_details: order_by
  stores_aggregate: stores_aggregate_order_by
}

"""
select columns of table "marketing_regions"
"""
enum marketing_regions_select_column {
  """column name"""
  marketing_region_code

  """column name"""
  marketing_region_descriptrion

  """column name"""
  marketing_region_name

  """column name"""
  other_details
}

"""
input type for updating data in table "marketing_regions"
"""
input marketing_regions_set_input {
  marketing_region_code: String
  marketing_region_descriptrion: String
  marketing_region_name: String
  other_details: String
}

"""
update columns of table "marketing_regions"
"""
enum marketing_regions_update_column {
  """column name"""
  marketing_region_code

  """column name"""
  marketing_region_descriptrion

  """column name"""
  marketing_region_name

  """column name"""
  other_details
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "addresses"
  """
  delete_addresses(
    """filter the rows which have to be deleted"""
    where: addresses_bool_exp!
  ): addresses_mutation_response

  """
  delete data from the table: "bookings"
  """
  delete_bookings(
    """filter the rows which have to be deleted"""
    where: bookings_bool_exp!
  ): bookings_mutation_response

  """
  delete single row from the table: "bookings"
  """
  delete_bookings_by_pk(booking_id: bigint!): bookings

  """
  delete data from the table: "bookings_services"
  """
  delete_bookings_services(
    """filter the rows which have to be deleted"""
    where: bookings_services_bool_exp!
  ): bookings_services_mutation_response

  """
  delete single row from the table: "bookings_services"
  """
  delete_bookings_services_by_pk(order_id: bigint!, product_id: bigint!): bookings_services

  """
  delete data from the table: "clients"
  """
  delete_clients(
    """filter the rows which have to be deleted"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  delete single row from the table: "clients"
  """
  delete_clients_by_pk(client_id: bigint!): clients

  """
  delete data from the table: "customer_orders"
  """
  delete_customer_orders(
    """filter the rows which have to be deleted"""
    where: customer_orders_bool_exp!
  ): customer_orders_mutation_response

  """
  delete single row from the table: "customer_orders"
  """
  delete_customer_orders_by_pk(order_id: bigint!): customer_orders

  """
  delete data from the table: "customers"
  """
  delete_customers(
    """filter the rows which have to be deleted"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  delete data from the table: "drama_workshop_groups"
  """
  delete_drama_workshop_groups(
    """filter the rows which have to be deleted"""
    where: drama_workshop_groups_bool_exp!
  ): drama_workshop_groups_mutation_response

  """
  delete single row from the table: "drama_workshop_groups"
  """
  delete_drama_workshop_groups_by_pk(workshop_group_id: bigint!): drama_workshop_groups

  """
  delete data from the table: "invoice_items"
  """
  delete_invoice_items(
    """filter the rows which have to be deleted"""
    where: invoice_items_bool_exp!
  ): invoice_items_mutation_response

  """
  delete single row from the table: "invoice_items"
  """
  delete_invoice_items_by_pk(invoice_item_id: bigint!): invoice_items

  """
  delete data from the table: "invoices"
  """
  delete_invoices(
    """filter the rows which have to be deleted"""
    where: invoices_bool_exp!
  ): invoices_mutation_response

  """
  delete single row from the table: "invoices"
  """
  delete_invoices_by_pk(invoice_id: bigint!): invoices

  """
  delete data from the table: "marketing_regions"
  """
  delete_marketing_regions(
    """filter the rows which have to be deleted"""
    where: marketing_regions_bool_exp!
  ): marketing_regions_mutation_response

  """
  delete data from the table: "order_items"
  """
  delete_order_items(
    """filter the rows which have to be deleted"""
    where: order_items_bool_exp!
  ): order_items_mutation_response

  """
  delete single row from the table: "order_items"
  """
  delete_order_items_by_pk(order_item_id: bigint!): order_items

  """
  delete data from the table: "performers"
  """
  delete_performers(
    """filter the rows which have to be deleted"""
    where: performers_bool_exp!
  ): performers_mutation_response

  """
  delete single row from the table: "performers"
  """
  delete_performers_by_pk(performer_id: bigint!): performers

  """
  delete data from the table: "performers_in_bookings"
  """
  delete_performers_in_bookings(
    """filter the rows which have to be deleted"""
    where: performers_in_bookings_bool_exp!
  ): performers_in_bookings_mutation_response

  """
  delete single row from the table: "performers_in_bookings"
  """
  delete_performers_in_bookings_by_pk(order_id: bigint!, performer_id: bigint!): performers_in_bookings

  """
  delete data from the table: "products"
  """
  delete_products(
    """filter the rows which have to be deleted"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  delete data from the table: "ref_payment_methods"
  """
  delete_ref_payment_methods(
    """filter the rows which have to be deleted"""
    where: ref_payment_methods_bool_exp!
  ): ref_payment_methods_mutation_response

  """
  delete single row from the table: "ref_payment_methods"
  """
  delete_ref_payment_methods_by_pk(payment_method_code: String!): ref_payment_methods

  """
  delete data from the table: "ref_service_types"
  """
  delete_ref_service_types(
    """filter the rows which have to be deleted"""
    where: ref_service_types_bool_exp!
  ): ref_service_types_mutation_response

  """
  delete data from the table: "services"
  """
  delete_services(
    """filter the rows which have to be deleted"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  delete single row from the table: "services"
  """
  delete_services_by_pk(service_id: bigint!): services

  """
  delete data from the table: "stores"
  """
  delete_stores(
    """filter the rows which have to be deleted"""
    where: stores_bool_exp!
  ): stores_mutation_response

  """
  insert data into the table: "addresses"
  """
  insert_addresses(
    """the rows to be inserted"""
    objects: [addresses_insert_input!]!

    """on conflict condition"""
    on_conflict: addresses_on_conflict
  ): addresses_mutation_response

  """
  insert a single row into the table: "addresses"
  """
  insert_addresses_one(
    """the row to be inserted"""
    object: addresses_insert_input!

    """on conflict condition"""
    on_conflict: addresses_on_conflict
  ): addresses

  """
  insert data into the table: "bookings"
  """
  insert_bookings(
    """the rows to be inserted"""
    objects: [bookings_insert_input!]!

    """on conflict condition"""
    on_conflict: bookings_on_conflict
  ): bookings_mutation_response

  """
  insert a single row into the table: "bookings"
  """
  insert_bookings_one(
    """the row to be inserted"""
    object: bookings_insert_input!

    """on conflict condition"""
    on_conflict: bookings_on_conflict
  ): bookings

  """
  insert data into the table: "bookings_services"
  """
  insert_bookings_services(
    """the rows to be inserted"""
    objects: [bookings_services_insert_input!]!

    """on conflict condition"""
    on_conflict: bookings_services_on_conflict
  ): bookings_services_mutation_response

  """
  insert a single row into the table: "bookings_services"
  """
  insert_bookings_services_one(
    """the row to be inserted"""
    object: bookings_services_insert_input!

    """on conflict condition"""
    on_conflict: bookings_services_on_conflict
  ): bookings_services

  """
  insert data into the table: "clients"
  """
  insert_clients(
    """the rows to be inserted"""
    objects: [clients_insert_input!]!

    """on conflict condition"""
    on_conflict: clients_on_conflict
  ): clients_mutation_response

  """
  insert a single row into the table: "clients"
  """
  insert_clients_one(
    """the row to be inserted"""
    object: clients_insert_input!

    """on conflict condition"""
    on_conflict: clients_on_conflict
  ): clients

  """
  insert data into the table: "customer_orders"
  """
  insert_customer_orders(
    """the rows to be inserted"""
    objects: [customer_orders_insert_input!]!

    """on conflict condition"""
    on_conflict: customer_orders_on_conflict
  ): customer_orders_mutation_response

  """
  insert a single row into the table: "customer_orders"
  """
  insert_customer_orders_one(
    """the row to be inserted"""
    object: customer_orders_insert_input!

    """on conflict condition"""
    on_conflict: customer_orders_on_conflict
  ): customer_orders

  """
  insert data into the table: "customers"
  """
  insert_customers(
    """the rows to be inserted"""
    objects: [customers_insert_input!]!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  """
  insert a single row into the table: "customers"
  """
  insert_customers_one(
    """the row to be inserted"""
    object: customers_insert_input!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers

  """
  insert data into the table: "drama_workshop_groups"
  """
  insert_drama_workshop_groups(
    """the rows to be inserted"""
    objects: [drama_workshop_groups_insert_input!]!

    """on conflict condition"""
    on_conflict: drama_workshop_groups_on_conflict
  ): drama_workshop_groups_mutation_response

  """
  insert a single row into the table: "drama_workshop_groups"
  """
  insert_drama_workshop_groups_one(
    """the row to be inserted"""
    object: drama_workshop_groups_insert_input!

    """on conflict condition"""
    on_conflict: drama_workshop_groups_on_conflict
  ): drama_workshop_groups

  """
  insert data into the table: "invoice_items"
  """
  insert_invoice_items(
    """the rows to be inserted"""
    objects: [invoice_items_insert_input!]!

    """on conflict condition"""
    on_conflict: invoice_items_on_conflict
  ): invoice_items_mutation_response

  """
  insert a single row into the table: "invoice_items"
  """
  insert_invoice_items_one(
    """the row to be inserted"""
    object: invoice_items_insert_input!

    """on conflict condition"""
    on_conflict: invoice_items_on_conflict
  ): invoice_items

  """
  insert data into the table: "invoices"
  """
  insert_invoices(
    """the rows to be inserted"""
    objects: [invoices_insert_input!]!

    """on conflict condition"""
    on_conflict: invoices_on_conflict
  ): invoices_mutation_response

  """
  insert a single row into the table: "invoices"
  """
  insert_invoices_one(
    """the row to be inserted"""
    object: invoices_insert_input!

    """on conflict condition"""
    on_conflict: invoices_on_conflict
  ): invoices

  """
  insert data into the table: "marketing_regions"
  """
  insert_marketing_regions(
    """the rows to be inserted"""
    objects: [marketing_regions_insert_input!]!

    """on conflict condition"""
    on_conflict: marketing_regions_on_conflict
  ): marketing_regions_mutation_response

  """
  insert a single row into the table: "marketing_regions"
  """
  insert_marketing_regions_one(
    """the row to be inserted"""
    object: marketing_regions_insert_input!

    """on conflict condition"""
    on_conflict: marketing_regions_on_conflict
  ): marketing_regions

  """
  insert data into the table: "order_items"
  """
  insert_order_items(
    """the rows to be inserted"""
    objects: [order_items_insert_input!]!

    """on conflict condition"""
    on_conflict: order_items_on_conflict
  ): order_items_mutation_response

  """
  insert a single row into the table: "order_items"
  """
  insert_order_items_one(
    """the row to be inserted"""
    object: order_items_insert_input!

    """on conflict condition"""
    on_conflict: order_items_on_conflict
  ): order_items

  """
  insert data into the table: "performers"
  """
  insert_performers(
    """the rows to be inserted"""
    objects: [performers_insert_input!]!

    """on conflict condition"""
    on_conflict: performers_on_conflict
  ): performers_mutation_response

  """
  insert data into the table: "performers_in_bookings"
  """
  insert_performers_in_bookings(
    """the rows to be inserted"""
    objects: [performers_in_bookings_insert_input!]!

    """on conflict condition"""
    on_conflict: performers_in_bookings_on_conflict
  ): performers_in_bookings_mutation_response

  """
  insert a single row into the table: "performers_in_bookings"
  """
  insert_performers_in_bookings_one(
    """the row to be inserted"""
    object: performers_in_bookings_insert_input!

    """on conflict condition"""
    on_conflict: performers_in_bookings_on_conflict
  ): performers_in_bookings

  """
  insert a single row into the table: "performers"
  """
  insert_performers_one(
    """the row to be inserted"""
    object: performers_insert_input!

    """on conflict condition"""
    on_conflict: performers_on_conflict
  ): performers

  """
  insert data into the table: "products"
  """
  insert_products(
    """the rows to be inserted"""
    objects: [products_insert_input!]!

    """on conflict condition"""
    on_conflict: products_on_conflict
  ): products_mutation_response

  """
  insert a single row into the table: "products"
  """
  insert_products_one(
    """the row to be inserted"""
    object: products_insert_input!

    """on conflict condition"""
    on_conflict: products_on_conflict
  ): products

  """
  insert data into the table: "ref_payment_methods"
  """
  insert_ref_payment_methods(
    """the rows to be inserted"""
    objects: [ref_payment_methods_insert_input!]!

    """on conflict condition"""
    on_conflict: ref_payment_methods_on_conflict
  ): ref_payment_methods_mutation_response

  """
  insert a single row into the table: "ref_payment_methods"
  """
  insert_ref_payment_methods_one(
    """the row to be inserted"""
    object: ref_payment_methods_insert_input!

    """on conflict condition"""
    on_conflict: ref_payment_methods_on_conflict
  ): ref_payment_methods

  """
  insert data into the table: "ref_service_types"
  """
  insert_ref_service_types(
    """the rows to be inserted"""
    objects: [ref_service_types_insert_input!]!

    """on conflict condition"""
    on_conflict: ref_service_types_on_conflict
  ): ref_service_types_mutation_response

  """
  insert a single row into the table: "ref_service_types"
  """
  insert_ref_service_types_one(
    """the row to be inserted"""
    object: ref_service_types_insert_input!

    """on conflict condition"""
    on_conflict: ref_service_types_on_conflict
  ): ref_service_types

  """
  insert data into the table: "services"
  """
  insert_services(
    """the rows to be inserted"""
    objects: [services_insert_input!]!

    """on conflict condition"""
    on_conflict: services_on_conflict
  ): services_mutation_response

  """
  insert a single row into the table: "services"
  """
  insert_services_one(
    """the row to be inserted"""
    object: services_insert_input!

    """on conflict condition"""
    on_conflict: services_on_conflict
  ): services

  """
  insert data into the table: "stores"
  """
  insert_stores(
    """the rows to be inserted"""
    objects: [stores_insert_input!]!

    """on conflict condition"""
    on_conflict: stores_on_conflict
  ): stores_mutation_response

  """
  insert a single row into the table: "stores"
  """
  insert_stores_one(
    """the row to be inserted"""
    object: stores_insert_input!

    """on conflict condition"""
    on_conflict: stores_on_conflict
  ): stores

  """
  update data of the table: "addresses"
  """
  update_addresses(
    """sets the columns of the filtered rows to the given values"""
    _set: addresses_set_input

    """filter the rows which have to be updated"""
    where: addresses_bool_exp!
  ): addresses_mutation_response

  """
  update data of the table: "bookings"
  """
  update_bookings(
    """increments the integer columns with given value of the filtered values"""
    _inc: bookings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_set_input

    """filter the rows which have to be updated"""
    where: bookings_bool_exp!
  ): bookings_mutation_response

  """
  update single row of the table: "bookings"
  """
  update_bookings_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: bookings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_set_input
    pk_columns: bookings_pk_columns_input!
  ): bookings

  """
  update data of the table: "bookings_services"
  """
  update_bookings_services(
    """increments the integer columns with given value of the filtered values"""
    _inc: bookings_services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_services_set_input

    """filter the rows which have to be updated"""
    where: bookings_services_bool_exp!
  ): bookings_services_mutation_response

  """
  update single row of the table: "bookings_services"
  """
  update_bookings_services_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: bookings_services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookings_services_set_input
    pk_columns: bookings_services_pk_columns_input!
  ): bookings_services

  """
  update data of the table: "clients"
  """
  update_clients(
    """increments the integer columns with given value of the filtered values"""
    _inc: clients_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input

    """filter the rows which have to be updated"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  update single row of the table: "clients"
  """
  update_clients_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: clients_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input
    pk_columns: clients_pk_columns_input!
  ): clients

  """
  update data of the table: "customer_orders"
  """
  update_customer_orders(
    """increments the integer columns with given value of the filtered values"""
    _inc: customer_orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_orders_set_input

    """filter the rows which have to be updated"""
    where: customer_orders_bool_exp!
  ): customer_orders_mutation_response

  """
  update single row of the table: "customer_orders"
  """
  update_customer_orders_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: customer_orders_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_orders_set_input
    pk_columns: customer_orders_pk_columns_input!
  ): customer_orders

  """
  update data of the table: "customers"
  """
  update_customers(
    """increments the integer columns with given value of the filtered values"""
    _inc: customers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input

    """filter the rows which have to be updated"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  update data of the table: "drama_workshop_groups"
  """
  update_drama_workshop_groups(
    """increments the integer columns with given value of the filtered values"""
    _inc: drama_workshop_groups_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: drama_workshop_groups_set_input

    """filter the rows which have to be updated"""
    where: drama_workshop_groups_bool_exp!
  ): drama_workshop_groups_mutation_response

  """
  update single row of the table: "drama_workshop_groups"
  """
  update_drama_workshop_groups_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: drama_workshop_groups_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: drama_workshop_groups_set_input
    pk_columns: drama_workshop_groups_pk_columns_input!
  ): drama_workshop_groups

  """
  update data of the table: "invoice_items"
  """
  update_invoice_items(
    """increments the integer columns with given value of the filtered values"""
    _inc: invoice_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: invoice_items_set_input

    """filter the rows which have to be updated"""
    where: invoice_items_bool_exp!
  ): invoice_items_mutation_response

  """
  update single row of the table: "invoice_items"
  """
  update_invoice_items_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: invoice_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: invoice_items_set_input
    pk_columns: invoice_items_pk_columns_input!
  ): invoice_items

  """
  update data of the table: "invoices"
  """
  update_invoices(
    """increments the integer columns with given value of the filtered values"""
    _inc: invoices_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: invoices_set_input

    """filter the rows which have to be updated"""
    where: invoices_bool_exp!
  ): invoices_mutation_response

  """
  update single row of the table: "invoices"
  """
  update_invoices_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: invoices_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: invoices_set_input
    pk_columns: invoices_pk_columns_input!
  ): invoices

  """
  update data of the table: "marketing_regions"
  """
  update_marketing_regions(
    """sets the columns of the filtered rows to the given values"""
    _set: marketing_regions_set_input

    """filter the rows which have to be updated"""
    where: marketing_regions_bool_exp!
  ): marketing_regions_mutation_response

  """
  update data of the table: "order_items"
  """
  update_order_items(
    """increments the integer columns with given value of the filtered values"""
    _inc: order_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_items_set_input

    """filter the rows which have to be updated"""
    where: order_items_bool_exp!
  ): order_items_mutation_response

  """
  update single row of the table: "order_items"
  """
  update_order_items_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: order_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_items_set_input
    pk_columns: order_items_pk_columns_input!
  ): order_items

  """
  update data of the table: "performers"
  """
  update_performers(
    """increments the integer columns with given value of the filtered values"""
    _inc: performers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: performers_set_input

    """filter the rows which have to be updated"""
    where: performers_bool_exp!
  ): performers_mutation_response

  """
  update single row of the table: "performers"
  """
  update_performers_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: performers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: performers_set_input
    pk_columns: performers_pk_columns_input!
  ): performers

  """
  update data of the table: "performers_in_bookings"
  """
  update_performers_in_bookings(
    """increments the integer columns with given value of the filtered values"""
    _inc: performers_in_bookings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: performers_in_bookings_set_input

    """filter the rows which have to be updated"""
    where: performers_in_bookings_bool_exp!
  ): performers_in_bookings_mutation_response

  """
  update single row of the table: "performers_in_bookings"
  """
  update_performers_in_bookings_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: performers_in_bookings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: performers_in_bookings_set_input
    pk_columns: performers_in_bookings_pk_columns_input!
  ): performers_in_bookings

  """
  update data of the table: "products"
  """
  update_products(
    """increments the integer columns with given value of the filtered values"""
    _inc: products_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input

    """filter the rows which have to be updated"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  update data of the table: "ref_payment_methods"
  """
  update_ref_payment_methods(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_payment_methods_set_input

    """filter the rows which have to be updated"""
    where: ref_payment_methods_bool_exp!
  ): ref_payment_methods_mutation_response

  """
  update single row of the table: "ref_payment_methods"
  """
  update_ref_payment_methods_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_payment_methods_set_input
    pk_columns: ref_payment_methods_pk_columns_input!
  ): ref_payment_methods

  """
  update data of the table: "ref_service_types"
  """
  update_ref_service_types(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_service_types_set_input

    """filter the rows which have to be updated"""
    where: ref_service_types_bool_exp!
  ): ref_service_types_mutation_response

  """
  update data of the table: "services"
  """
  update_services(
    """increments the integer columns with given value of the filtered values"""
    _inc: services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input

    """filter the rows which have to be updated"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  update single row of the table: "services"
  """
  update_services_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input
    pk_columns: services_pk_columns_input!
  ): services

  """
  update data of the table: "stores"
  """
  update_stores(
    """increments the integer columns with given value of the filtered values"""
    _inc: stores_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stores_set_input

    """filter the rows which have to be updated"""
    where: stores_bool_exp!
  ): stores_mutation_response
}

scalar numeric

"""
expression to compare columns of type numeric. All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "order_items"
"""
type order_items {
  """An object relationship"""
  customer_order: customer_orders

  """An array relationship"""
  invoice_items(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): [invoice_items!]!

  """An aggregated array relationship"""
  invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): invoice_items_aggregate!
  order_id: bigint
  order_item_id: bigint!
  order_quantity: String
  other_item_details: String
  product_id: bigint
}

"""
aggregated selection of "order_items"
"""
type order_items_aggregate {
  aggregate: order_items_aggregate_fields
  nodes: [order_items!]!
}

"""
aggregate fields of "order_items"
"""
type order_items_aggregate_fields {
  avg: order_items_avg_fields
  count(columns: [order_items_select_column!], distinct: Boolean): Int
  max: order_items_max_fields
  min: order_items_min_fields
  stddev: order_items_stddev_fields
  stddev_pop: order_items_stddev_pop_fields
  stddev_samp: order_items_stddev_samp_fields
  sum: order_items_sum_fields
  var_pop: order_items_var_pop_fields
  var_samp: order_items_var_samp_fields
  variance: order_items_variance_fields
}

"""
order by aggregate values of table "order_items"
"""
input order_items_aggregate_order_by {
  avg: order_items_avg_order_by
  count: order_by
  max: order_items_max_order_by
  min: order_items_min_order_by
  stddev: order_items_stddev_order_by
  stddev_pop: order_items_stddev_pop_order_by
  stddev_samp: order_items_stddev_samp_order_by
  sum: order_items_sum_order_by
  var_pop: order_items_var_pop_order_by
  var_samp: order_items_var_samp_order_by
  variance: order_items_variance_order_by
}

"""
input type for inserting array relation for remote table "order_items"
"""
input order_items_arr_rel_insert_input {
  data: [order_items_insert_input!]!
  on_conflict: order_items_on_conflict
}

"""aggregate avg on columns"""
type order_items_avg_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by avg() on columns of table "order_items"
"""
input order_items_avg_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "order_items". All fields are combined with a logical 'AND'.
"""
input order_items_bool_exp {
  _and: [order_items_bool_exp]
  _not: order_items_bool_exp
  _or: [order_items_bool_exp]
  customer_order: customer_orders_bool_exp
  invoice_items: invoice_items_bool_exp
  order_id: bigint_comparison_exp
  order_item_id: bigint_comparison_exp
  order_quantity: String_comparison_exp
  other_item_details: String_comparison_exp
  product_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "order_items"
"""
enum order_items_constraint {
  """unique or primary key constraint"""
  idx_24018_order_items_pkey
}

"""
input type for incrementing integer column in table "order_items"
"""
input order_items_inc_input {
  order_id: bigint
  order_item_id: bigint
  product_id: bigint
}

"""
input type for inserting data into table "order_items"
"""
input order_items_insert_input {
  customer_order: customer_orders_obj_rel_insert_input
  invoice_items: invoice_items_arr_rel_insert_input
  order_id: bigint
  order_item_id: bigint
  order_quantity: String
  other_item_details: String
  product_id: bigint
}

"""aggregate max on columns"""
type order_items_max_fields {
  order_id: bigint
  order_item_id: bigint
  order_quantity: String
  other_item_details: String
  product_id: bigint
}

"""
order by max() on columns of table "order_items"
"""
input order_items_max_order_by {
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type order_items_min_fields {
  order_id: bigint
  order_item_id: bigint
  order_quantity: String
  other_item_details: String
  product_id: bigint
}

"""
order by min() on columns of table "order_items"
"""
input order_items_min_order_by {
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""
response of any mutation on the table "order_items"
"""
type order_items_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [order_items!]!
}

"""
input type for inserting object relation for remote table "order_items"
"""
input order_items_obj_rel_insert_input {
  data: order_items_insert_input!
  on_conflict: order_items_on_conflict
}

"""
on conflict condition type for table "order_items"
"""
input order_items_on_conflict {
  constraint: order_items_constraint!
  update_columns: [order_items_update_column!]!
  where: order_items_bool_exp
}

"""
ordering options when selecting data from "order_items"
"""
input order_items_order_by {
  customer_order: customer_orders_order_by
  invoice_items_aggregate: invoice_items_aggregate_order_by
  order_id: order_by
  order_item_id: order_by
  order_quantity: order_by
  other_item_details: order_by
  product_id: order_by
}

"""
primary key columns input for table: "order_items"
"""
input order_items_pk_columns_input {
  order_item_id: bigint!
}

"""
select columns of table "order_items"
"""
enum order_items_select_column {
  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  product_id
}

"""
input type for updating data in table "order_items"
"""
input order_items_set_input {
  order_id: bigint
  order_item_id: bigint
  order_quantity: String
  other_item_details: String
  product_id: bigint
}

"""aggregate stddev on columns"""
type order_items_stddev_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by stddev() on columns of table "order_items"
"""
input order_items_stddev_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type order_items_stddev_pop_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "order_items"
"""
input order_items_stddev_pop_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type order_items_stddev_samp_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "order_items"
"""
input order_items_stddev_samp_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""aggregate sum on columns"""
type order_items_sum_fields {
  order_id: bigint
  order_item_id: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "order_items"
"""
input order_items_sum_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""
update columns of table "order_items"
"""
enum order_items_update_column {
  """column name"""
  order_id

  """column name"""
  order_item_id

  """column name"""
  order_quantity

  """column name"""
  other_item_details

  """column name"""
  product_id
}

"""aggregate var_pop on columns"""
type order_items_var_pop_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "order_items"
"""
input order_items_var_pop_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type order_items_var_samp_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "order_items"
"""
input order_items_var_samp_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type order_items_variance_fields {
  order_id: Float
  order_item_id: Float
  product_id: Float
}

"""
order by variance() on columns of table "order_items"
"""
input order_items_variance_order_by {
  order_id: order_by
  order_item_id: order_by
  product_id: order_by
}

"""
columns and relationships of "performers"
"""
type performers {
  address_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
  performer_id: bigint!

  """An array relationship"""
  performers_in_bookings(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): [performers_in_bookings!]!

  """An aggregated array relationship"""
  performers_in_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): performers_in_bookings_aggregate!
}

"""
aggregated selection of "performers"
"""
type performers_aggregate {
  aggregate: performers_aggregate_fields
  nodes: [performers!]!
}

"""
aggregate fields of "performers"
"""
type performers_aggregate_fields {
  avg: performers_avg_fields
  count(columns: [performers_select_column!], distinct: Boolean): Int
  max: performers_max_fields
  min: performers_min_fields
  stddev: performers_stddev_fields
  stddev_pop: performers_stddev_pop_fields
  stddev_samp: performers_stddev_samp_fields
  sum: performers_sum_fields
  var_pop: performers_var_pop_fields
  var_samp: performers_var_samp_fields
  variance: performers_variance_fields
}

"""
order by aggregate values of table "performers"
"""
input performers_aggregate_order_by {
  avg: performers_avg_order_by
  count: order_by
  max: performers_max_order_by
  min: performers_min_order_by
  stddev: performers_stddev_order_by
  stddev_pop: performers_stddev_pop_order_by
  stddev_samp: performers_stddev_samp_order_by
  sum: performers_sum_order_by
  var_pop: performers_var_pop_order_by
  var_samp: performers_var_samp_order_by
  variance: performers_variance_order_by
}

"""
input type for inserting array relation for remote table "performers"
"""
input performers_arr_rel_insert_input {
  data: [performers_insert_input!]!
  on_conflict: performers_on_conflict
}

"""aggregate avg on columns"""
type performers_avg_fields {
  address_id: Float
  performer_id: Float
}

"""
order by avg() on columns of table "performers"
"""
input performers_avg_order_by {
  address_id: order_by
  performer_id: order_by
}

"""
Boolean expression to filter rows from the table "performers". All fields are combined with a logical 'AND'.
"""
input performers_bool_exp {
  _and: [performers_bool_exp]
  _not: performers_bool_exp
  _or: [performers_bool_exp]
  address_id: bigint_comparison_exp
  customer_email_address: String_comparison_exp
  customer_name: String_comparison_exp
  customer_phone: String_comparison_exp
  other_details: String_comparison_exp
  performer_id: bigint_comparison_exp
  performers_in_bookings: performers_in_bookings_bool_exp
}

"""
unique or primary key constraints on table "performers"
"""
enum performers_constraint {
  """unique or primary key constraint"""
  idx_23985_performers_pkey

  """unique or primary key constraint"""
  idx_23985_sqlite_autoindex_performers_1
}

"""
columns and relationships of "performers_in_bookings"
"""
type performers_in_bookings {
  """An object relationship"""
  booking: bookings!
  order_id: bigint!

  """An object relationship"""
  performer: performers!
  performer_id: bigint!
}

"""
aggregated selection of "performers_in_bookings"
"""
type performers_in_bookings_aggregate {
  aggregate: performers_in_bookings_aggregate_fields
  nodes: [performers_in_bookings!]!
}

"""
aggregate fields of "performers_in_bookings"
"""
type performers_in_bookings_aggregate_fields {
  avg: performers_in_bookings_avg_fields
  count(columns: [performers_in_bookings_select_column!], distinct: Boolean): Int
  max: performers_in_bookings_max_fields
  min: performers_in_bookings_min_fields
  stddev: performers_in_bookings_stddev_fields
  stddev_pop: performers_in_bookings_stddev_pop_fields
  stddev_samp: performers_in_bookings_stddev_samp_fields
  sum: performers_in_bookings_sum_fields
  var_pop: performers_in_bookings_var_pop_fields
  var_samp: performers_in_bookings_var_samp_fields
  variance: performers_in_bookings_variance_fields
}

"""
order by aggregate values of table "performers_in_bookings"
"""
input performers_in_bookings_aggregate_order_by {
  avg: performers_in_bookings_avg_order_by
  count: order_by
  max: performers_in_bookings_max_order_by
  min: performers_in_bookings_min_order_by
  stddev: performers_in_bookings_stddev_order_by
  stddev_pop: performers_in_bookings_stddev_pop_order_by
  stddev_samp: performers_in_bookings_stddev_samp_order_by
  sum: performers_in_bookings_sum_order_by
  var_pop: performers_in_bookings_var_pop_order_by
  var_samp: performers_in_bookings_var_samp_order_by
  variance: performers_in_bookings_variance_order_by
}

"""
input type for inserting array relation for remote table "performers_in_bookings"
"""
input performers_in_bookings_arr_rel_insert_input {
  data: [performers_in_bookings_insert_input!]!
  on_conflict: performers_in_bookings_on_conflict
}

"""aggregate avg on columns"""
type performers_in_bookings_avg_fields {
  order_id: Float
  performer_id: Float
}

"""
order by avg() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_avg_order_by {
  order_id: order_by
  performer_id: order_by
}

"""
Boolean expression to filter rows from the table "performers_in_bookings". All fields are combined with a logical 'AND'.
"""
input performers_in_bookings_bool_exp {
  _and: [performers_in_bookings_bool_exp]
  _not: performers_in_bookings_bool_exp
  _or: [performers_in_bookings_bool_exp]
  booking: bookings_bool_exp
  order_id: bigint_comparison_exp
  performer: performers_bool_exp
  performer_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "performers_in_bookings"
"""
enum performers_in_bookings_constraint {
  """unique or primary key constraint"""
  idx_24009_performers_in_bookings_pkey

  """unique or primary key constraint"""
  idx_24009_sqlite_autoindex_performers_in_bookings_1
}

"""
input type for incrementing integer column in table "performers_in_bookings"
"""
input performers_in_bookings_inc_input {
  order_id: bigint
  performer_id: bigint
}

"""
input type for inserting data into table "performers_in_bookings"
"""
input performers_in_bookings_insert_input {
  booking: bookings_obj_rel_insert_input
  order_id: bigint
  performer: performers_obj_rel_insert_input
  performer_id: bigint
}

"""aggregate max on columns"""
type performers_in_bookings_max_fields {
  order_id: bigint
  performer_id: bigint
}

"""
order by max() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_max_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate min on columns"""
type performers_in_bookings_min_fields {
  order_id: bigint
  performer_id: bigint
}

"""
order by min() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_min_order_by {
  order_id: order_by
  performer_id: order_by
}

"""
response of any mutation on the table "performers_in_bookings"
"""
type performers_in_bookings_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [performers_in_bookings!]!
}

"""
input type for inserting object relation for remote table "performers_in_bookings"
"""
input performers_in_bookings_obj_rel_insert_input {
  data: performers_in_bookings_insert_input!
  on_conflict: performers_in_bookings_on_conflict
}

"""
on conflict condition type for table "performers_in_bookings"
"""
input performers_in_bookings_on_conflict {
  constraint: performers_in_bookings_constraint!
  update_columns: [performers_in_bookings_update_column!]!
  where: performers_in_bookings_bool_exp
}

"""
ordering options when selecting data from "performers_in_bookings"
"""
input performers_in_bookings_order_by {
  booking: bookings_order_by
  order_id: order_by
  performer: performers_order_by
  performer_id: order_by
}

"""
primary key columns input for table: "performers_in_bookings"
"""
input performers_in_bookings_pk_columns_input {
  order_id: bigint!
  performer_id: bigint!
}

"""
select columns of table "performers_in_bookings"
"""
enum performers_in_bookings_select_column {
  """column name"""
  order_id

  """column name"""
  performer_id
}

"""
input type for updating data in table "performers_in_bookings"
"""
input performers_in_bookings_set_input {
  order_id: bigint
  performer_id: bigint
}

"""aggregate stddev on columns"""
type performers_in_bookings_stddev_fields {
  order_id: Float
  performer_id: Float
}

"""
order by stddev() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_stddev_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate stddev_pop on columns"""
type performers_in_bookings_stddev_pop_fields {
  order_id: Float
  performer_id: Float
}

"""
order by stddev_pop() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_stddev_pop_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate stddev_samp on columns"""
type performers_in_bookings_stddev_samp_fields {
  order_id: Float
  performer_id: Float
}

"""
order by stddev_samp() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_stddev_samp_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate sum on columns"""
type performers_in_bookings_sum_fields {
  order_id: bigint
  performer_id: bigint
}

"""
order by sum() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_sum_order_by {
  order_id: order_by
  performer_id: order_by
}

"""
update columns of table "performers_in_bookings"
"""
enum performers_in_bookings_update_column {
  """column name"""
  order_id

  """column name"""
  performer_id
}

"""aggregate var_pop on columns"""
type performers_in_bookings_var_pop_fields {
  order_id: Float
  performer_id: Float
}

"""
order by var_pop() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_var_pop_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate var_samp on columns"""
type performers_in_bookings_var_samp_fields {
  order_id: Float
  performer_id: Float
}

"""
order by var_samp() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_var_samp_order_by {
  order_id: order_by
  performer_id: order_by
}

"""aggregate variance on columns"""
type performers_in_bookings_variance_fields {
  order_id: Float
  performer_id: Float
}

"""
order by variance() on columns of table "performers_in_bookings"
"""
input performers_in_bookings_variance_order_by {
  order_id: order_by
  performer_id: order_by
}

"""
input type for incrementing integer column in table "performers"
"""
input performers_inc_input {
  address_id: bigint
  performer_id: bigint
}

"""
input type for inserting data into table "performers"
"""
input performers_insert_input {
  address_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
  performer_id: bigint
  performers_in_bookings: performers_in_bookings_arr_rel_insert_input
}

"""aggregate max on columns"""
type performers_max_fields {
  address_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
  performer_id: bigint
}

"""
order by max() on columns of table "performers"
"""
input performers_max_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
  performer_id: order_by
}

"""aggregate min on columns"""
type performers_min_fields {
  address_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
  performer_id: bigint
}

"""
order by min() on columns of table "performers"
"""
input performers_min_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
  performer_id: order_by
}

"""
response of any mutation on the table "performers"
"""
type performers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [performers!]!
}

"""
input type for inserting object relation for remote table "performers"
"""
input performers_obj_rel_insert_input {
  data: performers_insert_input!
  on_conflict: performers_on_conflict
}

"""
on conflict condition type for table "performers"
"""
input performers_on_conflict {
  constraint: performers_constraint!
  update_columns: [performers_update_column!]!
  where: performers_bool_exp
}

"""
ordering options when selecting data from "performers"
"""
input performers_order_by {
  address_id: order_by
  customer_email_address: order_by
  customer_name: order_by
  customer_phone: order_by
  other_details: order_by
  performer_id: order_by
  performers_in_bookings_aggregate: performers_in_bookings_aggregate_order_by
}

"""
primary key columns input for table: "performers"
"""
input performers_pk_columns_input {
  performer_id: bigint!
}

"""
select columns of table "performers"
"""
enum performers_select_column {
  """column name"""
  address_id

  """column name"""
  customer_email_address

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details

  """column name"""
  performer_id
}

"""
input type for updating data in table "performers"
"""
input performers_set_input {
  address_id: bigint
  customer_email_address: String
  customer_name: String
  customer_phone: String
  other_details: String
  performer_id: bigint
}

"""aggregate stddev on columns"""
type performers_stddev_fields {
  address_id: Float
  performer_id: Float
}

"""
order by stddev() on columns of table "performers"
"""
input performers_stddev_order_by {
  address_id: order_by
  performer_id: order_by
}

"""aggregate stddev_pop on columns"""
type performers_stddev_pop_fields {
  address_id: Float
  performer_id: Float
}

"""
order by stddev_pop() on columns of table "performers"
"""
input performers_stddev_pop_order_by {
  address_id: order_by
  performer_id: order_by
}

"""aggregate stddev_samp on columns"""
type performers_stddev_samp_fields {
  address_id: Float
  performer_id: Float
}

"""
order by stddev_samp() on columns of table "performers"
"""
input performers_stddev_samp_order_by {
  address_id: order_by
  performer_id: order_by
}

"""aggregate sum on columns"""
type performers_sum_fields {
  address_id: bigint
  performer_id: bigint
}

"""
order by sum() on columns of table "performers"
"""
input performers_sum_order_by {
  address_id: order_by
  performer_id: order_by
}

"""
update columns of table "performers"
"""
enum performers_update_column {
  """column name"""
  address_id

  """column name"""
  customer_email_address

  """column name"""
  customer_name

  """column name"""
  customer_phone

  """column name"""
  other_details

  """column name"""
  performer_id
}

"""aggregate var_pop on columns"""
type performers_var_pop_fields {
  address_id: Float
  performer_id: Float
}

"""
order by var_pop() on columns of table "performers"
"""
input performers_var_pop_order_by {
  address_id: order_by
  performer_id: order_by
}

"""aggregate var_samp on columns"""
type performers_var_samp_fields {
  address_id: Float
  performer_id: Float
}

"""
order by var_samp() on columns of table "performers"
"""
input performers_var_samp_order_by {
  address_id: order_by
  performer_id: order_by
}

"""aggregate variance on columns"""
type performers_variance_fields {
  address_id: Float
  performer_id: Float
}

"""
order by variance() on columns of table "performers"
"""
input performers_variance_order_by {
  address_id: order_by
  performer_id: order_by
}

"""
columns and relationships of "products"
"""
type products {
  other_product_service_details: String
  product_description: String
  product_id: String
  product_name: String
  product_price: numeric
}

"""
aggregated selection of "products"
"""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

"""
aggregate fields of "products"
"""
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

"""
order by aggregate values of table "products"
"""
input products_aggregate_order_by {
  avg: products_avg_order_by
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
  stddev: products_stddev_order_by
  stddev_pop: products_stddev_pop_order_by
  stddev_samp: products_stddev_samp_order_by
  sum: products_sum_order_by
  var_pop: products_var_pop_order_by
  var_samp: products_var_samp_order_by
  variance: products_variance_order_by
}

"""
input type for inserting array relation for remote table "products"
"""
input products_arr_rel_insert_input {
  data: [products_insert_input!]!
  on_conflict: products_on_conflict
}

"""aggregate avg on columns"""
type products_avg_fields {
  product_price: Float
}

"""
order by avg() on columns of table "products"
"""
input products_avg_order_by {
  product_price: order_by
}

"""
Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
"""
input products_bool_exp {
  _and: [products_bool_exp]
  _not: products_bool_exp
  _or: [products_bool_exp]
  other_product_service_details: String_comparison_exp
  product_description: String_comparison_exp
  product_id: String_comparison_exp
  product_name: String_comparison_exp
  product_price: numeric_comparison_exp
}

"""
unique or primary key constraints on table "products"
"""
enum products_constraint {
  """unique or primary key constraint"""
  idx_23961_sqlite_autoindex_products_1
}

"""
input type for incrementing integer column in table "products"
"""
input products_inc_input {
  product_price: numeric
}

"""
input type for inserting data into table "products"
"""
input products_insert_input {
  other_product_service_details: String
  product_description: String
  product_id: String
  product_name: String
  product_price: numeric
}

"""aggregate max on columns"""
type products_max_fields {
  other_product_service_details: String
  product_description: String
  product_id: String
  product_name: String
  product_price: numeric
}

"""
order by max() on columns of table "products"
"""
input products_max_order_by {
  other_product_service_details: order_by
  product_description: order_by
  product_id: order_by
  product_name: order_by
  product_price: order_by
}

"""aggregate min on columns"""
type products_min_fields {
  other_product_service_details: String
  product_description: String
  product_id: String
  product_name: String
  product_price: numeric
}

"""
order by min() on columns of table "products"
"""
input products_min_order_by {
  other_product_service_details: order_by
  product_description: order_by
  product_id: order_by
  product_name: order_by
  product_price: order_by
}

"""
response of any mutation on the table "products"
"""
type products_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [products!]!
}

"""
input type for inserting object relation for remote table "products"
"""
input products_obj_rel_insert_input {
  data: products_insert_input!
  on_conflict: products_on_conflict
}

"""
on conflict condition type for table "products"
"""
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]!
  where: products_bool_exp
}

"""
ordering options when selecting data from "products"
"""
input products_order_by {
  other_product_service_details: order_by
  product_description: order_by
  product_id: order_by
  product_name: order_by
  product_price: order_by
}

"""
select columns of table "products"
"""
enum products_select_column {
  """column name"""
  other_product_service_details

  """column name"""
  product_description

  """column name"""
  product_id

  """column name"""
  product_name

  """column name"""
  product_price
}

"""
input type for updating data in table "products"
"""
input products_set_input {
  other_product_service_details: String
  product_description: String
  product_id: String
  product_name: String
  product_price: numeric
}

"""aggregate stddev on columns"""
type products_stddev_fields {
  product_price: Float
}

"""
order by stddev() on columns of table "products"
"""
input products_stddev_order_by {
  product_price: order_by
}

"""aggregate stddev_pop on columns"""
type products_stddev_pop_fields {
  product_price: Float
}

"""
order by stddev_pop() on columns of table "products"
"""
input products_stddev_pop_order_by {
  product_price: order_by
}

"""aggregate stddev_samp on columns"""
type products_stddev_samp_fields {
  product_price: Float
}

"""
order by stddev_samp() on columns of table "products"
"""
input products_stddev_samp_order_by {
  product_price: order_by
}

"""aggregate sum on columns"""
type products_sum_fields {
  product_price: numeric
}

"""
order by sum() on columns of table "products"
"""
input products_sum_order_by {
  product_price: order_by
}

"""
update columns of table "products"
"""
enum products_update_column {
  """column name"""
  other_product_service_details

  """column name"""
  product_description

  """column name"""
  product_id

  """column name"""
  product_name

  """column name"""
  product_price
}

"""aggregate var_pop on columns"""
type products_var_pop_fields {
  product_price: Float
}

"""
order by var_pop() on columns of table "products"
"""
input products_var_pop_order_by {
  product_price: order_by
}

"""aggregate var_samp on columns"""
type products_var_samp_fields {
  product_price: Float
}

"""
order by var_samp() on columns of table "products"
"""
input products_var_samp_order_by {
  product_price: order_by
}

"""aggregate variance on columns"""
type products_variance_fields {
  product_price: Float
}

"""
order by variance() on columns of table "products"
"""
input products_variance_order_by {
  product_price: order_by
}

"""query root"""
type query_root {
  """
  fetch data from the table: "addresses"
  """
  addresses(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """
  fetch aggregated fields from the table: "addresses"
  """
  addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): addresses_aggregate!

  """
  fetch data from the table: "bookings"
  """
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """
  fetch aggregated fields from the table: "bookings"
  """
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!

  """fetch data from the table: "bookings" using primary key columns"""
  bookings_by_pk(booking_id: bigint!): bookings

  """
  fetch data from the table: "bookings_services"
  """
  bookings_services(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): [bookings_services!]!

  """
  fetch aggregated fields from the table: "bookings_services"
  """
  bookings_services_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): bookings_services_aggregate!

  """
  fetch data from the table: "bookings_services" using primary key columns
  """
  bookings_services_by_pk(order_id: bigint!, product_id: bigint!): bookings_services

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(client_id: bigint!): clients

  """
  fetch data from the table: "customer_orders"
  """
  customer_orders(
    """distinct select on columns"""
    distinct_on: [customer_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_orders_order_by!]

    """filter the rows returned"""
    where: customer_orders_bool_exp
  ): [customer_orders!]!

  """
  fetch aggregated fields from the table: "customer_orders"
  """
  customer_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_orders_order_by!]

    """filter the rows returned"""
    where: customer_orders_bool_exp
  ): customer_orders_aggregate!

  """fetch data from the table: "customer_orders" using primary key columns"""
  customer_orders_by_pk(order_id: bigint!): customer_orders

  """
  fetch data from the table: "customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """
  fetch data from the table: "drama_workshop_groups"
  """
  drama_workshop_groups(
    """distinct select on columns"""
    distinct_on: [drama_workshop_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drama_workshop_groups_order_by!]

    """filter the rows returned"""
    where: drama_workshop_groups_bool_exp
  ): [drama_workshop_groups!]!

  """
  fetch aggregated fields from the table: "drama_workshop_groups"
  """
  drama_workshop_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [drama_workshop_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drama_workshop_groups_order_by!]

    """filter the rows returned"""
    where: drama_workshop_groups_bool_exp
  ): drama_workshop_groups_aggregate!

  """
  fetch data from the table: "drama_workshop_groups" using primary key columns
  """
  drama_workshop_groups_by_pk(workshop_group_id: bigint!): drama_workshop_groups

  """
  fetch data from the table: "invoice_items"
  """
  invoice_items(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): [invoice_items!]!

  """
  fetch aggregated fields from the table: "invoice_items"
  """
  invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): invoice_items_aggregate!

  """fetch data from the table: "invoice_items" using primary key columns"""
  invoice_items_by_pk(invoice_item_id: bigint!): invoice_items

  """
  fetch data from the table: "invoices"
  """
  invoices(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): [invoices!]!

  """
  fetch aggregated fields from the table: "invoices"
  """
  invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): invoices_aggregate!

  """fetch data from the table: "invoices" using primary key columns"""
  invoices_by_pk(invoice_id: bigint!): invoices

  """
  fetch data from the table: "marketing_regions"
  """
  marketing_regions(
    """distinct select on columns"""
    distinct_on: [marketing_regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketing_regions_order_by!]

    """filter the rows returned"""
    where: marketing_regions_bool_exp
  ): [marketing_regions!]!

  """
  fetch aggregated fields from the table: "marketing_regions"
  """
  marketing_regions_aggregate(
    """distinct select on columns"""
    distinct_on: [marketing_regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketing_regions_order_by!]

    """filter the rows returned"""
    where: marketing_regions_bool_exp
  ): marketing_regions_aggregate!

  """
  fetch data from the table: "order_items"
  """
  order_items(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """
  fetch aggregated fields from the table: "order_items"
  """
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): order_items_aggregate!

  """fetch data from the table: "order_items" using primary key columns"""
  order_items_by_pk(order_item_id: bigint!): order_items

  """
  fetch data from the table: "performers"
  """
  performers(
    """distinct select on columns"""
    distinct_on: [performers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_order_by!]

    """filter the rows returned"""
    where: performers_bool_exp
  ): [performers!]!

  """
  fetch aggregated fields from the table: "performers"
  """
  performers_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_order_by!]

    """filter the rows returned"""
    where: performers_bool_exp
  ): performers_aggregate!

  """fetch data from the table: "performers" using primary key columns"""
  performers_by_pk(performer_id: bigint!): performers

  """
  fetch data from the table: "performers_in_bookings"
  """
  performers_in_bookings(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): [performers_in_bookings!]!

  """
  fetch aggregated fields from the table: "performers_in_bookings"
  """
  performers_in_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): performers_in_bookings_aggregate!

  """
  fetch data from the table: "performers_in_bookings" using primary key columns
  """
  performers_in_bookings_by_pk(order_id: bigint!, performer_id: bigint!): performers_in_bookings

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """
  fetch data from the table: "ref_payment_methods"
  """
  ref_payment_methods(
    """distinct select on columns"""
    distinct_on: [ref_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_payment_methods_order_by!]

    """filter the rows returned"""
    where: ref_payment_methods_bool_exp
  ): [ref_payment_methods!]!

  """
  fetch aggregated fields from the table: "ref_payment_methods"
  """
  ref_payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_payment_methods_order_by!]

    """filter the rows returned"""
    where: ref_payment_methods_bool_exp
  ): ref_payment_methods_aggregate!

  """
  fetch data from the table: "ref_payment_methods" using primary key columns
  """
  ref_payment_methods_by_pk(payment_method_code: String!): ref_payment_methods

  """
  fetch data from the table: "ref_service_types"
  """
  ref_service_types(
    """distinct select on columns"""
    distinct_on: [ref_service_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_service_types_order_by!]

    """filter the rows returned"""
    where: ref_service_types_bool_exp
  ): [ref_service_types!]!

  """
  fetch aggregated fields from the table: "ref_service_types"
  """
  ref_service_types_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_service_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_service_types_order_by!]

    """filter the rows returned"""
    where: ref_service_types_bool_exp
  ): ref_service_types_aggregate!

  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch aggregated fields from the table: "services"
  """
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(service_id: bigint!): services

  """
  fetch data from the table: "stores"
  """
  stores(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """
  fetch aggregated fields from the table: "stores"
  """
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): stores_aggregate!
}

"""
columns and relationships of "ref_payment_methods"
"""
type ref_payment_methods {
  """An array relationship"""
  invoices(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): [invoices!]!

  """An aggregated array relationship"""
  invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): invoices_aggregate!
  payment_method_code: String!
  payment_method_description: String
}

"""
aggregated selection of "ref_payment_methods"
"""
type ref_payment_methods_aggregate {
  aggregate: ref_payment_methods_aggregate_fields
  nodes: [ref_payment_methods!]!
}

"""
aggregate fields of "ref_payment_methods"
"""
type ref_payment_methods_aggregate_fields {
  count(columns: [ref_payment_methods_select_column!], distinct: Boolean): Int
  max: ref_payment_methods_max_fields
  min: ref_payment_methods_min_fields
}

"""
order by aggregate values of table "ref_payment_methods"
"""
input ref_payment_methods_aggregate_order_by {
  count: order_by
  max: ref_payment_methods_max_order_by
  min: ref_payment_methods_min_order_by
}

"""
input type for inserting array relation for remote table "ref_payment_methods"
"""
input ref_payment_methods_arr_rel_insert_input {
  data: [ref_payment_methods_insert_input!]!
  on_conflict: ref_payment_methods_on_conflict
}

"""
Boolean expression to filter rows from the table "ref_payment_methods". All fields are combined with a logical 'AND'.
"""
input ref_payment_methods_bool_exp {
  _and: [ref_payment_methods_bool_exp]
  _not: ref_payment_methods_bool_exp
  _or: [ref_payment_methods_bool_exp]
  invoices: invoices_bool_exp
  payment_method_code: String_comparison_exp
  payment_method_description: String_comparison_exp
}

"""
unique or primary key constraints on table "ref_payment_methods"
"""
enum ref_payment_methods_constraint {
  """unique or primary key constraint"""
  idx_23943_sqlite_autoindex_ref_payment_methods_1
}

"""
input type for inserting data into table "ref_payment_methods"
"""
input ref_payment_methods_insert_input {
  invoices: invoices_arr_rel_insert_input
  payment_method_code: String
  payment_method_description: String
}

"""aggregate max on columns"""
type ref_payment_methods_max_fields {
  payment_method_code: String
  payment_method_description: String
}

"""
order by max() on columns of table "ref_payment_methods"
"""
input ref_payment_methods_max_order_by {
  payment_method_code: order_by
  payment_method_description: order_by
}

"""aggregate min on columns"""
type ref_payment_methods_min_fields {
  payment_method_code: String
  payment_method_description: String
}

"""
order by min() on columns of table "ref_payment_methods"
"""
input ref_payment_methods_min_order_by {
  payment_method_code: order_by
  payment_method_description: order_by
}

"""
response of any mutation on the table "ref_payment_methods"
"""
type ref_payment_methods_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [ref_payment_methods!]!
}

"""
input type for inserting object relation for remote table "ref_payment_methods"
"""
input ref_payment_methods_obj_rel_insert_input {
  data: ref_payment_methods_insert_input!
  on_conflict: ref_payment_methods_on_conflict
}

"""
on conflict condition type for table "ref_payment_methods"
"""
input ref_payment_methods_on_conflict {
  constraint: ref_payment_methods_constraint!
  update_columns: [ref_payment_methods_update_column!]!
  where: ref_payment_methods_bool_exp
}

"""
ordering options when selecting data from "ref_payment_methods"
"""
input ref_payment_methods_order_by {
  invoices_aggregate: invoices_aggregate_order_by
  payment_method_code: order_by
  payment_method_description: order_by
}

"""
primary key columns input for table: "ref_payment_methods"
"""
input ref_payment_methods_pk_columns_input {
  payment_method_code: String!
}

"""
select columns of table "ref_payment_methods"
"""
enum ref_payment_methods_select_column {
  """column name"""
  payment_method_code

  """column name"""
  payment_method_description
}

"""
input type for updating data in table "ref_payment_methods"
"""
input ref_payment_methods_set_input {
  payment_method_code: String
  payment_method_description: String
}

"""
update columns of table "ref_payment_methods"
"""
enum ref_payment_methods_update_column {
  """column name"""
  payment_method_code

  """column name"""
  payment_method_description
}

"""
columns and relationships of "ref_service_types"
"""
type ref_service_types {
  parent_service_type_code: String
  service_type_code: String
  service_type_description: String

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregated array relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
}

"""
aggregated selection of "ref_service_types"
"""
type ref_service_types_aggregate {
  aggregate: ref_service_types_aggregate_fields
  nodes: [ref_service_types!]!
}

"""
aggregate fields of "ref_service_types"
"""
type ref_service_types_aggregate_fields {
  count(columns: [ref_service_types_select_column!], distinct: Boolean): Int
  max: ref_service_types_max_fields
  min: ref_service_types_min_fields
}

"""
order by aggregate values of table "ref_service_types"
"""
input ref_service_types_aggregate_order_by {
  count: order_by
  max: ref_service_types_max_order_by
  min: ref_service_types_min_order_by
}

"""
input type for inserting array relation for remote table "ref_service_types"
"""
input ref_service_types_arr_rel_insert_input {
  data: [ref_service_types_insert_input!]!
  on_conflict: ref_service_types_on_conflict
}

"""
Boolean expression to filter rows from the table "ref_service_types". All fields are combined with a logical 'AND'.
"""
input ref_service_types_bool_exp {
  _and: [ref_service_types_bool_exp]
  _not: ref_service_types_bool_exp
  _or: [ref_service_types_bool_exp]
  parent_service_type_code: String_comparison_exp
  service_type_code: String_comparison_exp
  service_type_description: String_comparison_exp
  services: services_bool_exp
}

"""
unique or primary key constraints on table "ref_service_types"
"""
enum ref_service_types_constraint {
  """unique or primary key constraint"""
  idx_23949_sqlite_autoindex_ref_service_types_1
}

"""
input type for inserting data into table "ref_service_types"
"""
input ref_service_types_insert_input {
  parent_service_type_code: String
  service_type_code: String
  service_type_description: String
  services: services_arr_rel_insert_input
}

"""aggregate max on columns"""
type ref_service_types_max_fields {
  parent_service_type_code: String
  service_type_code: String
  service_type_description: String
}

"""
order by max() on columns of table "ref_service_types"
"""
input ref_service_types_max_order_by {
  parent_service_type_code: order_by
  service_type_code: order_by
  service_type_description: order_by
}

"""aggregate min on columns"""
type ref_service_types_min_fields {
  parent_service_type_code: String
  service_type_code: String
  service_type_description: String
}

"""
order by min() on columns of table "ref_service_types"
"""
input ref_service_types_min_order_by {
  parent_service_type_code: order_by
  service_type_code: order_by
  service_type_description: order_by
}

"""
response of any mutation on the table "ref_service_types"
"""
type ref_service_types_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [ref_service_types!]!
}

"""
input type for inserting object relation for remote table "ref_service_types"
"""
input ref_service_types_obj_rel_insert_input {
  data: ref_service_types_insert_input!
  on_conflict: ref_service_types_on_conflict
}

"""
on conflict condition type for table "ref_service_types"
"""
input ref_service_types_on_conflict {
  constraint: ref_service_types_constraint!
  update_columns: [ref_service_types_update_column!]!
  where: ref_service_types_bool_exp
}

"""
ordering options when selecting data from "ref_service_types"
"""
input ref_service_types_order_by {
  parent_service_type_code: order_by
  service_type_code: order_by
  service_type_description: order_by
  services_aggregate: services_aggregate_order_by
}

"""
select columns of table "ref_service_types"
"""
enum ref_service_types_select_column {
  """column name"""
  parent_service_type_code

  """column name"""
  service_type_code

  """column name"""
  service_type_description
}

"""
input type for updating data in table "ref_service_types"
"""
input ref_service_types_set_input {
  parent_service_type_code: String
  service_type_code: String
  service_type_description: String
}

"""
update columns of table "ref_service_types"
"""
enum ref_service_types_update_column {
  """column name"""
  parent_service_type_code

  """column name"""
  service_type_code

  """column name"""
  service_type_description
}

"""
columns and relationships of "services"
"""
type services {
  """An array relationship"""
  bookings_services(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): [bookings_services!]!

  """An aggregated array relationship"""
  bookings_services_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): bookings_services_aggregate!

  """An object relationship"""
  drama_workshop_group: drama_workshop_groups
  other_product_service_details: String
  product_description: String
  product_name: String
  product_price: numeric

  """An object relationship"""
  ref_service_type: ref_service_types
  service_id: bigint!
  service_type_code: String
  workshop_group_id: bigint
}

"""
aggregated selection of "services"
"""
type services_aggregate {
  aggregate: services_aggregate_fields
  nodes: [services!]!
}

"""
aggregate fields of "services"
"""
type services_aggregate_fields {
  avg: services_avg_fields
  count(columns: [services_select_column!], distinct: Boolean): Int
  max: services_max_fields
  min: services_min_fields
  stddev: services_stddev_fields
  stddev_pop: services_stddev_pop_fields
  stddev_samp: services_stddev_samp_fields
  sum: services_sum_fields
  var_pop: services_var_pop_fields
  var_samp: services_var_samp_fields
  variance: services_variance_fields
}

"""
order by aggregate values of table "services"
"""
input services_aggregate_order_by {
  avg: services_avg_order_by
  count: order_by
  max: services_max_order_by
  min: services_min_order_by
  stddev: services_stddev_order_by
  stddev_pop: services_stddev_pop_order_by
  stddev_samp: services_stddev_samp_order_by
  sum: services_sum_order_by
  var_pop: services_var_pop_order_by
  var_samp: services_var_samp_order_by
  variance: services_variance_order_by
}

"""
input type for inserting array relation for remote table "services"
"""
input services_arr_rel_insert_input {
  data: [services_insert_input!]!
  on_conflict: services_on_conflict
}

"""aggregate avg on columns"""
type services_avg_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by avg() on columns of table "services"
"""
input services_avg_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input services_bool_exp {
  _and: [services_bool_exp]
  _not: services_bool_exp
  _or: [services_bool_exp]
  bookings_services: bookings_services_bool_exp
  drama_workshop_group: drama_workshop_groups_bool_exp
  other_product_service_details: String_comparison_exp
  product_description: String_comparison_exp
  product_name: String_comparison_exp
  product_price: numeric_comparison_exp
  ref_service_type: ref_service_types_bool_exp
  service_id: bigint_comparison_exp
  service_type_code: String_comparison_exp
  workshop_group_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "services"
"""
enum services_constraint {
  """unique or primary key constraint"""
  idx_24030_services_pkey

  """unique or primary key constraint"""
  idx_24030_sqlite_autoindex_services_1
}

"""
input type for incrementing integer column in table "services"
"""
input services_inc_input {
  product_price: numeric
  service_id: bigint
  workshop_group_id: bigint
}

"""
input type for inserting data into table "services"
"""
input services_insert_input {
  bookings_services: bookings_services_arr_rel_insert_input
  drama_workshop_group: drama_workshop_groups_obj_rel_insert_input
  other_product_service_details: String
  product_description: String
  product_name: String
  product_price: numeric
  ref_service_type: ref_service_types_obj_rel_insert_input
  service_id: bigint
  service_type_code: String
  workshop_group_id: bigint
}

"""aggregate max on columns"""
type services_max_fields {
  other_product_service_details: String
  product_description: String
  product_name: String
  product_price: numeric
  service_id: bigint
  service_type_code: String
  workshop_group_id: bigint
}

"""
order by max() on columns of table "services"
"""
input services_max_order_by {
  other_product_service_details: order_by
  product_description: order_by
  product_name: order_by
  product_price: order_by
  service_id: order_by
  service_type_code: order_by
  workshop_group_id: order_by
}

"""aggregate min on columns"""
type services_min_fields {
  other_product_service_details: String
  product_description: String
  product_name: String
  product_price: numeric
  service_id: bigint
  service_type_code: String
  workshop_group_id: bigint
}

"""
order by min() on columns of table "services"
"""
input services_min_order_by {
  other_product_service_details: order_by
  product_description: order_by
  product_name: order_by
  product_price: order_by
  service_id: order_by
  service_type_code: order_by
  workshop_group_id: order_by
}

"""
response of any mutation on the table "services"
"""
type services_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input services_obj_rel_insert_input {
  data: services_insert_input!
  on_conflict: services_on_conflict
}

"""
on conflict condition type for table "services"
"""
input services_on_conflict {
  constraint: services_constraint!
  update_columns: [services_update_column!]!
  where: services_bool_exp
}

"""
ordering options when selecting data from "services"
"""
input services_order_by {
  bookings_services_aggregate: bookings_services_aggregate_order_by
  drama_workshop_group: drama_workshop_groups_order_by
  other_product_service_details: order_by
  product_description: order_by
  product_name: order_by
  product_price: order_by
  ref_service_type: ref_service_types_order_by
  service_id: order_by
  service_type_code: order_by
  workshop_group_id: order_by
}

"""
primary key columns input for table: "services"
"""
input services_pk_columns_input {
  service_id: bigint!
}

"""
select columns of table "services"
"""
enum services_select_column {
  """column name"""
  other_product_service_details

  """column name"""
  product_description

  """column name"""
  product_name

  """column name"""
  product_price

  """column name"""
  service_id

  """column name"""
  service_type_code

  """column name"""
  workshop_group_id
}

"""
input type for updating data in table "services"
"""
input services_set_input {
  other_product_service_details: String
  product_description: String
  product_name: String
  product_price: numeric
  service_id: bigint
  service_type_code: String
  workshop_group_id: bigint
}

"""aggregate stddev on columns"""
type services_stddev_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by stddev() on columns of table "services"
"""
input services_stddev_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""aggregate stddev_pop on columns"""
type services_stddev_pop_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by stddev_pop() on columns of table "services"
"""
input services_stddev_pop_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""aggregate stddev_samp on columns"""
type services_stddev_samp_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by stddev_samp() on columns of table "services"
"""
input services_stddev_samp_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""aggregate sum on columns"""
type services_sum_fields {
  product_price: numeric
  service_id: bigint
  workshop_group_id: bigint
}

"""
order by sum() on columns of table "services"
"""
input services_sum_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""
update columns of table "services"
"""
enum services_update_column {
  """column name"""
  other_product_service_details

  """column name"""
  product_description

  """column name"""
  product_name

  """column name"""
  product_price

  """column name"""
  service_id

  """column name"""
  service_type_code

  """column name"""
  workshop_group_id
}

"""aggregate var_pop on columns"""
type services_var_pop_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by var_pop() on columns of table "services"
"""
input services_var_pop_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""aggregate var_samp on columns"""
type services_var_samp_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by var_samp() on columns of table "services"
"""
input services_var_samp_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

"""aggregate variance on columns"""
type services_variance_fields {
  product_price: Float
  service_id: Float
  workshop_group_id: Float
}

"""
order by variance() on columns of table "services"
"""
input services_variance_order_by {
  product_price: order_by
  service_id: order_by
  workshop_group_id: order_by
}

scalar smallint

"""
expression to compare columns of type smallint. All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "stores"
"""
type stores {
  address_id: bigint

  """An object relationship"""
  marketing_region: marketing_regions
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_id: String
  store_name: String
  store_phone: String
}

"""
aggregated selection of "stores"
"""
type stores_aggregate {
  aggregate: stores_aggregate_fields
  nodes: [stores!]!
}

"""
aggregate fields of "stores"
"""
type stores_aggregate_fields {
  avg: stores_avg_fields
  count(columns: [stores_select_column!], distinct: Boolean): Int
  max: stores_max_fields
  min: stores_min_fields
  stddev: stores_stddev_fields
  stddev_pop: stores_stddev_pop_fields
  stddev_samp: stores_stddev_samp_fields
  sum: stores_sum_fields
  var_pop: stores_var_pop_fields
  var_samp: stores_var_samp_fields
  variance: stores_variance_fields
}

"""
order by aggregate values of table "stores"
"""
input stores_aggregate_order_by {
  avg: stores_avg_order_by
  count: order_by
  max: stores_max_order_by
  min: stores_min_order_by
  stddev: stores_stddev_order_by
  stddev_pop: stores_stddev_pop_order_by
  stddev_samp: stores_stddev_samp_order_by
  sum: stores_sum_order_by
  var_pop: stores_var_pop_order_by
  var_samp: stores_var_samp_order_by
  variance: stores_variance_order_by
}

"""
input type for inserting array relation for remote table "stores"
"""
input stores_arr_rel_insert_input {
  data: [stores_insert_input!]!
  on_conflict: stores_on_conflict
}

"""aggregate avg on columns"""
type stores_avg_fields {
  address_id: Float
}

"""
order by avg() on columns of table "stores"
"""
input stores_avg_order_by {
  address_id: order_by
}

"""
Boolean expression to filter rows from the table "stores". All fields are combined with a logical 'AND'.
"""
input stores_bool_exp {
  _and: [stores_bool_exp]
  _not: stores_bool_exp
  _or: [stores_bool_exp]
  address_id: bigint_comparison_exp
  marketing_region: marketing_regions_bool_exp
  marketing_region_code: String_comparison_exp
  other_details: String_comparison_exp
  store_email_address: String_comparison_exp
  store_id: String_comparison_exp
  store_name: String_comparison_exp
  store_phone: String_comparison_exp
}

"""
unique or primary key constraints on table "stores"
"""
enum stores_constraint {
  """unique or primary key constraint"""
  idx_23997_sqlite_autoindex_stores_1
}

"""
input type for incrementing integer column in table "stores"
"""
input stores_inc_input {
  address_id: bigint
}

"""
input type for inserting data into table "stores"
"""
input stores_insert_input {
  address_id: bigint
  marketing_region: marketing_regions_obj_rel_insert_input
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_id: String
  store_name: String
  store_phone: String
}

"""aggregate max on columns"""
type stores_max_fields {
  address_id: bigint
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_id: String
  store_name: String
  store_phone: String
}

"""
order by max() on columns of table "stores"
"""
input stores_max_order_by {
  address_id: order_by
  marketing_region_code: order_by
  other_details: order_by
  store_email_address: order_by
  store_id: order_by
  store_name: order_by
  store_phone: order_by
}

"""aggregate min on columns"""
type stores_min_fields {
  address_id: bigint
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_id: String
  store_name: String
  store_phone: String
}

"""
order by min() on columns of table "stores"
"""
input stores_min_order_by {
  address_id: order_by
  marketing_region_code: order_by
  other_details: order_by
  store_email_address: order_by
  store_id: order_by
  store_name: order_by
  store_phone: order_by
}

"""
response of any mutation on the table "stores"
"""
type stores_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [stores!]!
}

"""
input type for inserting object relation for remote table "stores"
"""
input stores_obj_rel_insert_input {
  data: stores_insert_input!
  on_conflict: stores_on_conflict
}

"""
on conflict condition type for table "stores"
"""
input stores_on_conflict {
  constraint: stores_constraint!
  update_columns: [stores_update_column!]!
  where: stores_bool_exp
}

"""
ordering options when selecting data from "stores"
"""
input stores_order_by {
  address_id: order_by
  marketing_region: marketing_regions_order_by
  marketing_region_code: order_by
  other_details: order_by
  store_email_address: order_by
  store_id: order_by
  store_name: order_by
  store_phone: order_by
}

"""
select columns of table "stores"
"""
enum stores_select_column {
  """column name"""
  address_id

  """column name"""
  marketing_region_code

  """column name"""
  other_details

  """column name"""
  store_email_address

  """column name"""
  store_id

  """column name"""
  store_name

  """column name"""
  store_phone
}

"""
input type for updating data in table "stores"
"""
input stores_set_input {
  address_id: bigint
  marketing_region_code: String
  other_details: String
  store_email_address: String
  store_id: String
  store_name: String
  store_phone: String
}

"""aggregate stddev on columns"""
type stores_stddev_fields {
  address_id: Float
}

"""
order by stddev() on columns of table "stores"
"""
input stores_stddev_order_by {
  address_id: order_by
}

"""aggregate stddev_pop on columns"""
type stores_stddev_pop_fields {
  address_id: Float
}

"""
order by stddev_pop() on columns of table "stores"
"""
input stores_stddev_pop_order_by {
  address_id: order_by
}

"""aggregate stddev_samp on columns"""
type stores_stddev_samp_fields {
  address_id: Float
}

"""
order by stddev_samp() on columns of table "stores"
"""
input stores_stddev_samp_order_by {
  address_id: order_by
}

"""aggregate sum on columns"""
type stores_sum_fields {
  address_id: bigint
}

"""
order by sum() on columns of table "stores"
"""
input stores_sum_order_by {
  address_id: order_by
}

"""
update columns of table "stores"
"""
enum stores_update_column {
  """column name"""
  address_id

  """column name"""
  marketing_region_code

  """column name"""
  other_details

  """column name"""
  store_email_address

  """column name"""
  store_id

  """column name"""
  store_name

  """column name"""
  store_phone
}

"""aggregate var_pop on columns"""
type stores_var_pop_fields {
  address_id: Float
}

"""
order by var_pop() on columns of table "stores"
"""
input stores_var_pop_order_by {
  address_id: order_by
}

"""aggregate var_samp on columns"""
type stores_var_samp_fields {
  address_id: Float
}

"""
order by var_samp() on columns of table "stores"
"""
input stores_var_samp_order_by {
  address_id: order_by
}

"""aggregate variance on columns"""
type stores_variance_fields {
  address_id: Float
}

"""
order by variance() on columns of table "stores"
"""
input stores_variance_order_by {
  address_id: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "addresses"
  """
  addresses(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): [addresses!]!

  """
  fetch aggregated fields from the table: "addresses"
  """
  addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [addresses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [addresses_order_by!]

    """filter the rows returned"""
    where: addresses_bool_exp
  ): addresses_aggregate!

  """
  fetch data from the table: "bookings"
  """
  bookings(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): [bookings!]!

  """
  fetch aggregated fields from the table: "bookings"
  """
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_order_by!]

    """filter the rows returned"""
    where: bookings_bool_exp
  ): bookings_aggregate!

  """fetch data from the table: "bookings" using primary key columns"""
  bookings_by_pk(booking_id: bigint!): bookings

  """
  fetch data from the table: "bookings_services"
  """
  bookings_services(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): [bookings_services!]!

  """
  fetch aggregated fields from the table: "bookings_services"
  """
  bookings_services_aggregate(
    """distinct select on columns"""
    distinct_on: [bookings_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookings_services_order_by!]

    """filter the rows returned"""
    where: bookings_services_bool_exp
  ): bookings_services_aggregate!

  """
  fetch data from the table: "bookings_services" using primary key columns
  """
  bookings_services_by_pk(order_id: bigint!, product_id: bigint!): bookings_services

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(client_id: bigint!): clients

  """
  fetch data from the table: "customer_orders"
  """
  customer_orders(
    """distinct select on columns"""
    distinct_on: [customer_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_orders_order_by!]

    """filter the rows returned"""
    where: customer_orders_bool_exp
  ): [customer_orders!]!

  """
  fetch aggregated fields from the table: "customer_orders"
  """
  customer_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_orders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_orders_order_by!]

    """filter the rows returned"""
    where: customer_orders_bool_exp
  ): customer_orders_aggregate!

  """fetch data from the table: "customer_orders" using primary key columns"""
  customer_orders_by_pk(order_id: bigint!): customer_orders

  """
  fetch data from the table: "customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """
  fetch data from the table: "drama_workshop_groups"
  """
  drama_workshop_groups(
    """distinct select on columns"""
    distinct_on: [drama_workshop_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drama_workshop_groups_order_by!]

    """filter the rows returned"""
    where: drama_workshop_groups_bool_exp
  ): [drama_workshop_groups!]!

  """
  fetch aggregated fields from the table: "drama_workshop_groups"
  """
  drama_workshop_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [drama_workshop_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [drama_workshop_groups_order_by!]

    """filter the rows returned"""
    where: drama_workshop_groups_bool_exp
  ): drama_workshop_groups_aggregate!

  """
  fetch data from the table: "drama_workshop_groups" using primary key columns
  """
  drama_workshop_groups_by_pk(workshop_group_id: bigint!): drama_workshop_groups

  """
  fetch data from the table: "invoice_items"
  """
  invoice_items(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): [invoice_items!]!

  """
  fetch aggregated fields from the table: "invoice_items"
  """
  invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_items_order_by!]

    """filter the rows returned"""
    where: invoice_items_bool_exp
  ): invoice_items_aggregate!

  """fetch data from the table: "invoice_items" using primary key columns"""
  invoice_items_by_pk(invoice_item_id: bigint!): invoice_items

  """
  fetch data from the table: "invoices"
  """
  invoices(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): [invoices!]!

  """
  fetch aggregated fields from the table: "invoices"
  """
  invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoices_order_by!]

    """filter the rows returned"""
    where: invoices_bool_exp
  ): invoices_aggregate!

  """fetch data from the table: "invoices" using primary key columns"""
  invoices_by_pk(invoice_id: bigint!): invoices

  """
  fetch data from the table: "marketing_regions"
  """
  marketing_regions(
    """distinct select on columns"""
    distinct_on: [marketing_regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketing_regions_order_by!]

    """filter the rows returned"""
    where: marketing_regions_bool_exp
  ): [marketing_regions!]!

  """
  fetch aggregated fields from the table: "marketing_regions"
  """
  marketing_regions_aggregate(
    """distinct select on columns"""
    distinct_on: [marketing_regions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketing_regions_order_by!]

    """filter the rows returned"""
    where: marketing_regions_bool_exp
  ): marketing_regions_aggregate!

  """
  fetch data from the table: "order_items"
  """
  order_items(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): [order_items!]!

  """
  fetch aggregated fields from the table: "order_items"
  """
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_items_order_by!]

    """filter the rows returned"""
    where: order_items_bool_exp
  ): order_items_aggregate!

  """fetch data from the table: "order_items" using primary key columns"""
  order_items_by_pk(order_item_id: bigint!): order_items

  """
  fetch data from the table: "performers"
  """
  performers(
    """distinct select on columns"""
    distinct_on: [performers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_order_by!]

    """filter the rows returned"""
    where: performers_bool_exp
  ): [performers!]!

  """
  fetch aggregated fields from the table: "performers"
  """
  performers_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_order_by!]

    """filter the rows returned"""
    where: performers_bool_exp
  ): performers_aggregate!

  """fetch data from the table: "performers" using primary key columns"""
  performers_by_pk(performer_id: bigint!): performers

  """
  fetch data from the table: "performers_in_bookings"
  """
  performers_in_bookings(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): [performers_in_bookings!]!

  """
  fetch aggregated fields from the table: "performers_in_bookings"
  """
  performers_in_bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [performers_in_bookings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [performers_in_bookings_order_by!]

    """filter the rows returned"""
    where: performers_in_bookings_bool_exp
  ): performers_in_bookings_aggregate!

  """
  fetch data from the table: "performers_in_bookings" using primary key columns
  """
  performers_in_bookings_by_pk(order_id: bigint!, performer_id: bigint!): performers_in_bookings

  """
  fetch data from the table: "products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """
  fetch data from the table: "ref_payment_methods"
  """
  ref_payment_methods(
    """distinct select on columns"""
    distinct_on: [ref_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_payment_methods_order_by!]

    """filter the rows returned"""
    where: ref_payment_methods_bool_exp
  ): [ref_payment_methods!]!

  """
  fetch aggregated fields from the table: "ref_payment_methods"
  """
  ref_payment_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_payment_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_payment_methods_order_by!]

    """filter the rows returned"""
    where: ref_payment_methods_bool_exp
  ): ref_payment_methods_aggregate!

  """
  fetch data from the table: "ref_payment_methods" using primary key columns
  """
  ref_payment_methods_by_pk(payment_method_code: String!): ref_payment_methods

  """
  fetch data from the table: "ref_service_types"
  """
  ref_service_types(
    """distinct select on columns"""
    distinct_on: [ref_service_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_service_types_order_by!]

    """filter the rows returned"""
    where: ref_service_types_bool_exp
  ): [ref_service_types!]!

  """
  fetch aggregated fields from the table: "ref_service_types"
  """
  ref_service_types_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_service_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_service_types_order_by!]

    """filter the rows returned"""
    where: ref_service_types_bool_exp
  ): ref_service_types_aggregate!

  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch aggregated fields from the table: "services"
  """
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(service_id: bigint!): services

  """
  fetch data from the table: "stores"
  """
  stores(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): [stores!]!

  """
  fetch aggregated fields from the table: "stores"
  """
  stores_aggregate(
    """distinct select on columns"""
    distinct_on: [stores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stores_order_by!]

    """filter the rows returned"""
    where: stores_bool_exp
  ): stores_aggregate!
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
