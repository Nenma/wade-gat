schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "affiliated_with"
"""
type affiliated_with {
  department: bigint!

  """An object relationship"""
  departmentByDepartment: department!
  physician: bigint!

  """An object relationship"""
  physicianByPhysician: physician!
  primaryaffiliation: Boolean
}

"""
aggregated selection of "affiliated_with"
"""
type affiliated_with_aggregate {
  aggregate: affiliated_with_aggregate_fields
  nodes: [affiliated_with!]!
}

"""
aggregate fields of "affiliated_with"
"""
type affiliated_with_aggregate_fields {
  avg: affiliated_with_avg_fields
  count(columns: [affiliated_with_select_column!], distinct: Boolean): Int
  max: affiliated_with_max_fields
  min: affiliated_with_min_fields
  stddev: affiliated_with_stddev_fields
  stddev_pop: affiliated_with_stddev_pop_fields
  stddev_samp: affiliated_with_stddev_samp_fields
  sum: affiliated_with_sum_fields
  var_pop: affiliated_with_var_pop_fields
  var_samp: affiliated_with_var_samp_fields
  variance: affiliated_with_variance_fields
}

"""
order by aggregate values of table "affiliated_with"
"""
input affiliated_with_aggregate_order_by {
  avg: affiliated_with_avg_order_by
  count: order_by
  max: affiliated_with_max_order_by
  min: affiliated_with_min_order_by
  stddev: affiliated_with_stddev_order_by
  stddev_pop: affiliated_with_stddev_pop_order_by
  stddev_samp: affiliated_with_stddev_samp_order_by
  sum: affiliated_with_sum_order_by
  var_pop: affiliated_with_var_pop_order_by
  var_samp: affiliated_with_var_samp_order_by
  variance: affiliated_with_variance_order_by
}

"""
input type for inserting array relation for remote table "affiliated_with"
"""
input affiliated_with_arr_rel_insert_input {
  data: [affiliated_with_insert_input!]!
  on_conflict: affiliated_with_on_conflict
}

"""aggregate avg on columns"""
type affiliated_with_avg_fields {
  department: Float
  physician: Float
}

"""
order by avg() on columns of table "affiliated_with"
"""
input affiliated_with_avg_order_by {
  department: order_by
  physician: order_by
}

"""
Boolean expression to filter rows from the table "affiliated_with". All fields are combined with a logical 'AND'.
"""
input affiliated_with_bool_exp {
  _and: [affiliated_with_bool_exp]
  _not: affiliated_with_bool_exp
  _or: [affiliated_with_bool_exp]
  department: bigint_comparison_exp
  departmentByDepartment: department_bool_exp
  physician: bigint_comparison_exp
  physicianByPhysician: physician_bool_exp
  primaryaffiliation: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "affiliated_with"
"""
enum affiliated_with_constraint {
  """unique or primary key constraint"""
  idx_17233_affiliated_with_pkey

  """unique or primary key constraint"""
  idx_17233_sqlite_autoindex_affiliated_with_1
}

"""
input type for incrementing integer column in table "affiliated_with"
"""
input affiliated_with_inc_input {
  department: bigint
  physician: bigint
}

"""
input type for inserting data into table "affiliated_with"
"""
input affiliated_with_insert_input {
  department: bigint
  departmentByDepartment: department_obj_rel_insert_input
  physician: bigint
  physicianByPhysician: physician_obj_rel_insert_input
  primaryaffiliation: Boolean
}

"""aggregate max on columns"""
type affiliated_with_max_fields {
  department: bigint
  physician: bigint
}

"""
order by max() on columns of table "affiliated_with"
"""
input affiliated_with_max_order_by {
  department: order_by
  physician: order_by
}

"""aggregate min on columns"""
type affiliated_with_min_fields {
  department: bigint
  physician: bigint
}

"""
order by min() on columns of table "affiliated_with"
"""
input affiliated_with_min_order_by {
  department: order_by
  physician: order_by
}

"""
response of any mutation on the table "affiliated_with"
"""
type affiliated_with_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [affiliated_with!]!
}

"""
input type for inserting object relation for remote table "affiliated_with"
"""
input affiliated_with_obj_rel_insert_input {
  data: affiliated_with_insert_input!
  on_conflict: affiliated_with_on_conflict
}

"""
on conflict condition type for table "affiliated_with"
"""
input affiliated_with_on_conflict {
  constraint: affiliated_with_constraint!
  update_columns: [affiliated_with_update_column!]!
  where: affiliated_with_bool_exp
}

"""
ordering options when selecting data from "affiliated_with"
"""
input affiliated_with_order_by {
  department: order_by
  departmentByDepartment: department_order_by
  physician: order_by
  physicianByPhysician: physician_order_by
  primaryaffiliation: order_by
}

"""
primary key columns input for table: "affiliated_with"
"""
input affiliated_with_pk_columns_input {
  department: bigint!
  physician: bigint!
}

"""
select columns of table "affiliated_with"
"""
enum affiliated_with_select_column {
  """column name"""
  department

  """column name"""
  physician

  """column name"""
  primaryaffiliation
}

"""
input type for updating data in table "affiliated_with"
"""
input affiliated_with_set_input {
  department: bigint
  physician: bigint
  primaryaffiliation: Boolean
}

"""aggregate stddev on columns"""
type affiliated_with_stddev_fields {
  department: Float
  physician: Float
}

"""
order by stddev() on columns of table "affiliated_with"
"""
input affiliated_with_stddev_order_by {
  department: order_by
  physician: order_by
}

"""aggregate stddev_pop on columns"""
type affiliated_with_stddev_pop_fields {
  department: Float
  physician: Float
}

"""
order by stddev_pop() on columns of table "affiliated_with"
"""
input affiliated_with_stddev_pop_order_by {
  department: order_by
  physician: order_by
}

"""aggregate stddev_samp on columns"""
type affiliated_with_stddev_samp_fields {
  department: Float
  physician: Float
}

"""
order by stddev_samp() on columns of table "affiliated_with"
"""
input affiliated_with_stddev_samp_order_by {
  department: order_by
  physician: order_by
}

"""aggregate sum on columns"""
type affiliated_with_sum_fields {
  department: bigint
  physician: bigint
}

"""
order by sum() on columns of table "affiliated_with"
"""
input affiliated_with_sum_order_by {
  department: order_by
  physician: order_by
}

"""
update columns of table "affiliated_with"
"""
enum affiliated_with_update_column {
  """column name"""
  department

  """column name"""
  physician

  """column name"""
  primaryaffiliation
}

"""aggregate var_pop on columns"""
type affiliated_with_var_pop_fields {
  department: Float
  physician: Float
}

"""
order by var_pop() on columns of table "affiliated_with"
"""
input affiliated_with_var_pop_order_by {
  department: order_by
  physician: order_by
}

"""aggregate var_samp on columns"""
type affiliated_with_var_samp_fields {
  department: Float
  physician: Float
}

"""
order by var_samp() on columns of table "affiliated_with"
"""
input affiliated_with_var_samp_order_by {
  department: order_by
  physician: order_by
}

"""aggregate variance on columns"""
type affiliated_with_variance_fields {
  department: Float
  physician: Float
}

"""
order by variance() on columns of table "affiliated_with"
"""
input affiliated_with_variance_order_by {
  department: order_by
  physician: order_by
}

"""
columns and relationships of "appointment"
"""
type appointment {
  appointmentid: bigint!
  end: timestamptz
  examinationroom: String

  """An object relationship"""
  nurse: nurse
  patient: bigint

  """An object relationship"""
  patientByPatient: patient
  physician: bigint

  """An object relationship"""
  physicianByPhysician: physician
  prepnurse: bigint

  """An array relationship"""
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """An aggregated array relationship"""
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!
  start: timestamptz
}

"""
aggregated selection of "appointment"
"""
type appointment_aggregate {
  aggregate: appointment_aggregate_fields
  nodes: [appointment!]!
}

"""
aggregate fields of "appointment"
"""
type appointment_aggregate_fields {
  avg: appointment_avg_fields
  count(columns: [appointment_select_column!], distinct: Boolean): Int
  max: appointment_max_fields
  min: appointment_min_fields
  stddev: appointment_stddev_fields
  stddev_pop: appointment_stddev_pop_fields
  stddev_samp: appointment_stddev_samp_fields
  sum: appointment_sum_fields
  var_pop: appointment_var_pop_fields
  var_samp: appointment_var_samp_fields
  variance: appointment_variance_fields
}

"""
order by aggregate values of table "appointment"
"""
input appointment_aggregate_order_by {
  avg: appointment_avg_order_by
  count: order_by
  max: appointment_max_order_by
  min: appointment_min_order_by
  stddev: appointment_stddev_order_by
  stddev_pop: appointment_stddev_pop_order_by
  stddev_samp: appointment_stddev_samp_order_by
  sum: appointment_sum_order_by
  var_pop: appointment_var_pop_order_by
  var_samp: appointment_var_samp_order_by
  variance: appointment_variance_order_by
}

"""
input type for inserting array relation for remote table "appointment"
"""
input appointment_arr_rel_insert_input {
  data: [appointment_insert_input!]!
  on_conflict: appointment_on_conflict
}

"""aggregate avg on columns"""
type appointment_avg_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by avg() on columns of table "appointment"
"""
input appointment_avg_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""
Boolean expression to filter rows from the table "appointment". All fields are combined with a logical 'AND'.
"""
input appointment_bool_exp {
  _and: [appointment_bool_exp]
  _not: appointment_bool_exp
  _or: [appointment_bool_exp]
  appointmentid: bigint_comparison_exp
  end: timestamptz_comparison_exp
  examinationroom: String_comparison_exp
  nurse: nurse_bool_exp
  patient: bigint_comparison_exp
  patientByPatient: patient_bool_exp
  physician: bigint_comparison_exp
  physicianByPhysician: physician_bool_exp
  prepnurse: bigint_comparison_exp
  prescribes: prescribes_bool_exp
  start: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "appointment"
"""
enum appointment_constraint {
  """unique or primary key constraint"""
  idx_17257_appointment_pkey
}

"""
input type for incrementing integer column in table "appointment"
"""
input appointment_inc_input {
  appointmentid: bigint
  patient: bigint
  physician: bigint
  prepnurse: bigint
}

"""
input type for inserting data into table "appointment"
"""
input appointment_insert_input {
  appointmentid: bigint
  end: timestamptz
  examinationroom: String
  nurse: nurse_obj_rel_insert_input
  patient: bigint
  patientByPatient: patient_obj_rel_insert_input
  physician: bigint
  physicianByPhysician: physician_obj_rel_insert_input
  prepnurse: bigint
  prescribes: prescribes_arr_rel_insert_input
  start: timestamptz
}

"""aggregate max on columns"""
type appointment_max_fields {
  appointmentid: bigint
  end: timestamptz
  examinationroom: String
  patient: bigint
  physician: bigint
  prepnurse: bigint
  start: timestamptz
}

"""
order by max() on columns of table "appointment"
"""
input appointment_max_order_by {
  appointmentid: order_by
  end: order_by
  examinationroom: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
  start: order_by
}

"""aggregate min on columns"""
type appointment_min_fields {
  appointmentid: bigint
  end: timestamptz
  examinationroom: String
  patient: bigint
  physician: bigint
  prepnurse: bigint
  start: timestamptz
}

"""
order by min() on columns of table "appointment"
"""
input appointment_min_order_by {
  appointmentid: order_by
  end: order_by
  examinationroom: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
  start: order_by
}

"""
response of any mutation on the table "appointment"
"""
type appointment_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [appointment!]!
}

"""
input type for inserting object relation for remote table "appointment"
"""
input appointment_obj_rel_insert_input {
  data: appointment_insert_input!
  on_conflict: appointment_on_conflict
}

"""
on conflict condition type for table "appointment"
"""
input appointment_on_conflict {
  constraint: appointment_constraint!
  update_columns: [appointment_update_column!]!
  where: appointment_bool_exp
}

"""
ordering options when selecting data from "appointment"
"""
input appointment_order_by {
  appointmentid: order_by
  end: order_by
  examinationroom: order_by
  nurse: nurse_order_by
  patient: order_by
  patientByPatient: patient_order_by
  physician: order_by
  physicianByPhysician: physician_order_by
  prepnurse: order_by
  prescribes_aggregate: prescribes_aggregate_order_by
  start: order_by
}

"""
primary key columns input for table: "appointment"
"""
input appointment_pk_columns_input {
  appointmentid: bigint!
}

"""
select columns of table "appointment"
"""
enum appointment_select_column {
  """column name"""
  appointmentid

  """column name"""
  end

  """column name"""
  examinationroom

  """column name"""
  patient

  """column name"""
  physician

  """column name"""
  prepnurse

  """column name"""
  start
}

"""
input type for updating data in table "appointment"
"""
input appointment_set_input {
  appointmentid: bigint
  end: timestamptz
  examinationroom: String
  patient: bigint
  physician: bigint
  prepnurse: bigint
  start: timestamptz
}

"""aggregate stddev on columns"""
type appointment_stddev_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by stddev() on columns of table "appointment"
"""
input appointment_stddev_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""aggregate stddev_pop on columns"""
type appointment_stddev_pop_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by stddev_pop() on columns of table "appointment"
"""
input appointment_stddev_pop_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""aggregate stddev_samp on columns"""
type appointment_stddev_samp_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by stddev_samp() on columns of table "appointment"
"""
input appointment_stddev_samp_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""aggregate sum on columns"""
type appointment_sum_fields {
  appointmentid: bigint
  patient: bigint
  physician: bigint
  prepnurse: bigint
}

"""
order by sum() on columns of table "appointment"
"""
input appointment_sum_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""
update columns of table "appointment"
"""
enum appointment_update_column {
  """column name"""
  appointmentid

  """column name"""
  end

  """column name"""
  examinationroom

  """column name"""
  patient

  """column name"""
  physician

  """column name"""
  prepnurse

  """column name"""
  start
}

"""aggregate var_pop on columns"""
type appointment_var_pop_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by var_pop() on columns of table "appointment"
"""
input appointment_var_pop_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""aggregate var_samp on columns"""
type appointment_var_samp_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by var_samp() on columns of table "appointment"
"""
input appointment_var_samp_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

"""aggregate variance on columns"""
type appointment_variance_fields {
  appointmentid: Float
  patient: Float
  physician: Float
  prepnurse: Float
}

"""
order by variance() on columns of table "appointment"
"""
input appointment_variance_order_by {
  appointmentid: order_by
  patient: order_by
  physician: order_by
  prepnurse: order_by
}

scalar bigint

"""
expression to compare columns of type bigint. All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "block"
"""
type block {
  blockcode: bigint!
  blockfloor: bigint!

  """An array relationship"""
  on_calls(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): [on_call!]!

  """An aggregated array relationship"""
  on_calls_aggregate(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): on_call_aggregate!

  """An array relationship"""
  rooms(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """An aggregated array relationship"""
  rooms_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!
}

"""
aggregated selection of "block"
"""
type block_aggregate {
  aggregate: block_aggregate_fields
  nodes: [block!]!
}

"""
aggregate fields of "block"
"""
type block_aggregate_fields {
  avg: block_avg_fields
  count(columns: [block_select_column!], distinct: Boolean): Int
  max: block_max_fields
  min: block_min_fields
  stddev: block_stddev_fields
  stddev_pop: block_stddev_pop_fields
  stddev_samp: block_stddev_samp_fields
  sum: block_sum_fields
  var_pop: block_var_pop_fields
  var_samp: block_var_samp_fields
  variance: block_variance_fields
}

"""
order by aggregate values of table "block"
"""
input block_aggregate_order_by {
  avg: block_avg_order_by
  count: order_by
  max: block_max_order_by
  min: block_min_order_by
  stddev: block_stddev_order_by
  stddev_pop: block_stddev_pop_order_by
  stddev_samp: block_stddev_samp_order_by
  sum: block_sum_order_by
  var_pop: block_var_pop_order_by
  var_samp: block_var_samp_order_by
  variance: block_variance_order_by
}

"""
input type for inserting array relation for remote table "block"
"""
input block_arr_rel_insert_input {
  data: [block_insert_input!]!
  on_conflict: block_on_conflict
}

"""aggregate avg on columns"""
type block_avg_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by avg() on columns of table "block"
"""
input block_avg_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""
Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
"""
input block_bool_exp {
  _and: [block_bool_exp]
  _not: block_bool_exp
  _or: [block_bool_exp]
  blockcode: bigint_comparison_exp
  blockfloor: bigint_comparison_exp
  on_calls: on_call_bool_exp
  rooms: room_bool_exp
}

"""
unique or primary key constraints on table "block"
"""
enum block_constraint {
  """unique or primary key constraint"""
  idx_17275_block_pkey

  """unique or primary key constraint"""
  idx_17275_sqlite_autoindex_block_1
}

"""
input type for incrementing integer column in table "block"
"""
input block_inc_input {
  blockcode: bigint
  blockfloor: bigint
}

"""
input type for inserting data into table "block"
"""
input block_insert_input {
  blockcode: bigint
  blockfloor: bigint
  on_calls: on_call_arr_rel_insert_input
  rooms: room_arr_rel_insert_input
}

"""aggregate max on columns"""
type block_max_fields {
  blockcode: bigint
  blockfloor: bigint
}

"""
order by max() on columns of table "block"
"""
input block_max_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate min on columns"""
type block_min_fields {
  blockcode: bigint
  blockfloor: bigint
}

"""
order by min() on columns of table "block"
"""
input block_min_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""
response of any mutation on the table "block"
"""
type block_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [block!]!
}

"""
input type for inserting object relation for remote table "block"
"""
input block_obj_rel_insert_input {
  data: block_insert_input!
  on_conflict: block_on_conflict
}

"""
on conflict condition type for table "block"
"""
input block_on_conflict {
  constraint: block_constraint!
  update_columns: [block_update_column!]!
  where: block_bool_exp
}

"""
ordering options when selecting data from "block"
"""
input block_order_by {
  blockcode: order_by
  blockfloor: order_by
  on_calls_aggregate: on_call_aggregate_order_by
  rooms_aggregate: room_aggregate_order_by
}

"""
primary key columns input for table: "block"
"""
input block_pk_columns_input {
  blockcode: bigint!
  blockfloor: bigint!
}

"""
select columns of table "block"
"""
enum block_select_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor
}

"""
input type for updating data in table "block"
"""
input block_set_input {
  blockcode: bigint
  blockfloor: bigint
}

"""aggregate stddev on columns"""
type block_stddev_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by stddev() on columns of table "block"
"""
input block_stddev_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate stddev_pop on columns"""
type block_stddev_pop_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by stddev_pop() on columns of table "block"
"""
input block_stddev_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate stddev_samp on columns"""
type block_stddev_samp_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by stddev_samp() on columns of table "block"
"""
input block_stddev_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate sum on columns"""
type block_sum_fields {
  blockcode: bigint
  blockfloor: bigint
}

"""
order by sum() on columns of table "block"
"""
input block_sum_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""
update columns of table "block"
"""
enum block_update_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor
}

"""aggregate var_pop on columns"""
type block_var_pop_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by var_pop() on columns of table "block"
"""
input block_var_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate var_samp on columns"""
type block_var_samp_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by var_samp() on columns of table "block"
"""
input block_var_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""aggregate variance on columns"""
type block_variance_fields {
  blockcode: Float
  blockfloor: Float
}

"""
order by variance() on columns of table "block"
"""
input block_variance_order_by {
  blockcode: order_by
  blockfloor: order_by
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "department"
"""
type department {
  """An array relationship"""
  affiliated_withs(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): [affiliated_with!]!

  """An aggregated array relationship"""
  affiliated_withs_aggregate(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): affiliated_with_aggregate!
  departmentid: bigint!
  head: bigint
  name: String

  """An object relationship"""
  physician: physician
}

"""
aggregated selection of "department"
"""
type department_aggregate {
  aggregate: department_aggregate_fields
  nodes: [department!]!
}

"""
aggregate fields of "department"
"""
type department_aggregate_fields {
  avg: department_avg_fields
  count(columns: [department_select_column!], distinct: Boolean): Int
  max: department_max_fields
  min: department_min_fields
  stddev: department_stddev_fields
  stddev_pop: department_stddev_pop_fields
  stddev_samp: department_stddev_samp_fields
  sum: department_sum_fields
  var_pop: department_var_pop_fields
  var_samp: department_var_samp_fields
  variance: department_variance_fields
}

"""
order by aggregate values of table "department"
"""
input department_aggregate_order_by {
  avg: department_avg_order_by
  count: order_by
  max: department_max_order_by
  min: department_min_order_by
  stddev: department_stddev_order_by
  stddev_pop: department_stddev_pop_order_by
  stddev_samp: department_stddev_samp_order_by
  sum: department_sum_order_by
  var_pop: department_var_pop_order_by
  var_samp: department_var_samp_order_by
  variance: department_variance_order_by
}

"""
input type for inserting array relation for remote table "department"
"""
input department_arr_rel_insert_input {
  data: [department_insert_input!]!
  on_conflict: department_on_conflict
}

"""aggregate avg on columns"""
type department_avg_fields {
  departmentid: Float
  head: Float
}

"""
order by avg() on columns of table "department"
"""
input department_avg_order_by {
  departmentid: order_by
  head: order_by
}

"""
Boolean expression to filter rows from the table "department". All fields are combined with a logical 'AND'.
"""
input department_bool_exp {
  _and: [department_bool_exp]
  _not: department_bool_exp
  _or: [department_bool_exp]
  affiliated_withs: affiliated_with_bool_exp
  departmentid: bigint_comparison_exp
  head: bigint_comparison_exp
  name: String_comparison_exp
  physician: physician_bool_exp
}

"""
unique or primary key constraints on table "department"
"""
enum department_constraint {
  """unique or primary key constraint"""
  idx_17227_department_pkey
}

"""
input type for incrementing integer column in table "department"
"""
input department_inc_input {
  departmentid: bigint
  head: bigint
}

"""
input type for inserting data into table "department"
"""
input department_insert_input {
  affiliated_withs: affiliated_with_arr_rel_insert_input
  departmentid: bigint
  head: bigint
  name: String
  physician: physician_obj_rel_insert_input
}

"""aggregate max on columns"""
type department_max_fields {
  departmentid: bigint
  head: bigint
  name: String
}

"""
order by max() on columns of table "department"
"""
input department_max_order_by {
  departmentid: order_by
  head: order_by
  name: order_by
}

"""aggregate min on columns"""
type department_min_fields {
  departmentid: bigint
  head: bigint
  name: String
}

"""
order by min() on columns of table "department"
"""
input department_min_order_by {
  departmentid: order_by
  head: order_by
  name: order_by
}

"""
response of any mutation on the table "department"
"""
type department_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [department!]!
}

"""
input type for inserting object relation for remote table "department"
"""
input department_obj_rel_insert_input {
  data: department_insert_input!
  on_conflict: department_on_conflict
}

"""
on conflict condition type for table "department"
"""
input department_on_conflict {
  constraint: department_constraint!
  update_columns: [department_update_column!]!
  where: department_bool_exp
}

"""
ordering options when selecting data from "department"
"""
input department_order_by {
  affiliated_withs_aggregate: affiliated_with_aggregate_order_by
  departmentid: order_by
  head: order_by
  name: order_by
  physician: physician_order_by
}

"""
primary key columns input for table: "department"
"""
input department_pk_columns_input {
  departmentid: bigint!
}

"""
select columns of table "department"
"""
enum department_select_column {
  """column name"""
  departmentid

  """column name"""
  head

  """column name"""
  name
}

"""
input type for updating data in table "department"
"""
input department_set_input {
  departmentid: bigint
  head: bigint
  name: String
}

"""aggregate stddev on columns"""
type department_stddev_fields {
  departmentid: Float
  head: Float
}

"""
order by stddev() on columns of table "department"
"""
input department_stddev_order_by {
  departmentid: order_by
  head: order_by
}

"""aggregate stddev_pop on columns"""
type department_stddev_pop_fields {
  departmentid: Float
  head: Float
}

"""
order by stddev_pop() on columns of table "department"
"""
input department_stddev_pop_order_by {
  departmentid: order_by
  head: order_by
}

"""aggregate stddev_samp on columns"""
type department_stddev_samp_fields {
  departmentid: Float
  head: Float
}

"""
order by stddev_samp() on columns of table "department"
"""
input department_stddev_samp_order_by {
  departmentid: order_by
  head: order_by
}

"""aggregate sum on columns"""
type department_sum_fields {
  departmentid: bigint
  head: bigint
}

"""
order by sum() on columns of table "department"
"""
input department_sum_order_by {
  departmentid: order_by
  head: order_by
}

"""
update columns of table "department"
"""
enum department_update_column {
  """column name"""
  departmentid

  """column name"""
  head

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type department_var_pop_fields {
  departmentid: Float
  head: Float
}

"""
order by var_pop() on columns of table "department"
"""
input department_var_pop_order_by {
  departmentid: order_by
  head: order_by
}

"""aggregate var_samp on columns"""
type department_var_samp_fields {
  departmentid: Float
  head: Float
}

"""
order by var_samp() on columns of table "department"
"""
input department_var_samp_order_by {
  departmentid: order_by
  head: order_by
}

"""aggregate variance on columns"""
type department_variance_fields {
  departmentid: Float
  head: Float
}

"""
order by variance() on columns of table "department"
"""
input department_variance_order_by {
  departmentid: order_by
  head: order_by
}

"""
expression to compare columns of type Float. All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
columns and relationships of "medication"
"""
type medication {
  brand: String
  code: bigint!
  description: String
  name: String

  """An array relationship"""
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """An aggregated array relationship"""
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!
}

"""
aggregated selection of "medication"
"""
type medication_aggregate {
  aggregate: medication_aggregate_fields
  nodes: [medication!]!
}

"""
aggregate fields of "medication"
"""
type medication_aggregate_fields {
  avg: medication_avg_fields
  count(columns: [medication_select_column!], distinct: Boolean): Int
  max: medication_max_fields
  min: medication_min_fields
  stddev: medication_stddev_fields
  stddev_pop: medication_stddev_pop_fields
  stddev_samp: medication_stddev_samp_fields
  sum: medication_sum_fields
  var_pop: medication_var_pop_fields
  var_samp: medication_var_samp_fields
  variance: medication_variance_fields
}

"""
order by aggregate values of table "medication"
"""
input medication_aggregate_order_by {
  avg: medication_avg_order_by
  count: order_by
  max: medication_max_order_by
  min: medication_min_order_by
  stddev: medication_stddev_order_by
  stddev_pop: medication_stddev_pop_order_by
  stddev_samp: medication_stddev_samp_order_by
  sum: medication_sum_order_by
  var_pop: medication_var_pop_order_by
  var_samp: medication_var_samp_order_by
  variance: medication_variance_order_by
}

"""
input type for inserting array relation for remote table "medication"
"""
input medication_arr_rel_insert_input {
  data: [medication_insert_input!]!
  on_conflict: medication_on_conflict
}

"""aggregate avg on columns"""
type medication_avg_fields {
  code: Float
}

"""
order by avg() on columns of table "medication"
"""
input medication_avg_order_by {
  code: order_by
}

"""
Boolean expression to filter rows from the table "medication". All fields are combined with a logical 'AND'.
"""
input medication_bool_exp {
  _and: [medication_bool_exp]
  _not: medication_bool_exp
  _or: [medication_bool_exp]
  brand: String_comparison_exp
  code: bigint_comparison_exp
  description: String_comparison_exp
  name: String_comparison_exp
  prescribes: prescribes_bool_exp
}

"""
unique or primary key constraints on table "medication"
"""
enum medication_constraint {
  """unique or primary key constraint"""
  idx_17263_medication_pkey
}

"""
input type for incrementing integer column in table "medication"
"""
input medication_inc_input {
  code: bigint
}

"""
input type for inserting data into table "medication"
"""
input medication_insert_input {
  brand: String
  code: bigint
  description: String
  name: String
  prescribes: prescribes_arr_rel_insert_input
}

"""aggregate max on columns"""
type medication_max_fields {
  brand: String
  code: bigint
  description: String
  name: String
}

"""
order by max() on columns of table "medication"
"""
input medication_max_order_by {
  brand: order_by
  code: order_by
  description: order_by
  name: order_by
}

"""aggregate min on columns"""
type medication_min_fields {
  brand: String
  code: bigint
  description: String
  name: String
}

"""
order by min() on columns of table "medication"
"""
input medication_min_order_by {
  brand: order_by
  code: order_by
  description: order_by
  name: order_by
}

"""
response of any mutation on the table "medication"
"""
type medication_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [medication!]!
}

"""
input type for inserting object relation for remote table "medication"
"""
input medication_obj_rel_insert_input {
  data: medication_insert_input!
  on_conflict: medication_on_conflict
}

"""
on conflict condition type for table "medication"
"""
input medication_on_conflict {
  constraint: medication_constraint!
  update_columns: [medication_update_column!]!
  where: medication_bool_exp
}

"""
ordering options when selecting data from "medication"
"""
input medication_order_by {
  brand: order_by
  code: order_by
  description: order_by
  name: order_by
  prescribes_aggregate: prescribes_aggregate_order_by
}

"""
primary key columns input for table: "medication"
"""
input medication_pk_columns_input {
  code: bigint!
}

"""
select columns of table "medication"
"""
enum medication_select_column {
  """column name"""
  brand

  """column name"""
  code

  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "medication"
"""
input medication_set_input {
  brand: String
  code: bigint
  description: String
  name: String
}

"""aggregate stddev on columns"""
type medication_stddev_fields {
  code: Float
}

"""
order by stddev() on columns of table "medication"
"""
input medication_stddev_order_by {
  code: order_by
}

"""aggregate stddev_pop on columns"""
type medication_stddev_pop_fields {
  code: Float
}

"""
order by stddev_pop() on columns of table "medication"
"""
input medication_stddev_pop_order_by {
  code: order_by
}

"""aggregate stddev_samp on columns"""
type medication_stddev_samp_fields {
  code: Float
}

"""
order by stddev_samp() on columns of table "medication"
"""
input medication_stddev_samp_order_by {
  code: order_by
}

"""aggregate sum on columns"""
type medication_sum_fields {
  code: bigint
}

"""
order by sum() on columns of table "medication"
"""
input medication_sum_order_by {
  code: order_by
}

"""
update columns of table "medication"
"""
enum medication_update_column {
  """column name"""
  brand

  """column name"""
  code

  """column name"""
  description

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type medication_var_pop_fields {
  code: Float
}

"""
order by var_pop() on columns of table "medication"
"""
input medication_var_pop_order_by {
  code: order_by
}

"""aggregate var_samp on columns"""
type medication_var_samp_fields {
  code: Float
}

"""
order by var_samp() on columns of table "medication"
"""
input medication_var_samp_order_by {
  code: order_by
}

"""aggregate variance on columns"""
type medication_variance_fields {
  code: Float
}

"""
order by variance() on columns of table "medication"
"""
input medication_variance_order_by {
  code: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "affiliated_with"
  """
  delete_affiliated_with(
    """filter the rows which have to be deleted"""
    where: affiliated_with_bool_exp!
  ): affiliated_with_mutation_response

  """
  delete single row from the table: "affiliated_with"
  """
  delete_affiliated_with_by_pk(department: bigint!, physician: bigint!): affiliated_with

  """
  delete data from the table: "appointment"
  """
  delete_appointment(
    """filter the rows which have to be deleted"""
    where: appointment_bool_exp!
  ): appointment_mutation_response

  """
  delete single row from the table: "appointment"
  """
  delete_appointment_by_pk(appointmentid: bigint!): appointment

  """
  delete data from the table: "block"
  """
  delete_block(
    """filter the rows which have to be deleted"""
    where: block_bool_exp!
  ): block_mutation_response

  """
  delete single row from the table: "block"
  """
  delete_block_by_pk(blockcode: bigint!, blockfloor: bigint!): block

  """
  delete data from the table: "department"
  """
  delete_department(
    """filter the rows which have to be deleted"""
    where: department_bool_exp!
  ): department_mutation_response

  """
  delete single row from the table: "department"
  """
  delete_department_by_pk(departmentid: bigint!): department

  """
  delete data from the table: "medication"
  """
  delete_medication(
    """filter the rows which have to be deleted"""
    where: medication_bool_exp!
  ): medication_mutation_response

  """
  delete single row from the table: "medication"
  """
  delete_medication_by_pk(code: bigint!): medication

  """
  delete data from the table: "nurse"
  """
  delete_nurse(
    """filter the rows which have to be deleted"""
    where: nurse_bool_exp!
  ): nurse_mutation_response

  """
  delete single row from the table: "nurse"
  """
  delete_nurse_by_pk(employeeid: bigint!): nurse

  """
  delete data from the table: "on_call"
  """
  delete_on_call(
    """filter the rows which have to be deleted"""
    where: on_call_bool_exp!
  ): on_call_mutation_response

  """
  delete data from the table: "patient"
  """
  delete_patient(
    """filter the rows which have to be deleted"""
    where: patient_bool_exp!
  ): patient_mutation_response

  """
  delete single row from the table: "patient"
  """
  delete_patient_by_pk(ssn: bigint!): patient

  """
  delete data from the table: "physician"
  """
  delete_physician(
    """filter the rows which have to be deleted"""
    where: physician_bool_exp!
  ): physician_mutation_response

  """
  delete single row from the table: "physician"
  """
  delete_physician_by_pk(employeeid: bigint!): physician

  """
  delete data from the table: "prescribes"
  """
  delete_prescribes(
    """filter the rows which have to be deleted"""
    where: prescribes_bool_exp!
  ): prescribes_mutation_response

  """
  delete data from the table: "procedures"
  """
  delete_procedures(
    """filter the rows which have to be deleted"""
    where: procedures_bool_exp!
  ): procedures_mutation_response

  """
  delete single row from the table: "procedures"
  """
  delete_procedures_by_pk(code: bigint!): procedures

  """
  delete data from the table: "room"
  """
  delete_room(
    """filter the rows which have to be deleted"""
    where: room_bool_exp!
  ): room_mutation_response

  """
  delete single row from the table: "room"
  """
  delete_room_by_pk(roomnumber: bigint!): room

  """
  delete data from the table: "stay"
  """
  delete_stay(
    """filter the rows which have to be deleted"""
    where: stay_bool_exp!
  ): stay_mutation_response

  """
  delete single row from the table: "stay"
  """
  delete_stay_by_pk(stayid: bigint!): stay

  """
  delete data from the table: "trained_in"
  """
  delete_trained_in(
    """filter the rows which have to be deleted"""
    where: trained_in_bool_exp!
  ): trained_in_mutation_response

  """
  delete single row from the table: "trained_in"
  """
  delete_trained_in_by_pk(physician: bigint!, treatment: bigint!): trained_in

  """
  delete data from the table: "undergoes"
  """
  delete_undergoes(
    """filter the rows which have to be deleted"""
    where: undergoes_bool_exp!
  ): undergoes_mutation_response

  """
  insert data into the table: "affiliated_with"
  """
  insert_affiliated_with(
    """the rows to be inserted"""
    objects: [affiliated_with_insert_input!]!

    """on conflict condition"""
    on_conflict: affiliated_with_on_conflict
  ): affiliated_with_mutation_response

  """
  insert a single row into the table: "affiliated_with"
  """
  insert_affiliated_with_one(
    """the row to be inserted"""
    object: affiliated_with_insert_input!

    """on conflict condition"""
    on_conflict: affiliated_with_on_conflict
  ): affiliated_with

  """
  insert data into the table: "appointment"
  """
  insert_appointment(
    """the rows to be inserted"""
    objects: [appointment_insert_input!]!

    """on conflict condition"""
    on_conflict: appointment_on_conflict
  ): appointment_mutation_response

  """
  insert a single row into the table: "appointment"
  """
  insert_appointment_one(
    """the row to be inserted"""
    object: appointment_insert_input!

    """on conflict condition"""
    on_conflict: appointment_on_conflict
  ): appointment

  """
  insert data into the table: "block"
  """
  insert_block(
    """the rows to be inserted"""
    objects: [block_insert_input!]!

    """on conflict condition"""
    on_conflict: block_on_conflict
  ): block_mutation_response

  """
  insert a single row into the table: "block"
  """
  insert_block_one(
    """the row to be inserted"""
    object: block_insert_input!

    """on conflict condition"""
    on_conflict: block_on_conflict
  ): block

  """
  insert data into the table: "department"
  """
  insert_department(
    """the rows to be inserted"""
    objects: [department_insert_input!]!

    """on conflict condition"""
    on_conflict: department_on_conflict
  ): department_mutation_response

  """
  insert a single row into the table: "department"
  """
  insert_department_one(
    """the row to be inserted"""
    object: department_insert_input!

    """on conflict condition"""
    on_conflict: department_on_conflict
  ): department

  """
  insert data into the table: "medication"
  """
  insert_medication(
    """the rows to be inserted"""
    objects: [medication_insert_input!]!

    """on conflict condition"""
    on_conflict: medication_on_conflict
  ): medication_mutation_response

  """
  insert a single row into the table: "medication"
  """
  insert_medication_one(
    """the row to be inserted"""
    object: medication_insert_input!

    """on conflict condition"""
    on_conflict: medication_on_conflict
  ): medication

  """
  insert data into the table: "nurse"
  """
  insert_nurse(
    """the rows to be inserted"""
    objects: [nurse_insert_input!]!

    """on conflict condition"""
    on_conflict: nurse_on_conflict
  ): nurse_mutation_response

  """
  insert a single row into the table: "nurse"
  """
  insert_nurse_one(
    """the row to be inserted"""
    object: nurse_insert_input!

    """on conflict condition"""
    on_conflict: nurse_on_conflict
  ): nurse

  """
  insert data into the table: "on_call"
  """
  insert_on_call(
    """the rows to be inserted"""
    objects: [on_call_insert_input!]!

    """on conflict condition"""
    on_conflict: on_call_on_conflict
  ): on_call_mutation_response

  """
  insert a single row into the table: "on_call"
  """
  insert_on_call_one(
    """the row to be inserted"""
    object: on_call_insert_input!

    """on conflict condition"""
    on_conflict: on_call_on_conflict
  ): on_call

  """
  insert data into the table: "patient"
  """
  insert_patient(
    """the rows to be inserted"""
    objects: [patient_insert_input!]!

    """on conflict condition"""
    on_conflict: patient_on_conflict
  ): patient_mutation_response

  """
  insert a single row into the table: "patient"
  """
  insert_patient_one(
    """the row to be inserted"""
    object: patient_insert_input!

    """on conflict condition"""
    on_conflict: patient_on_conflict
  ): patient

  """
  insert data into the table: "physician"
  """
  insert_physician(
    """the rows to be inserted"""
    objects: [physician_insert_input!]!

    """on conflict condition"""
    on_conflict: physician_on_conflict
  ): physician_mutation_response

  """
  insert a single row into the table: "physician"
  """
  insert_physician_one(
    """the row to be inserted"""
    object: physician_insert_input!

    """on conflict condition"""
    on_conflict: physician_on_conflict
  ): physician

  """
  insert data into the table: "prescribes"
  """
  insert_prescribes(
    """the rows to be inserted"""
    objects: [prescribes_insert_input!]!

    """on conflict condition"""
    on_conflict: prescribes_on_conflict
  ): prescribes_mutation_response

  """
  insert a single row into the table: "prescribes"
  """
  insert_prescribes_one(
    """the row to be inserted"""
    object: prescribes_insert_input!

    """on conflict condition"""
    on_conflict: prescribes_on_conflict
  ): prescribes

  """
  insert data into the table: "procedures"
  """
  insert_procedures(
    """the rows to be inserted"""
    objects: [procedures_insert_input!]!

    """on conflict condition"""
    on_conflict: procedures_on_conflict
  ): procedures_mutation_response

  """
  insert a single row into the table: "procedures"
  """
  insert_procedures_one(
    """the row to be inserted"""
    object: procedures_insert_input!

    """on conflict condition"""
    on_conflict: procedures_on_conflict
  ): procedures

  """
  insert data into the table: "room"
  """
  insert_room(
    """the rows to be inserted"""
    objects: [room_insert_input!]!

    """on conflict condition"""
    on_conflict: room_on_conflict
  ): room_mutation_response

  """
  insert a single row into the table: "room"
  """
  insert_room_one(
    """the row to be inserted"""
    object: room_insert_input!

    """on conflict condition"""
    on_conflict: room_on_conflict
  ): room

  """
  insert data into the table: "stay"
  """
  insert_stay(
    """the rows to be inserted"""
    objects: [stay_insert_input!]!

    """on conflict condition"""
    on_conflict: stay_on_conflict
  ): stay_mutation_response

  """
  insert a single row into the table: "stay"
  """
  insert_stay_one(
    """the row to be inserted"""
    object: stay_insert_input!

    """on conflict condition"""
    on_conflict: stay_on_conflict
  ): stay

  """
  insert data into the table: "trained_in"
  """
  insert_trained_in(
    """the rows to be inserted"""
    objects: [trained_in_insert_input!]!

    """on conflict condition"""
    on_conflict: trained_in_on_conflict
  ): trained_in_mutation_response

  """
  insert a single row into the table: "trained_in"
  """
  insert_trained_in_one(
    """the row to be inserted"""
    object: trained_in_insert_input!

    """on conflict condition"""
    on_conflict: trained_in_on_conflict
  ): trained_in

  """
  insert data into the table: "undergoes"
  """
  insert_undergoes(
    """the rows to be inserted"""
    objects: [undergoes_insert_input!]!

    """on conflict condition"""
    on_conflict: undergoes_on_conflict
  ): undergoes_mutation_response

  """
  insert a single row into the table: "undergoes"
  """
  insert_undergoes_one(
    """the row to be inserted"""
    object: undergoes_insert_input!

    """on conflict condition"""
    on_conflict: undergoes_on_conflict
  ): undergoes

  """
  update data of the table: "affiliated_with"
  """
  update_affiliated_with(
    """increments the integer columns with given value of the filtered values"""
    _inc: affiliated_with_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: affiliated_with_set_input

    """filter the rows which have to be updated"""
    where: affiliated_with_bool_exp!
  ): affiliated_with_mutation_response

  """
  update single row of the table: "affiliated_with"
  """
  update_affiliated_with_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: affiliated_with_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: affiliated_with_set_input
    pk_columns: affiliated_with_pk_columns_input!
  ): affiliated_with

  """
  update data of the table: "appointment"
  """
  update_appointment(
    """increments the integer columns with given value of the filtered values"""
    _inc: appointment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: appointment_set_input

    """filter the rows which have to be updated"""
    where: appointment_bool_exp!
  ): appointment_mutation_response

  """
  update single row of the table: "appointment"
  """
  update_appointment_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: appointment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: appointment_set_input
    pk_columns: appointment_pk_columns_input!
  ): appointment

  """
  update data of the table: "block"
  """
  update_block(
    """increments the integer columns with given value of the filtered values"""
    _inc: block_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_set_input

    """filter the rows which have to be updated"""
    where: block_bool_exp!
  ): block_mutation_response

  """
  update single row of the table: "block"
  """
  update_block_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: block_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_set_input
    pk_columns: block_pk_columns_input!
  ): block

  """
  update data of the table: "department"
  """
  update_department(
    """increments the integer columns with given value of the filtered values"""
    _inc: department_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: department_set_input

    """filter the rows which have to be updated"""
    where: department_bool_exp!
  ): department_mutation_response

  """
  update single row of the table: "department"
  """
  update_department_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: department_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: department_set_input
    pk_columns: department_pk_columns_input!
  ): department

  """
  update data of the table: "medication"
  """
  update_medication(
    """increments the integer columns with given value of the filtered values"""
    _inc: medication_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: medication_set_input

    """filter the rows which have to be updated"""
    where: medication_bool_exp!
  ): medication_mutation_response

  """
  update single row of the table: "medication"
  """
  update_medication_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: medication_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: medication_set_input
    pk_columns: medication_pk_columns_input!
  ): medication

  """
  update data of the table: "nurse"
  """
  update_nurse(
    """increments the integer columns with given value of the filtered values"""
    _inc: nurse_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nurse_set_input

    """filter the rows which have to be updated"""
    where: nurse_bool_exp!
  ): nurse_mutation_response

  """
  update single row of the table: "nurse"
  """
  update_nurse_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: nurse_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nurse_set_input
    pk_columns: nurse_pk_columns_input!
  ): nurse

  """
  update data of the table: "on_call"
  """
  update_on_call(
    """increments the integer columns with given value of the filtered values"""
    _inc: on_call_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: on_call_set_input

    """filter the rows which have to be updated"""
    where: on_call_bool_exp!
  ): on_call_mutation_response

  """
  update data of the table: "patient"
  """
  update_patient(
    """increments the integer columns with given value of the filtered values"""
    _inc: patient_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: patient_set_input

    """filter the rows which have to be updated"""
    where: patient_bool_exp!
  ): patient_mutation_response

  """
  update single row of the table: "patient"
  """
  update_patient_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: patient_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: patient_set_input
    pk_columns: patient_pk_columns_input!
  ): patient

  """
  update data of the table: "physician"
  """
  update_physician(
    """increments the integer columns with given value of the filtered values"""
    _inc: physician_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: physician_set_input

    """filter the rows which have to be updated"""
    where: physician_bool_exp!
  ): physician_mutation_response

  """
  update single row of the table: "physician"
  """
  update_physician_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: physician_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: physician_set_input
    pk_columns: physician_pk_columns_input!
  ): physician

  """
  update data of the table: "prescribes"
  """
  update_prescribes(
    """increments the integer columns with given value of the filtered values"""
    _inc: prescribes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: prescribes_set_input

    """filter the rows which have to be updated"""
    where: prescribes_bool_exp!
  ): prescribes_mutation_response

  """
  update data of the table: "procedures"
  """
  update_procedures(
    """increments the integer columns with given value of the filtered values"""
    _inc: procedures_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: procedures_set_input

    """filter the rows which have to be updated"""
    where: procedures_bool_exp!
  ): procedures_mutation_response

  """
  update single row of the table: "procedures"
  """
  update_procedures_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: procedures_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: procedures_set_input
    pk_columns: procedures_pk_columns_input!
  ): procedures

  """
  update data of the table: "room"
  """
  update_room(
    """increments the integer columns with given value of the filtered values"""
    _inc: room_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: room_set_input

    """filter the rows which have to be updated"""
    where: room_bool_exp!
  ): room_mutation_response

  """
  update single row of the table: "room"
  """
  update_room_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: room_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: room_set_input
    pk_columns: room_pk_columns_input!
  ): room

  """
  update data of the table: "stay"
  """
  update_stay(
    """increments the integer columns with given value of the filtered values"""
    _inc: stay_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stay_set_input

    """filter the rows which have to be updated"""
    where: stay_bool_exp!
  ): stay_mutation_response

  """
  update single row of the table: "stay"
  """
  update_stay_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: stay_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: stay_set_input
    pk_columns: stay_pk_columns_input!
  ): stay

  """
  update data of the table: "trained_in"
  """
  update_trained_in(
    """increments the integer columns with given value of the filtered values"""
    _inc: trained_in_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: trained_in_set_input

    """filter the rows which have to be updated"""
    where: trained_in_bool_exp!
  ): trained_in_mutation_response

  """
  update single row of the table: "trained_in"
  """
  update_trained_in_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: trained_in_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: trained_in_set_input
    pk_columns: trained_in_pk_columns_input!
  ): trained_in

  """
  update data of the table: "undergoes"
  """
  update_undergoes(
    """increments the integer columns with given value of the filtered values"""
    _inc: undergoes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: undergoes_set_input

    """filter the rows which have to be updated"""
    where: undergoes_bool_exp!
  ): undergoes_mutation_response
}

"""
columns and relationships of "nurse"
"""
type nurse {
  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): [appointment!]!

  """An aggregated array relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): appointment_aggregate!
  employeeid: bigint!
  name: String

  """An array relationship"""
  on_calls(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): [on_call!]!

  """An aggregated array relationship"""
  on_calls_aggregate(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): on_call_aggregate!
  position: String
  registered: Boolean
  ssn: bigint
}

"""
aggregated selection of "nurse"
"""
type nurse_aggregate {
  aggregate: nurse_aggregate_fields
  nodes: [nurse!]!
}

"""
aggregate fields of "nurse"
"""
type nurse_aggregate_fields {
  avg: nurse_avg_fields
  count(columns: [nurse_select_column!], distinct: Boolean): Int
  max: nurse_max_fields
  min: nurse_min_fields
  stddev: nurse_stddev_fields
  stddev_pop: nurse_stddev_pop_fields
  stddev_samp: nurse_stddev_samp_fields
  sum: nurse_sum_fields
  var_pop: nurse_var_pop_fields
  var_samp: nurse_var_samp_fields
  variance: nurse_variance_fields
}

"""
order by aggregate values of table "nurse"
"""
input nurse_aggregate_order_by {
  avg: nurse_avg_order_by
  count: order_by
  max: nurse_max_order_by
  min: nurse_min_order_by
  stddev: nurse_stddev_order_by
  stddev_pop: nurse_stddev_pop_order_by
  stddev_samp: nurse_stddev_samp_order_by
  sum: nurse_sum_order_by
  var_pop: nurse_var_pop_order_by
  var_samp: nurse_var_samp_order_by
  variance: nurse_variance_order_by
}

"""
input type for inserting array relation for remote table "nurse"
"""
input nurse_arr_rel_insert_input {
  data: [nurse_insert_input!]!
  on_conflict: nurse_on_conflict
}

"""aggregate avg on columns"""
type nurse_avg_fields {
  employeeid: Float
  ssn: Float
}

"""
order by avg() on columns of table "nurse"
"""
input nurse_avg_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
Boolean expression to filter rows from the table "nurse". All fields are combined with a logical 'AND'.
"""
input nurse_bool_exp {
  _and: [nurse_bool_exp]
  _not: nurse_bool_exp
  _or: [nurse_bool_exp]
  appointments: appointment_bool_exp
  employeeid: bigint_comparison_exp
  name: String_comparison_exp
  on_calls: on_call_bool_exp
  position: String_comparison_exp
  registered: Boolean_comparison_exp
  ssn: bigint_comparison_exp
}

"""
unique or primary key constraints on table "nurse"
"""
enum nurse_constraint {
  """unique or primary key constraint"""
  idx_17251_nurse_pkey
}

"""
input type for incrementing integer column in table "nurse"
"""
input nurse_inc_input {
  employeeid: bigint
  ssn: bigint
}

"""
input type for inserting data into table "nurse"
"""
input nurse_insert_input {
  appointments: appointment_arr_rel_insert_input
  employeeid: bigint
  name: String
  on_calls: on_call_arr_rel_insert_input
  position: String
  registered: Boolean
  ssn: bigint
}

"""aggregate max on columns"""
type nurse_max_fields {
  employeeid: bigint
  name: String
  position: String
  ssn: bigint
}

"""
order by max() on columns of table "nurse"
"""
input nurse_max_order_by {
  employeeid: order_by
  name: order_by
  position: order_by
  ssn: order_by
}

"""aggregate min on columns"""
type nurse_min_fields {
  employeeid: bigint
  name: String
  position: String
  ssn: bigint
}

"""
order by min() on columns of table "nurse"
"""
input nurse_min_order_by {
  employeeid: order_by
  name: order_by
  position: order_by
  ssn: order_by
}

"""
response of any mutation on the table "nurse"
"""
type nurse_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [nurse!]!
}

"""
input type for inserting object relation for remote table "nurse"
"""
input nurse_obj_rel_insert_input {
  data: nurse_insert_input!
  on_conflict: nurse_on_conflict
}

"""
on conflict condition type for table "nurse"
"""
input nurse_on_conflict {
  constraint: nurse_constraint!
  update_columns: [nurse_update_column!]!
  where: nurse_bool_exp
}

"""
ordering options when selecting data from "nurse"
"""
input nurse_order_by {
  appointments_aggregate: appointment_aggregate_order_by
  employeeid: order_by
  name: order_by
  on_calls_aggregate: on_call_aggregate_order_by
  position: order_by
  registered: order_by
  ssn: order_by
}

"""
primary key columns input for table: "nurse"
"""
input nurse_pk_columns_input {
  employeeid: bigint!
}

"""
select columns of table "nurse"
"""
enum nurse_select_column {
  """column name"""
  employeeid

  """column name"""
  name

  """column name"""
  position

  """column name"""
  registered

  """column name"""
  ssn
}

"""
input type for updating data in table "nurse"
"""
input nurse_set_input {
  employeeid: bigint
  name: String
  position: String
  registered: Boolean
  ssn: bigint
}

"""aggregate stddev on columns"""
type nurse_stddev_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev() on columns of table "nurse"
"""
input nurse_stddev_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate stddev_pop on columns"""
type nurse_stddev_pop_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev_pop() on columns of table "nurse"
"""
input nurse_stddev_pop_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate stddev_samp on columns"""
type nurse_stddev_samp_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev_samp() on columns of table "nurse"
"""
input nurse_stddev_samp_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate sum on columns"""
type nurse_sum_fields {
  employeeid: bigint
  ssn: bigint
}

"""
order by sum() on columns of table "nurse"
"""
input nurse_sum_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
update columns of table "nurse"
"""
enum nurse_update_column {
  """column name"""
  employeeid

  """column name"""
  name

  """column name"""
  position

  """column name"""
  registered

  """column name"""
  ssn
}

"""aggregate var_pop on columns"""
type nurse_var_pop_fields {
  employeeid: Float
  ssn: Float
}

"""
order by var_pop() on columns of table "nurse"
"""
input nurse_var_pop_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate var_samp on columns"""
type nurse_var_samp_fields {
  employeeid: Float
  ssn: Float
}

"""
order by var_samp() on columns of table "nurse"
"""
input nurse_var_samp_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate variance on columns"""
type nurse_variance_fields {
  employeeid: Float
  ssn: Float
}

"""
order by variance() on columns of table "nurse"
"""
input nurse_variance_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
columns and relationships of "on_call"
"""
type on_call {
  """An object relationship"""
  block: block
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint

  """An object relationship"""
  nurseByNurse: nurse
  oncallend: timestamptz
  oncallstart: timestamptz
}

"""
aggregated selection of "on_call"
"""
type on_call_aggregate {
  aggregate: on_call_aggregate_fields
  nodes: [on_call!]!
}

"""
aggregate fields of "on_call"
"""
type on_call_aggregate_fields {
  avg: on_call_avg_fields
  count(columns: [on_call_select_column!], distinct: Boolean): Int
  max: on_call_max_fields
  min: on_call_min_fields
  stddev: on_call_stddev_fields
  stddev_pop: on_call_stddev_pop_fields
  stddev_samp: on_call_stddev_samp_fields
  sum: on_call_sum_fields
  var_pop: on_call_var_pop_fields
  var_samp: on_call_var_samp_fields
  variance: on_call_variance_fields
}

"""
order by aggregate values of table "on_call"
"""
input on_call_aggregate_order_by {
  avg: on_call_avg_order_by
  count: order_by
  max: on_call_max_order_by
  min: on_call_min_order_by
  stddev: on_call_stddev_order_by
  stddev_pop: on_call_stddev_pop_order_by
  stddev_samp: on_call_stddev_samp_order_by
  sum: on_call_sum_order_by
  var_pop: on_call_var_pop_order_by
  var_samp: on_call_var_samp_order_by
  variance: on_call_variance_order_by
}

"""
input type for inserting array relation for remote table "on_call"
"""
input on_call_arr_rel_insert_input {
  data: [on_call_insert_input!]!
  on_conflict: on_call_on_conflict
}

"""aggregate avg on columns"""
type on_call_avg_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by avg() on columns of table "on_call"
"""
input on_call_avg_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""
Boolean expression to filter rows from the table "on_call". All fields are combined with a logical 'AND'.
"""
input on_call_bool_exp {
  _and: [on_call_bool_exp]
  _not: on_call_bool_exp
  _or: [on_call_bool_exp]
  block: block_bool_exp
  blockcode: bigint_comparison_exp
  blockfloor: bigint_comparison_exp
  nurse: bigint_comparison_exp
  nurseByNurse: nurse_bool_exp
  oncallend: timestamptz_comparison_exp
  oncallstart: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "on_call"
"""
enum on_call_constraint {
  """unique or primary key constraint"""
  idx_17284_sqlite_autoindex_on_call_1
}

"""
input type for incrementing integer column in table "on_call"
"""
input on_call_inc_input {
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
}

"""
input type for inserting data into table "on_call"
"""
input on_call_insert_input {
  block: block_obj_rel_insert_input
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
  nurseByNurse: nurse_obj_rel_insert_input
  oncallend: timestamptz
  oncallstart: timestamptz
}

"""aggregate max on columns"""
type on_call_max_fields {
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
  oncallend: timestamptz
  oncallstart: timestamptz
}

"""
order by max() on columns of table "on_call"
"""
input on_call_max_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
  oncallend: order_by
  oncallstart: order_by
}

"""aggregate min on columns"""
type on_call_min_fields {
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
  oncallend: timestamptz
  oncallstart: timestamptz
}

"""
order by min() on columns of table "on_call"
"""
input on_call_min_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
  oncallend: order_by
  oncallstart: order_by
}

"""
response of any mutation on the table "on_call"
"""
type on_call_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [on_call!]!
}

"""
input type for inserting object relation for remote table "on_call"
"""
input on_call_obj_rel_insert_input {
  data: on_call_insert_input!
  on_conflict: on_call_on_conflict
}

"""
on conflict condition type for table "on_call"
"""
input on_call_on_conflict {
  constraint: on_call_constraint!
  update_columns: [on_call_update_column!]!
  where: on_call_bool_exp
}

"""
ordering options when selecting data from "on_call"
"""
input on_call_order_by {
  block: block_order_by
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
  nurseByNurse: nurse_order_by
  oncallend: order_by
  oncallstart: order_by
}

"""
select columns of table "on_call"
"""
enum on_call_select_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor

  """column name"""
  nurse

  """column name"""
  oncallend

  """column name"""
  oncallstart
}

"""
input type for updating data in table "on_call"
"""
input on_call_set_input {
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
  oncallend: timestamptz
  oncallstart: timestamptz
}

"""aggregate stddev on columns"""
type on_call_stddev_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by stddev() on columns of table "on_call"
"""
input on_call_stddev_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""aggregate stddev_pop on columns"""
type on_call_stddev_pop_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by stddev_pop() on columns of table "on_call"
"""
input on_call_stddev_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""aggregate stddev_samp on columns"""
type on_call_stddev_samp_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by stddev_samp() on columns of table "on_call"
"""
input on_call_stddev_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""aggregate sum on columns"""
type on_call_sum_fields {
  blockcode: bigint
  blockfloor: bigint
  nurse: bigint
}

"""
order by sum() on columns of table "on_call"
"""
input on_call_sum_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""
update columns of table "on_call"
"""
enum on_call_update_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor

  """column name"""
  nurse

  """column name"""
  oncallend

  """column name"""
  oncallstart
}

"""aggregate var_pop on columns"""
type on_call_var_pop_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by var_pop() on columns of table "on_call"
"""
input on_call_var_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""aggregate var_samp on columns"""
type on_call_var_samp_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by var_samp() on columns of table "on_call"
"""
input on_call_var_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""aggregate variance on columns"""
type on_call_variance_fields {
  blockcode: Float
  blockfloor: Float
  nurse: Float
}

"""
order by variance() on columns of table "on_call"
"""
input on_call_variance_order_by {
  blockcode: order_by
  blockfloor: order_by
  nurse: order_by
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "patient"
"""
type patient {
  address: String

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): [appointment!]!

  """An aggregated array relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): appointment_aggregate!
  insuranceid: bigint
  name: String
  pcp: bigint
  phone: String

  """An object relationship"""
  physician: physician

  """An array relationship"""
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """An aggregated array relationship"""
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!
  ssn: bigint!

  """An array relationship"""
  stays(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): [stay!]!

  """An aggregated array relationship"""
  stays_aggregate(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): stay_aggregate!

  """An array relationship"""
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """An aggregated array relationship"""
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

"""
aggregated selection of "patient"
"""
type patient_aggregate {
  aggregate: patient_aggregate_fields
  nodes: [patient!]!
}

"""
aggregate fields of "patient"
"""
type patient_aggregate_fields {
  avg: patient_avg_fields
  count(columns: [patient_select_column!], distinct: Boolean): Int
  max: patient_max_fields
  min: patient_min_fields
  stddev: patient_stddev_fields
  stddev_pop: patient_stddev_pop_fields
  stddev_samp: patient_stddev_samp_fields
  sum: patient_sum_fields
  var_pop: patient_var_pop_fields
  var_samp: patient_var_samp_fields
  variance: patient_variance_fields
}

"""
order by aggregate values of table "patient"
"""
input patient_aggregate_order_by {
  avg: patient_avg_order_by
  count: order_by
  max: patient_max_order_by
  min: patient_min_order_by
  stddev: patient_stddev_order_by
  stddev_pop: patient_stddev_pop_order_by
  stddev_samp: patient_stddev_samp_order_by
  sum: patient_sum_order_by
  var_pop: patient_var_pop_order_by
  var_samp: patient_var_samp_order_by
  variance: patient_variance_order_by
}

"""
input type for inserting array relation for remote table "patient"
"""
input patient_arr_rel_insert_input {
  data: [patient_insert_input!]!
  on_conflict: patient_on_conflict
}

"""aggregate avg on columns"""
type patient_avg_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by avg() on columns of table "patient"
"""
input patient_avg_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""
Boolean expression to filter rows from the table "patient". All fields are combined with a logical 'AND'.
"""
input patient_bool_exp {
  _and: [patient_bool_exp]
  _not: patient_bool_exp
  _or: [patient_bool_exp]
  address: String_comparison_exp
  appointments: appointment_bool_exp
  insuranceid: bigint_comparison_exp
  name: String_comparison_exp
  pcp: bigint_comparison_exp
  phone: String_comparison_exp
  physician: physician_bool_exp
  prescribes: prescribes_bool_exp
  ssn: bigint_comparison_exp
  stays: stay_bool_exp
  undergoes: undergoes_bool_exp
}

"""
unique or primary key constraints on table "patient"
"""
enum patient_constraint {
  """unique or primary key constraint"""
  idx_17245_patient_pkey
}

"""
input type for incrementing integer column in table "patient"
"""
input patient_inc_input {
  insuranceid: bigint
  pcp: bigint
  ssn: bigint
}

"""
input type for inserting data into table "patient"
"""
input patient_insert_input {
  address: String
  appointments: appointment_arr_rel_insert_input
  insuranceid: bigint
  name: String
  pcp: bigint
  phone: String
  physician: physician_obj_rel_insert_input
  prescribes: prescribes_arr_rel_insert_input
  ssn: bigint
  stays: stay_arr_rel_insert_input
  undergoes: undergoes_arr_rel_insert_input
}

"""aggregate max on columns"""
type patient_max_fields {
  address: String
  insuranceid: bigint
  name: String
  pcp: bigint
  phone: String
  ssn: bigint
}

"""
order by max() on columns of table "patient"
"""
input patient_max_order_by {
  address: order_by
  insuranceid: order_by
  name: order_by
  pcp: order_by
  phone: order_by
  ssn: order_by
}

"""aggregate min on columns"""
type patient_min_fields {
  address: String
  insuranceid: bigint
  name: String
  pcp: bigint
  phone: String
  ssn: bigint
}

"""
order by min() on columns of table "patient"
"""
input patient_min_order_by {
  address: order_by
  insuranceid: order_by
  name: order_by
  pcp: order_by
  phone: order_by
  ssn: order_by
}

"""
response of any mutation on the table "patient"
"""
type patient_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [patient!]!
}

"""
input type for inserting object relation for remote table "patient"
"""
input patient_obj_rel_insert_input {
  data: patient_insert_input!
  on_conflict: patient_on_conflict
}

"""
on conflict condition type for table "patient"
"""
input patient_on_conflict {
  constraint: patient_constraint!
  update_columns: [patient_update_column!]!
  where: patient_bool_exp
}

"""
ordering options when selecting data from "patient"
"""
input patient_order_by {
  address: order_by
  appointments_aggregate: appointment_aggregate_order_by
  insuranceid: order_by
  name: order_by
  pcp: order_by
  phone: order_by
  physician: physician_order_by
  prescribes_aggregate: prescribes_aggregate_order_by
  ssn: order_by
  stays_aggregate: stay_aggregate_order_by
  undergoes_aggregate: undergoes_aggregate_order_by
}

"""
primary key columns input for table: "patient"
"""
input patient_pk_columns_input {
  ssn: bigint!
}

"""
select columns of table "patient"
"""
enum patient_select_column {
  """column name"""
  address

  """column name"""
  insuranceid

  """column name"""
  name

  """column name"""
  pcp

  """column name"""
  phone

  """column name"""
  ssn
}

"""
input type for updating data in table "patient"
"""
input patient_set_input {
  address: String
  insuranceid: bigint
  name: String
  pcp: bigint
  phone: String
  ssn: bigint
}

"""aggregate stddev on columns"""
type patient_stddev_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by stddev() on columns of table "patient"
"""
input patient_stddev_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""aggregate stddev_pop on columns"""
type patient_stddev_pop_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by stddev_pop() on columns of table "patient"
"""
input patient_stddev_pop_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""aggregate stddev_samp on columns"""
type patient_stddev_samp_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by stddev_samp() on columns of table "patient"
"""
input patient_stddev_samp_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""aggregate sum on columns"""
type patient_sum_fields {
  insuranceid: bigint
  pcp: bigint
  ssn: bigint
}

"""
order by sum() on columns of table "patient"
"""
input patient_sum_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""
update columns of table "patient"
"""
enum patient_update_column {
  """column name"""
  address

  """column name"""
  insuranceid

  """column name"""
  name

  """column name"""
  pcp

  """column name"""
  phone

  """column name"""
  ssn
}

"""aggregate var_pop on columns"""
type patient_var_pop_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by var_pop() on columns of table "patient"
"""
input patient_var_pop_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""aggregate var_samp on columns"""
type patient_var_samp_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by var_samp() on columns of table "patient"
"""
input patient_var_samp_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""aggregate variance on columns"""
type patient_variance_fields {
  insuranceid: Float
  pcp: Float
  ssn: Float
}

"""
order by variance() on columns of table "patient"
"""
input patient_variance_order_by {
  insuranceid: order_by
  pcp: order_by
  ssn: order_by
}

"""
columns and relationships of "physician"
"""
type physician {
  """An array relationship"""
  affiliated_withs(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): [affiliated_with!]!

  """An aggregated array relationship"""
  affiliated_withs_aggregate(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): affiliated_with_aggregate!

  """An array relationship"""
  appointments(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): [appointment!]!

  """An aggregated array relationship"""
  appointments_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): appointment_aggregate!

  """An array relationship"""
  departments(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): [department!]!

  """An aggregated array relationship"""
  departments_aggregate(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): department_aggregate!
  employeeid: bigint!
  name: String

  """An array relationship"""
  patients(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!

  """An aggregated array relationship"""
  patients_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!
  position: String

  """An array relationship"""
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """An aggregated array relationship"""
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!
  ssn: bigint

  """An array relationship"""
  trained_ins(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): [trained_in!]!

  """An aggregated array relationship"""
  trained_ins_aggregate(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): trained_in_aggregate!

  """An array relationship"""
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """An aggregated array relationship"""
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

"""
aggregated selection of "physician"
"""
type physician_aggregate {
  aggregate: physician_aggregate_fields
  nodes: [physician!]!
}

"""
aggregate fields of "physician"
"""
type physician_aggregate_fields {
  avg: physician_avg_fields
  count(columns: [physician_select_column!], distinct: Boolean): Int
  max: physician_max_fields
  min: physician_min_fields
  stddev: physician_stddev_fields
  stddev_pop: physician_stddev_pop_fields
  stddev_samp: physician_stddev_samp_fields
  sum: physician_sum_fields
  var_pop: physician_var_pop_fields
  var_samp: physician_var_samp_fields
  variance: physician_variance_fields
}

"""
order by aggregate values of table "physician"
"""
input physician_aggregate_order_by {
  avg: physician_avg_order_by
  count: order_by
  max: physician_max_order_by
  min: physician_min_order_by
  stddev: physician_stddev_order_by
  stddev_pop: physician_stddev_pop_order_by
  stddev_samp: physician_stddev_samp_order_by
  sum: physician_sum_order_by
  var_pop: physician_var_pop_order_by
  var_samp: physician_var_samp_order_by
  variance: physician_variance_order_by
}

"""
input type for inserting array relation for remote table "physician"
"""
input physician_arr_rel_insert_input {
  data: [physician_insert_input!]!
  on_conflict: physician_on_conflict
}

"""aggregate avg on columns"""
type physician_avg_fields {
  employeeid: Float
  ssn: Float
}

"""
order by avg() on columns of table "physician"
"""
input physician_avg_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
Boolean expression to filter rows from the table "physician". All fields are combined with a logical 'AND'.
"""
input physician_bool_exp {
  _and: [physician_bool_exp]
  _not: physician_bool_exp
  _or: [physician_bool_exp]
  affiliated_withs: affiliated_with_bool_exp
  appointments: appointment_bool_exp
  departments: department_bool_exp
  employeeid: bigint_comparison_exp
  name: String_comparison_exp
  patients: patient_bool_exp
  position: String_comparison_exp
  prescribes: prescribes_bool_exp
  ssn: bigint_comparison_exp
  trained_ins: trained_in_bool_exp
  undergoes: undergoes_bool_exp
}

"""
unique or primary key constraints on table "physician"
"""
enum physician_constraint {
  """unique or primary key constraint"""
  idx_17221_physician_pkey
}

"""
input type for incrementing integer column in table "physician"
"""
input physician_inc_input {
  employeeid: bigint
  ssn: bigint
}

"""
input type for inserting data into table "physician"
"""
input physician_insert_input {
  affiliated_withs: affiliated_with_arr_rel_insert_input
  appointments: appointment_arr_rel_insert_input
  departments: department_arr_rel_insert_input
  employeeid: bigint
  name: String
  patients: patient_arr_rel_insert_input
  position: String
  prescribes: prescribes_arr_rel_insert_input
  ssn: bigint
  trained_ins: trained_in_arr_rel_insert_input
  undergoes: undergoes_arr_rel_insert_input
}

"""aggregate max on columns"""
type physician_max_fields {
  employeeid: bigint
  name: String
  position: String
  ssn: bigint
}

"""
order by max() on columns of table "physician"
"""
input physician_max_order_by {
  employeeid: order_by
  name: order_by
  position: order_by
  ssn: order_by
}

"""aggregate min on columns"""
type physician_min_fields {
  employeeid: bigint
  name: String
  position: String
  ssn: bigint
}

"""
order by min() on columns of table "physician"
"""
input physician_min_order_by {
  employeeid: order_by
  name: order_by
  position: order_by
  ssn: order_by
}

"""
response of any mutation on the table "physician"
"""
type physician_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [physician!]!
}

"""
input type for inserting object relation for remote table "physician"
"""
input physician_obj_rel_insert_input {
  data: physician_insert_input!
  on_conflict: physician_on_conflict
}

"""
on conflict condition type for table "physician"
"""
input physician_on_conflict {
  constraint: physician_constraint!
  update_columns: [physician_update_column!]!
  where: physician_bool_exp
}

"""
ordering options when selecting data from "physician"
"""
input physician_order_by {
  affiliated_withs_aggregate: affiliated_with_aggregate_order_by
  appointments_aggregate: appointment_aggregate_order_by
  departments_aggregate: department_aggregate_order_by
  employeeid: order_by
  name: order_by
  patients_aggregate: patient_aggregate_order_by
  position: order_by
  prescribes_aggregate: prescribes_aggregate_order_by
  ssn: order_by
  trained_ins_aggregate: trained_in_aggregate_order_by
  undergoes_aggregate: undergoes_aggregate_order_by
}

"""
primary key columns input for table: "physician"
"""
input physician_pk_columns_input {
  employeeid: bigint!
}

"""
select columns of table "physician"
"""
enum physician_select_column {
  """column name"""
  employeeid

  """column name"""
  name

  """column name"""
  position

  """column name"""
  ssn
}

"""
input type for updating data in table "physician"
"""
input physician_set_input {
  employeeid: bigint
  name: String
  position: String
  ssn: bigint
}

"""aggregate stddev on columns"""
type physician_stddev_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev() on columns of table "physician"
"""
input physician_stddev_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate stddev_pop on columns"""
type physician_stddev_pop_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev_pop() on columns of table "physician"
"""
input physician_stddev_pop_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate stddev_samp on columns"""
type physician_stddev_samp_fields {
  employeeid: Float
  ssn: Float
}

"""
order by stddev_samp() on columns of table "physician"
"""
input physician_stddev_samp_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate sum on columns"""
type physician_sum_fields {
  employeeid: bigint
  ssn: bigint
}

"""
order by sum() on columns of table "physician"
"""
input physician_sum_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
update columns of table "physician"
"""
enum physician_update_column {
  """column name"""
  employeeid

  """column name"""
  name

  """column name"""
  position

  """column name"""
  ssn
}

"""aggregate var_pop on columns"""
type physician_var_pop_fields {
  employeeid: Float
  ssn: Float
}

"""
order by var_pop() on columns of table "physician"
"""
input physician_var_pop_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate var_samp on columns"""
type physician_var_samp_fields {
  employeeid: Float
  ssn: Float
}

"""
order by var_samp() on columns of table "physician"
"""
input physician_var_samp_order_by {
  employeeid: order_by
  ssn: order_by
}

"""aggregate variance on columns"""
type physician_variance_fields {
  employeeid: Float
  ssn: Float
}

"""
order by variance() on columns of table "physician"
"""
input physician_variance_order_by {
  employeeid: order_by
  ssn: order_by
}

"""
columns and relationships of "prescribes"
"""
type prescribes {
  appointment: bigint

  """An object relationship"""
  appointmentByAppointment: appointment
  date: timestamptz
  dose: String
  medication: bigint

  """An object relationship"""
  medicationByMedication: medication
  patient: bigint

  """An object relationship"""
  patientByPatient: patient
  physician: bigint

  """An object relationship"""
  physicianByPhysician: physician
}

"""
aggregated selection of "prescribes"
"""
type prescribes_aggregate {
  aggregate: prescribes_aggregate_fields
  nodes: [prescribes!]!
}

"""
aggregate fields of "prescribes"
"""
type prescribes_aggregate_fields {
  avg: prescribes_avg_fields
  count(columns: [prescribes_select_column!], distinct: Boolean): Int
  max: prescribes_max_fields
  min: prescribes_min_fields
  stddev: prescribes_stddev_fields
  stddev_pop: prescribes_stddev_pop_fields
  stddev_samp: prescribes_stddev_samp_fields
  sum: prescribes_sum_fields
  var_pop: prescribes_var_pop_fields
  var_samp: prescribes_var_samp_fields
  variance: prescribes_variance_fields
}

"""
order by aggregate values of table "prescribes"
"""
input prescribes_aggregate_order_by {
  avg: prescribes_avg_order_by
  count: order_by
  max: prescribes_max_order_by
  min: prescribes_min_order_by
  stddev: prescribes_stddev_order_by
  stddev_pop: prescribes_stddev_pop_order_by
  stddev_samp: prescribes_stddev_samp_order_by
  sum: prescribes_sum_order_by
  var_pop: prescribes_var_pop_order_by
  var_samp: prescribes_var_samp_order_by
  variance: prescribes_variance_order_by
}

"""
input type for inserting array relation for remote table "prescribes"
"""
input prescribes_arr_rel_insert_input {
  data: [prescribes_insert_input!]!
  on_conflict: prescribes_on_conflict
}

"""aggregate avg on columns"""
type prescribes_avg_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by avg() on columns of table "prescribes"
"""
input prescribes_avg_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""
Boolean expression to filter rows from the table "prescribes". All fields are combined with a logical 'AND'.
"""
input prescribes_bool_exp {
  _and: [prescribes_bool_exp]
  _not: prescribes_bool_exp
  _or: [prescribes_bool_exp]
  appointment: bigint_comparison_exp
  appointmentByAppointment: appointment_bool_exp
  date: timestamptz_comparison_exp
  dose: String_comparison_exp
  medication: bigint_comparison_exp
  medicationByMedication: medication_bool_exp
  patient: bigint_comparison_exp
  patientByPatient: patient_bool_exp
  physician: bigint_comparison_exp
  physicianByPhysician: physician_bool_exp
}

"""
unique or primary key constraints on table "prescribes"
"""
enum prescribes_constraint {
  """unique or primary key constraint"""
  idx_17269_sqlite_autoindex_prescribes_1
}

"""
input type for incrementing integer column in table "prescribes"
"""
input prescribes_inc_input {
  appointment: bigint
  medication: bigint
  patient: bigint
  physician: bigint
}

"""
input type for inserting data into table "prescribes"
"""
input prescribes_insert_input {
  appointment: bigint
  appointmentByAppointment: appointment_obj_rel_insert_input
  date: timestamptz
  dose: String
  medication: bigint
  medicationByMedication: medication_obj_rel_insert_input
  patient: bigint
  patientByPatient: patient_obj_rel_insert_input
  physician: bigint
  physicianByPhysician: physician_obj_rel_insert_input
}

"""aggregate max on columns"""
type prescribes_max_fields {
  appointment: bigint
  date: timestamptz
  dose: String
  medication: bigint
  patient: bigint
  physician: bigint
}

"""
order by max() on columns of table "prescribes"
"""
input prescribes_max_order_by {
  appointment: order_by
  date: order_by
  dose: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate min on columns"""
type prescribes_min_fields {
  appointment: bigint
  date: timestamptz
  dose: String
  medication: bigint
  patient: bigint
  physician: bigint
}

"""
order by min() on columns of table "prescribes"
"""
input prescribes_min_order_by {
  appointment: order_by
  date: order_by
  dose: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""
response of any mutation on the table "prescribes"
"""
type prescribes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [prescribes!]!
}

"""
input type for inserting object relation for remote table "prescribes"
"""
input prescribes_obj_rel_insert_input {
  data: prescribes_insert_input!
  on_conflict: prescribes_on_conflict
}

"""
on conflict condition type for table "prescribes"
"""
input prescribes_on_conflict {
  constraint: prescribes_constraint!
  update_columns: [prescribes_update_column!]!
  where: prescribes_bool_exp
}

"""
ordering options when selecting data from "prescribes"
"""
input prescribes_order_by {
  appointment: order_by
  appointmentByAppointment: appointment_order_by
  date: order_by
  dose: order_by
  medication: order_by
  medicationByMedication: medication_order_by
  patient: order_by
  patientByPatient: patient_order_by
  physician: order_by
  physicianByPhysician: physician_order_by
}

"""
select columns of table "prescribes"
"""
enum prescribes_select_column {
  """column name"""
  appointment

  """column name"""
  date

  """column name"""
  dose

  """column name"""
  medication

  """column name"""
  patient

  """column name"""
  physician
}

"""
input type for updating data in table "prescribes"
"""
input prescribes_set_input {
  appointment: bigint
  date: timestamptz
  dose: String
  medication: bigint
  patient: bigint
  physician: bigint
}

"""aggregate stddev on columns"""
type prescribes_stddev_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by stddev() on columns of table "prescribes"
"""
input prescribes_stddev_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate stddev_pop on columns"""
type prescribes_stddev_pop_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by stddev_pop() on columns of table "prescribes"
"""
input prescribes_stddev_pop_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate stddev_samp on columns"""
type prescribes_stddev_samp_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by stddev_samp() on columns of table "prescribes"
"""
input prescribes_stddev_samp_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate sum on columns"""
type prescribes_sum_fields {
  appointment: bigint
  medication: bigint
  patient: bigint
  physician: bigint
}

"""
order by sum() on columns of table "prescribes"
"""
input prescribes_sum_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""
update columns of table "prescribes"
"""
enum prescribes_update_column {
  """column name"""
  appointment

  """column name"""
  date

  """column name"""
  dose

  """column name"""
  medication

  """column name"""
  patient

  """column name"""
  physician
}

"""aggregate var_pop on columns"""
type prescribes_var_pop_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by var_pop() on columns of table "prescribes"
"""
input prescribes_var_pop_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate var_samp on columns"""
type prescribes_var_samp_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by var_samp() on columns of table "prescribes"
"""
input prescribes_var_samp_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""aggregate variance on columns"""
type prescribes_variance_fields {
  appointment: Float
  medication: Float
  patient: Float
  physician: Float
}

"""
order by variance() on columns of table "prescribes"
"""
input prescribes_variance_order_by {
  appointment: order_by
  medication: order_by
  patient: order_by
  physician: order_by
}

"""
columns and relationships of "procedures"
"""
type procedures {
  code: bigint!
  cost: Float
  name: String

  """An array relationship"""
  trained_ins(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): [trained_in!]!

  """An aggregated array relationship"""
  trained_ins_aggregate(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): trained_in_aggregate!

  """An array relationship"""
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """An aggregated array relationship"""
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

"""
aggregated selection of "procedures"
"""
type procedures_aggregate {
  aggregate: procedures_aggregate_fields
  nodes: [procedures!]!
}

"""
aggregate fields of "procedures"
"""
type procedures_aggregate_fields {
  avg: procedures_avg_fields
  count(columns: [procedures_select_column!], distinct: Boolean): Int
  max: procedures_max_fields
  min: procedures_min_fields
  stddev: procedures_stddev_fields
  stddev_pop: procedures_stddev_pop_fields
  stddev_samp: procedures_stddev_samp_fields
  sum: procedures_sum_fields
  var_pop: procedures_var_pop_fields
  var_samp: procedures_var_samp_fields
  variance: procedures_variance_fields
}

"""
order by aggregate values of table "procedures"
"""
input procedures_aggregate_order_by {
  avg: procedures_avg_order_by
  count: order_by
  max: procedures_max_order_by
  min: procedures_min_order_by
  stddev: procedures_stddev_order_by
  stddev_pop: procedures_stddev_pop_order_by
  stddev_samp: procedures_stddev_samp_order_by
  sum: procedures_sum_order_by
  var_pop: procedures_var_pop_order_by
  var_samp: procedures_var_samp_order_by
  variance: procedures_variance_order_by
}

"""
input type for inserting array relation for remote table "procedures"
"""
input procedures_arr_rel_insert_input {
  data: [procedures_insert_input!]!
  on_conflict: procedures_on_conflict
}

"""aggregate avg on columns"""
type procedures_avg_fields {
  code: Float
  cost: Float
}

"""
order by avg() on columns of table "procedures"
"""
input procedures_avg_order_by {
  code: order_by
  cost: order_by
}

"""
Boolean expression to filter rows from the table "procedures". All fields are combined with a logical 'AND'.
"""
input procedures_bool_exp {
  _and: [procedures_bool_exp]
  _not: procedures_bool_exp
  _or: [procedures_bool_exp]
  code: bigint_comparison_exp
  cost: Float_comparison_exp
  name: String_comparison_exp
  trained_ins: trained_in_bool_exp
  undergoes: undergoes_bool_exp
}

"""
unique or primary key constraints on table "procedures"
"""
enum procedures_constraint {
  """unique or primary key constraint"""
  idx_17236_procedures_pkey
}

"""
input type for incrementing integer column in table "procedures"
"""
input procedures_inc_input {
  code: bigint
  cost: Float
}

"""
input type for inserting data into table "procedures"
"""
input procedures_insert_input {
  code: bigint
  cost: Float
  name: String
  trained_ins: trained_in_arr_rel_insert_input
  undergoes: undergoes_arr_rel_insert_input
}

"""aggregate max on columns"""
type procedures_max_fields {
  code: bigint
  cost: Float
  name: String
}

"""
order by max() on columns of table "procedures"
"""
input procedures_max_order_by {
  code: order_by
  cost: order_by
  name: order_by
}

"""aggregate min on columns"""
type procedures_min_fields {
  code: bigint
  cost: Float
  name: String
}

"""
order by min() on columns of table "procedures"
"""
input procedures_min_order_by {
  code: order_by
  cost: order_by
  name: order_by
}

"""
response of any mutation on the table "procedures"
"""
type procedures_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [procedures!]!
}

"""
input type for inserting object relation for remote table "procedures"
"""
input procedures_obj_rel_insert_input {
  data: procedures_insert_input!
  on_conflict: procedures_on_conflict
}

"""
on conflict condition type for table "procedures"
"""
input procedures_on_conflict {
  constraint: procedures_constraint!
  update_columns: [procedures_update_column!]!
  where: procedures_bool_exp
}

"""
ordering options when selecting data from "procedures"
"""
input procedures_order_by {
  code: order_by
  cost: order_by
  name: order_by
  trained_ins_aggregate: trained_in_aggregate_order_by
  undergoes_aggregate: undergoes_aggregate_order_by
}

"""
primary key columns input for table: "procedures"
"""
input procedures_pk_columns_input {
  code: bigint!
}

"""
select columns of table "procedures"
"""
enum procedures_select_column {
  """column name"""
  code

  """column name"""
  cost

  """column name"""
  name
}

"""
input type for updating data in table "procedures"
"""
input procedures_set_input {
  code: bigint
  cost: Float
  name: String
}

"""aggregate stddev on columns"""
type procedures_stddev_fields {
  code: Float
  cost: Float
}

"""
order by stddev() on columns of table "procedures"
"""
input procedures_stddev_order_by {
  code: order_by
  cost: order_by
}

"""aggregate stddev_pop on columns"""
type procedures_stddev_pop_fields {
  code: Float
  cost: Float
}

"""
order by stddev_pop() on columns of table "procedures"
"""
input procedures_stddev_pop_order_by {
  code: order_by
  cost: order_by
}

"""aggregate stddev_samp on columns"""
type procedures_stddev_samp_fields {
  code: Float
  cost: Float
}

"""
order by stddev_samp() on columns of table "procedures"
"""
input procedures_stddev_samp_order_by {
  code: order_by
  cost: order_by
}

"""aggregate sum on columns"""
type procedures_sum_fields {
  code: bigint
  cost: Float
}

"""
order by sum() on columns of table "procedures"
"""
input procedures_sum_order_by {
  code: order_by
  cost: order_by
}

"""
update columns of table "procedures"
"""
enum procedures_update_column {
  """column name"""
  code

  """column name"""
  cost

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type procedures_var_pop_fields {
  code: Float
  cost: Float
}

"""
order by var_pop() on columns of table "procedures"
"""
input procedures_var_pop_order_by {
  code: order_by
  cost: order_by
}

"""aggregate var_samp on columns"""
type procedures_var_samp_fields {
  code: Float
  cost: Float
}

"""
order by var_samp() on columns of table "procedures"
"""
input procedures_var_samp_order_by {
  code: order_by
  cost: order_by
}

"""aggregate variance on columns"""
type procedures_variance_fields {
  code: Float
  cost: Float
}

"""
order by variance() on columns of table "procedures"
"""
input procedures_variance_order_by {
  code: order_by
  cost: order_by
}

"""query root"""
type query_root {
  """
  fetch data from the table: "affiliated_with"
  """
  affiliated_with(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): [affiliated_with!]!

  """
  fetch aggregated fields from the table: "affiliated_with"
  """
  affiliated_with_aggregate(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): affiliated_with_aggregate!

  """fetch data from the table: "affiliated_with" using primary key columns"""
  affiliated_with_by_pk(department: bigint!, physician: bigint!): affiliated_with

  """
  fetch data from the table: "appointment"
  """
  appointment(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): [appointment!]!

  """
  fetch aggregated fields from the table: "appointment"
  """
  appointment_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): appointment_aggregate!

  """fetch data from the table: "appointment" using primary key columns"""
  appointment_by_pk(appointmentid: bigint!): appointment

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(blockcode: bigint!, blockfloor: bigint!): block

  """
  fetch data from the table: "department"
  """
  department(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): [department!]!

  """
  fetch aggregated fields from the table: "department"
  """
  department_aggregate(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): department_aggregate!

  """fetch data from the table: "department" using primary key columns"""
  department_by_pk(departmentid: bigint!): department

  """
  fetch data from the table: "medication"
  """
  medication(
    """distinct select on columns"""
    distinct_on: [medication_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [medication_order_by!]

    """filter the rows returned"""
    where: medication_bool_exp
  ): [medication!]!

  """
  fetch aggregated fields from the table: "medication"
  """
  medication_aggregate(
    """distinct select on columns"""
    distinct_on: [medication_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [medication_order_by!]

    """filter the rows returned"""
    where: medication_bool_exp
  ): medication_aggregate!

  """fetch data from the table: "medication" using primary key columns"""
  medication_by_pk(code: bigint!): medication

  """
  fetch data from the table: "nurse"
  """
  nurse(
    """distinct select on columns"""
    distinct_on: [nurse_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nurse_order_by!]

    """filter the rows returned"""
    where: nurse_bool_exp
  ): [nurse!]!

  """
  fetch aggregated fields from the table: "nurse"
  """
  nurse_aggregate(
    """distinct select on columns"""
    distinct_on: [nurse_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nurse_order_by!]

    """filter the rows returned"""
    where: nurse_bool_exp
  ): nurse_aggregate!

  """fetch data from the table: "nurse" using primary key columns"""
  nurse_by_pk(employeeid: bigint!): nurse

  """
  fetch data from the table: "on_call"
  """
  on_call(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): [on_call!]!

  """
  fetch aggregated fields from the table: "on_call"
  """
  on_call_aggregate(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): on_call_aggregate!

  """
  fetch data from the table: "patient"
  """
  patient(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!

  """
  fetch aggregated fields from the table: "patient"
  """
  patient_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!

  """fetch data from the table: "patient" using primary key columns"""
  patient_by_pk(ssn: bigint!): patient

  """
  fetch data from the table: "physician"
  """
  physician(
    """distinct select on columns"""
    distinct_on: [physician_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [physician_order_by!]

    """filter the rows returned"""
    where: physician_bool_exp
  ): [physician!]!

  """
  fetch aggregated fields from the table: "physician"
  """
  physician_aggregate(
    """distinct select on columns"""
    distinct_on: [physician_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [physician_order_by!]

    """filter the rows returned"""
    where: physician_bool_exp
  ): physician_aggregate!

  """fetch data from the table: "physician" using primary key columns"""
  physician_by_pk(employeeid: bigint!): physician

  """
  fetch data from the table: "prescribes"
  """
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """
  fetch aggregated fields from the table: "prescribes"
  """
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!

  """
  fetch data from the table: "procedures"
  """
  procedures(
    """distinct select on columns"""
    distinct_on: [procedures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [procedures_order_by!]

    """filter the rows returned"""
    where: procedures_bool_exp
  ): [procedures!]!

  """
  fetch aggregated fields from the table: "procedures"
  """
  procedures_aggregate(
    """distinct select on columns"""
    distinct_on: [procedures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [procedures_order_by!]

    """filter the rows returned"""
    where: procedures_bool_exp
  ): procedures_aggregate!

  """fetch data from the table: "procedures" using primary key columns"""
  procedures_by_pk(code: bigint!): procedures

  """
  fetch data from the table: "room"
  """
  room(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!

  """fetch data from the table: "room" using primary key columns"""
  room_by_pk(roomnumber: bigint!): room

  """
  fetch data from the table: "stay"
  """
  stay(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): [stay!]!

  """
  fetch aggregated fields from the table: "stay"
  """
  stay_aggregate(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): stay_aggregate!

  """fetch data from the table: "stay" using primary key columns"""
  stay_by_pk(stayid: bigint!): stay

  """
  fetch data from the table: "trained_in"
  """
  trained_in(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): [trained_in!]!

  """
  fetch aggregated fields from the table: "trained_in"
  """
  trained_in_aggregate(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): trained_in_aggregate!

  """fetch data from the table: "trained_in" using primary key columns"""
  trained_in_by_pk(physician: bigint!, treatment: bigint!): trained_in

  """
  fetch data from the table: "undergoes"
  """
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """
  fetch aggregated fields from the table: "undergoes"
  """
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

"""
columns and relationships of "room"
"""
type room {
  """An object relationship"""
  block: block
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint!
  roomtype: String

  """An array relationship"""
  stays(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): [stay!]!

  """An aggregated array relationship"""
  stays_aggregate(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): stay_aggregate!
  unavailable: Boolean
}

"""
aggregated selection of "room"
"""
type room_aggregate {
  aggregate: room_aggregate_fields
  nodes: [room!]!
}

"""
aggregate fields of "room"
"""
type room_aggregate_fields {
  avg: room_avg_fields
  count(columns: [room_select_column!], distinct: Boolean): Int
  max: room_max_fields
  min: room_min_fields
  stddev: room_stddev_fields
  stddev_pop: room_stddev_pop_fields
  stddev_samp: room_stddev_samp_fields
  sum: room_sum_fields
  var_pop: room_var_pop_fields
  var_samp: room_var_samp_fields
  variance: room_variance_fields
}

"""
order by aggregate values of table "room"
"""
input room_aggregate_order_by {
  avg: room_avg_order_by
  count: order_by
  max: room_max_order_by
  min: room_min_order_by
  stddev: room_stddev_order_by
  stddev_pop: room_stddev_pop_order_by
  stddev_samp: room_stddev_samp_order_by
  sum: room_sum_order_by
  var_pop: room_var_pop_order_by
  var_samp: room_var_samp_order_by
  variance: room_variance_order_by
}

"""
input type for inserting array relation for remote table "room"
"""
input room_arr_rel_insert_input {
  data: [room_insert_input!]!
  on_conflict: room_on_conflict
}

"""aggregate avg on columns"""
type room_avg_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by avg() on columns of table "room"
"""
input room_avg_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""
Boolean expression to filter rows from the table "room". All fields are combined with a logical 'AND'.
"""
input room_bool_exp {
  _and: [room_bool_exp]
  _not: room_bool_exp
  _or: [room_bool_exp]
  block: block_bool_exp
  blockcode: bigint_comparison_exp
  blockfloor: bigint_comparison_exp
  roomnumber: bigint_comparison_exp
  roomtype: String_comparison_exp
  stays: stay_bool_exp
  unavailable: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "room"
"""
enum room_constraint {
  """unique or primary key constraint"""
  idx_17278_room_pkey
}

"""
input type for incrementing integer column in table "room"
"""
input room_inc_input {
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
}

"""
input type for inserting data into table "room"
"""
input room_insert_input {
  block: block_obj_rel_insert_input
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
  roomtype: String
  stays: stay_arr_rel_insert_input
  unavailable: Boolean
}

"""aggregate max on columns"""
type room_max_fields {
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
  roomtype: String
}

"""
order by max() on columns of table "room"
"""
input room_max_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
  roomtype: order_by
}

"""aggregate min on columns"""
type room_min_fields {
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
  roomtype: String
}

"""
order by min() on columns of table "room"
"""
input room_min_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
  roomtype: order_by
}

"""
response of any mutation on the table "room"
"""
type room_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [room!]!
}

"""
input type for inserting object relation for remote table "room"
"""
input room_obj_rel_insert_input {
  data: room_insert_input!
  on_conflict: room_on_conflict
}

"""
on conflict condition type for table "room"
"""
input room_on_conflict {
  constraint: room_constraint!
  update_columns: [room_update_column!]!
  where: room_bool_exp
}

"""
ordering options when selecting data from "room"
"""
input room_order_by {
  block: block_order_by
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
  roomtype: order_by
  stays_aggregate: stay_aggregate_order_by
  unavailable: order_by
}

"""
primary key columns input for table: "room"
"""
input room_pk_columns_input {
  roomnumber: bigint!
}

"""
select columns of table "room"
"""
enum room_select_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor

  """column name"""
  roomnumber

  """column name"""
  roomtype

  """column name"""
  unavailable
}

"""
input type for updating data in table "room"
"""
input room_set_input {
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
  roomtype: String
  unavailable: Boolean
}

"""aggregate stddev on columns"""
type room_stddev_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by stddev() on columns of table "room"
"""
input room_stddev_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""aggregate stddev_pop on columns"""
type room_stddev_pop_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by stddev_pop() on columns of table "room"
"""
input room_stddev_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""aggregate stddev_samp on columns"""
type room_stddev_samp_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by stddev_samp() on columns of table "room"
"""
input room_stddev_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""aggregate sum on columns"""
type room_sum_fields {
  blockcode: bigint
  blockfloor: bigint
  roomnumber: bigint
}

"""
order by sum() on columns of table "room"
"""
input room_sum_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""
update columns of table "room"
"""
enum room_update_column {
  """column name"""
  blockcode

  """column name"""
  blockfloor

  """column name"""
  roomnumber

  """column name"""
  roomtype

  """column name"""
  unavailable
}

"""aggregate var_pop on columns"""
type room_var_pop_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by var_pop() on columns of table "room"
"""
input room_var_pop_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""aggregate var_samp on columns"""
type room_var_samp_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by var_samp() on columns of table "room"
"""
input room_var_samp_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""aggregate variance on columns"""
type room_variance_fields {
  blockcode: Float
  blockfloor: Float
  roomnumber: Float
}

"""
order by variance() on columns of table "room"
"""
input room_variance_order_by {
  blockcode: order_by
  blockfloor: order_by
  roomnumber: order_by
}

"""
columns and relationships of "stay"
"""
type stay {
  patient: bigint

  """An object relationship"""
  patientByPatient: patient
  room: bigint

  """An object relationship"""
  roomByRoom: room
  stayend: timestamptz
  stayid: bigint!
  staystart: timestamptz

  """An array relationship"""
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """An aggregated array relationship"""
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

"""
aggregated selection of "stay"
"""
type stay_aggregate {
  aggregate: stay_aggregate_fields
  nodes: [stay!]!
}

"""
aggregate fields of "stay"
"""
type stay_aggregate_fields {
  avg: stay_avg_fields
  count(columns: [stay_select_column!], distinct: Boolean): Int
  max: stay_max_fields
  min: stay_min_fields
  stddev: stay_stddev_fields
  stddev_pop: stay_stddev_pop_fields
  stddev_samp: stay_stddev_samp_fields
  sum: stay_sum_fields
  var_pop: stay_var_pop_fields
  var_samp: stay_var_samp_fields
  variance: stay_variance_fields
}

"""
order by aggregate values of table "stay"
"""
input stay_aggregate_order_by {
  avg: stay_avg_order_by
  count: order_by
  max: stay_max_order_by
  min: stay_min_order_by
  stddev: stay_stddev_order_by
  stddev_pop: stay_stddev_pop_order_by
  stddev_samp: stay_stddev_samp_order_by
  sum: stay_sum_order_by
  var_pop: stay_var_pop_order_by
  var_samp: stay_var_samp_order_by
  variance: stay_variance_order_by
}

"""
input type for inserting array relation for remote table "stay"
"""
input stay_arr_rel_insert_input {
  data: [stay_insert_input!]!
  on_conflict: stay_on_conflict
}

"""aggregate avg on columns"""
type stay_avg_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by avg() on columns of table "stay"
"""
input stay_avg_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""
Boolean expression to filter rows from the table "stay". All fields are combined with a logical 'AND'.
"""
input stay_bool_exp {
  _and: [stay_bool_exp]
  _not: stay_bool_exp
  _or: [stay_bool_exp]
  patient: bigint_comparison_exp
  patientByPatient: patient_bool_exp
  room: bigint_comparison_exp
  roomByRoom: room_bool_exp
  stayend: timestamptz_comparison_exp
  stayid: bigint_comparison_exp
  staystart: timestamptz_comparison_exp
  undergoes: undergoes_bool_exp
}

"""
unique or primary key constraints on table "stay"
"""
enum stay_constraint {
  """unique or primary key constraint"""
  idx_17287_stay_pkey
}

"""
input type for incrementing integer column in table "stay"
"""
input stay_inc_input {
  patient: bigint
  room: bigint
  stayid: bigint
}

"""
input type for inserting data into table "stay"
"""
input stay_insert_input {
  patient: bigint
  patientByPatient: patient_obj_rel_insert_input
  room: bigint
  roomByRoom: room_obj_rel_insert_input
  stayend: timestamptz
  stayid: bigint
  staystart: timestamptz
  undergoes: undergoes_arr_rel_insert_input
}

"""aggregate max on columns"""
type stay_max_fields {
  patient: bigint
  room: bigint
  stayend: timestamptz
  stayid: bigint
  staystart: timestamptz
}

"""
order by max() on columns of table "stay"
"""
input stay_max_order_by {
  patient: order_by
  room: order_by
  stayend: order_by
  stayid: order_by
  staystart: order_by
}

"""aggregate min on columns"""
type stay_min_fields {
  patient: bigint
  room: bigint
  stayend: timestamptz
  stayid: bigint
  staystart: timestamptz
}

"""
order by min() on columns of table "stay"
"""
input stay_min_order_by {
  patient: order_by
  room: order_by
  stayend: order_by
  stayid: order_by
  staystart: order_by
}

"""
response of any mutation on the table "stay"
"""
type stay_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [stay!]!
}

"""
input type for inserting object relation for remote table "stay"
"""
input stay_obj_rel_insert_input {
  data: stay_insert_input!
  on_conflict: stay_on_conflict
}

"""
on conflict condition type for table "stay"
"""
input stay_on_conflict {
  constraint: stay_constraint!
  update_columns: [stay_update_column!]!
  where: stay_bool_exp
}

"""
ordering options when selecting data from "stay"
"""
input stay_order_by {
  patient: order_by
  patientByPatient: patient_order_by
  room: order_by
  roomByRoom: room_order_by
  stayend: order_by
  stayid: order_by
  staystart: order_by
  undergoes_aggregate: undergoes_aggregate_order_by
}

"""
primary key columns input for table: "stay"
"""
input stay_pk_columns_input {
  stayid: bigint!
}

"""
select columns of table "stay"
"""
enum stay_select_column {
  """column name"""
  patient

  """column name"""
  room

  """column name"""
  stayend

  """column name"""
  stayid

  """column name"""
  staystart
}

"""
input type for updating data in table "stay"
"""
input stay_set_input {
  patient: bigint
  room: bigint
  stayend: timestamptz
  stayid: bigint
  staystart: timestamptz
}

"""aggregate stddev on columns"""
type stay_stddev_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by stddev() on columns of table "stay"
"""
input stay_stddev_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""aggregate stddev_pop on columns"""
type stay_stddev_pop_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by stddev_pop() on columns of table "stay"
"""
input stay_stddev_pop_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""aggregate stddev_samp on columns"""
type stay_stddev_samp_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by stddev_samp() on columns of table "stay"
"""
input stay_stddev_samp_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""aggregate sum on columns"""
type stay_sum_fields {
  patient: bigint
  room: bigint
  stayid: bigint
}

"""
order by sum() on columns of table "stay"
"""
input stay_sum_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""
update columns of table "stay"
"""
enum stay_update_column {
  """column name"""
  patient

  """column name"""
  room

  """column name"""
  stayend

  """column name"""
  stayid

  """column name"""
  staystart
}

"""aggregate var_pop on columns"""
type stay_var_pop_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by var_pop() on columns of table "stay"
"""
input stay_var_pop_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""aggregate var_samp on columns"""
type stay_var_samp_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by var_samp() on columns of table "stay"
"""
input stay_var_samp_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""aggregate variance on columns"""
type stay_variance_fields {
  patient: Float
  room: Float
  stayid: Float
}

"""
order by variance() on columns of table "stay"
"""
input stay_variance_order_by {
  patient: order_by
  room: order_by
  stayid: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "affiliated_with"
  """
  affiliated_with(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): [affiliated_with!]!

  """
  fetch aggregated fields from the table: "affiliated_with"
  """
  affiliated_with_aggregate(
    """distinct select on columns"""
    distinct_on: [affiliated_with_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [affiliated_with_order_by!]

    """filter the rows returned"""
    where: affiliated_with_bool_exp
  ): affiliated_with_aggregate!

  """fetch data from the table: "affiliated_with" using primary key columns"""
  affiliated_with_by_pk(department: bigint!, physician: bigint!): affiliated_with

  """
  fetch data from the table: "appointment"
  """
  appointment(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): [appointment!]!

  """
  fetch aggregated fields from the table: "appointment"
  """
  appointment_aggregate(
    """distinct select on columns"""
    distinct_on: [appointment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [appointment_order_by!]

    """filter the rows returned"""
    where: appointment_bool_exp
  ): appointment_aggregate!

  """fetch data from the table: "appointment" using primary key columns"""
  appointment_by_pk(appointmentid: bigint!): appointment

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(blockcode: bigint!, blockfloor: bigint!): block

  """
  fetch data from the table: "department"
  """
  department(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): [department!]!

  """
  fetch aggregated fields from the table: "department"
  """
  department_aggregate(
    """distinct select on columns"""
    distinct_on: [department_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [department_order_by!]

    """filter the rows returned"""
    where: department_bool_exp
  ): department_aggregate!

  """fetch data from the table: "department" using primary key columns"""
  department_by_pk(departmentid: bigint!): department

  """
  fetch data from the table: "medication"
  """
  medication(
    """distinct select on columns"""
    distinct_on: [medication_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [medication_order_by!]

    """filter the rows returned"""
    where: medication_bool_exp
  ): [medication!]!

  """
  fetch aggregated fields from the table: "medication"
  """
  medication_aggregate(
    """distinct select on columns"""
    distinct_on: [medication_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [medication_order_by!]

    """filter the rows returned"""
    where: medication_bool_exp
  ): medication_aggregate!

  """fetch data from the table: "medication" using primary key columns"""
  medication_by_pk(code: bigint!): medication

  """
  fetch data from the table: "nurse"
  """
  nurse(
    """distinct select on columns"""
    distinct_on: [nurse_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nurse_order_by!]

    """filter the rows returned"""
    where: nurse_bool_exp
  ): [nurse!]!

  """
  fetch aggregated fields from the table: "nurse"
  """
  nurse_aggregate(
    """distinct select on columns"""
    distinct_on: [nurse_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nurse_order_by!]

    """filter the rows returned"""
    where: nurse_bool_exp
  ): nurse_aggregate!

  """fetch data from the table: "nurse" using primary key columns"""
  nurse_by_pk(employeeid: bigint!): nurse

  """
  fetch data from the table: "on_call"
  """
  on_call(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): [on_call!]!

  """
  fetch aggregated fields from the table: "on_call"
  """
  on_call_aggregate(
    """distinct select on columns"""
    distinct_on: [on_call_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [on_call_order_by!]

    """filter the rows returned"""
    where: on_call_bool_exp
  ): on_call_aggregate!

  """
  fetch data from the table: "patient"
  """
  patient(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): [patient!]!

  """
  fetch aggregated fields from the table: "patient"
  """
  patient_aggregate(
    """distinct select on columns"""
    distinct_on: [patient_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [patient_order_by!]

    """filter the rows returned"""
    where: patient_bool_exp
  ): patient_aggregate!

  """fetch data from the table: "patient" using primary key columns"""
  patient_by_pk(ssn: bigint!): patient

  """
  fetch data from the table: "physician"
  """
  physician(
    """distinct select on columns"""
    distinct_on: [physician_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [physician_order_by!]

    """filter the rows returned"""
    where: physician_bool_exp
  ): [physician!]!

  """
  fetch aggregated fields from the table: "physician"
  """
  physician_aggregate(
    """distinct select on columns"""
    distinct_on: [physician_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [physician_order_by!]

    """filter the rows returned"""
    where: physician_bool_exp
  ): physician_aggregate!

  """fetch data from the table: "physician" using primary key columns"""
  physician_by_pk(employeeid: bigint!): physician

  """
  fetch data from the table: "prescribes"
  """
  prescribes(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): [prescribes!]!

  """
  fetch aggregated fields from the table: "prescribes"
  """
  prescribes_aggregate(
    """distinct select on columns"""
    distinct_on: [prescribes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [prescribes_order_by!]

    """filter the rows returned"""
    where: prescribes_bool_exp
  ): prescribes_aggregate!

  """
  fetch data from the table: "procedures"
  """
  procedures(
    """distinct select on columns"""
    distinct_on: [procedures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [procedures_order_by!]

    """filter the rows returned"""
    where: procedures_bool_exp
  ): [procedures!]!

  """
  fetch aggregated fields from the table: "procedures"
  """
  procedures_aggregate(
    """distinct select on columns"""
    distinct_on: [procedures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [procedures_order_by!]

    """filter the rows returned"""
    where: procedures_bool_exp
  ): procedures_aggregate!

  """fetch data from the table: "procedures" using primary key columns"""
  procedures_by_pk(code: bigint!): procedures

  """
  fetch data from the table: "room"
  """
  room(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!

  """fetch data from the table: "room" using primary key columns"""
  room_by_pk(roomnumber: bigint!): room

  """
  fetch data from the table: "stay"
  """
  stay(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): [stay!]!

  """
  fetch aggregated fields from the table: "stay"
  """
  stay_aggregate(
    """distinct select on columns"""
    distinct_on: [stay_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [stay_order_by!]

    """filter the rows returned"""
    where: stay_bool_exp
  ): stay_aggregate!

  """fetch data from the table: "stay" using primary key columns"""
  stay_by_pk(stayid: bigint!): stay

  """
  fetch data from the table: "trained_in"
  """
  trained_in(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): [trained_in!]!

  """
  fetch aggregated fields from the table: "trained_in"
  """
  trained_in_aggregate(
    """distinct select on columns"""
    distinct_on: [trained_in_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [trained_in_order_by!]

    """filter the rows returned"""
    where: trained_in_bool_exp
  ): trained_in_aggregate!

  """fetch data from the table: "trained_in" using primary key columns"""
  trained_in_by_pk(physician: bigint!, treatment: bigint!): trained_in

  """
  fetch data from the table: "undergoes"
  """
  undergoes(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): [undergoes!]!

  """
  fetch aggregated fields from the table: "undergoes"
  """
  undergoes_aggregate(
    """distinct select on columns"""
    distinct_on: [undergoes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [undergoes_order_by!]

    """filter the rows returned"""
    where: undergoes_bool_exp
  ): undergoes_aggregate!
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "trained_in"
"""
type trained_in {
  certificationdate: timestamptz
  certificationexpires: timestamptz
  physician: bigint!

  """An object relationship"""
  physicianByPhysician: physician!

  """An object relationship"""
  procedure: procedures!
  treatment: bigint!
}

"""
aggregated selection of "trained_in"
"""
type trained_in_aggregate {
  aggregate: trained_in_aggregate_fields
  nodes: [trained_in!]!
}

"""
aggregate fields of "trained_in"
"""
type trained_in_aggregate_fields {
  avg: trained_in_avg_fields
  count(columns: [trained_in_select_column!], distinct: Boolean): Int
  max: trained_in_max_fields
  min: trained_in_min_fields
  stddev: trained_in_stddev_fields
  stddev_pop: trained_in_stddev_pop_fields
  stddev_samp: trained_in_stddev_samp_fields
  sum: trained_in_sum_fields
  var_pop: trained_in_var_pop_fields
  var_samp: trained_in_var_samp_fields
  variance: trained_in_variance_fields
}

"""
order by aggregate values of table "trained_in"
"""
input trained_in_aggregate_order_by {
  avg: trained_in_avg_order_by
  count: order_by
  max: trained_in_max_order_by
  min: trained_in_min_order_by
  stddev: trained_in_stddev_order_by
  stddev_pop: trained_in_stddev_pop_order_by
  stddev_samp: trained_in_stddev_samp_order_by
  sum: trained_in_sum_order_by
  var_pop: trained_in_var_pop_order_by
  var_samp: trained_in_var_samp_order_by
  variance: trained_in_variance_order_by
}

"""
input type for inserting array relation for remote table "trained_in"
"""
input trained_in_arr_rel_insert_input {
  data: [trained_in_insert_input!]!
  on_conflict: trained_in_on_conflict
}

"""aggregate avg on columns"""
type trained_in_avg_fields {
  physician: Float
  treatment: Float
}

"""
order by avg() on columns of table "trained_in"
"""
input trained_in_avg_order_by {
  physician: order_by
  treatment: order_by
}

"""
Boolean expression to filter rows from the table "trained_in". All fields are combined with a logical 'AND'.
"""
input trained_in_bool_exp {
  _and: [trained_in_bool_exp]
  _not: trained_in_bool_exp
  _or: [trained_in_bool_exp]
  certificationdate: timestamptz_comparison_exp
  certificationexpires: timestamptz_comparison_exp
  physician: bigint_comparison_exp
  physicianByPhysician: physician_bool_exp
  procedure: procedures_bool_exp
  treatment: bigint_comparison_exp
}

"""
unique or primary key constraints on table "trained_in"
"""
enum trained_in_constraint {
  """unique or primary key constraint"""
  idx_17242_sqlite_autoindex_trained_in_1

  """unique or primary key constraint"""
  idx_17242_trained_in_pkey
}

"""
input type for incrementing integer column in table "trained_in"
"""
input trained_in_inc_input {
  physician: bigint
  treatment: bigint
}

"""
input type for inserting data into table "trained_in"
"""
input trained_in_insert_input {
  certificationdate: timestamptz
  certificationexpires: timestamptz
  physician: bigint
  physicianByPhysician: physician_obj_rel_insert_input
  procedure: procedures_obj_rel_insert_input
  treatment: bigint
}

"""aggregate max on columns"""
type trained_in_max_fields {
  certificationdate: timestamptz
  certificationexpires: timestamptz
  physician: bigint
  treatment: bigint
}

"""
order by max() on columns of table "trained_in"
"""
input trained_in_max_order_by {
  certificationdate: order_by
  certificationexpires: order_by
  physician: order_by
  treatment: order_by
}

"""aggregate min on columns"""
type trained_in_min_fields {
  certificationdate: timestamptz
  certificationexpires: timestamptz
  physician: bigint
  treatment: bigint
}

"""
order by min() on columns of table "trained_in"
"""
input trained_in_min_order_by {
  certificationdate: order_by
  certificationexpires: order_by
  physician: order_by
  treatment: order_by
}

"""
response of any mutation on the table "trained_in"
"""
type trained_in_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [trained_in!]!
}

"""
input type for inserting object relation for remote table "trained_in"
"""
input trained_in_obj_rel_insert_input {
  data: trained_in_insert_input!
  on_conflict: trained_in_on_conflict
}

"""
on conflict condition type for table "trained_in"
"""
input trained_in_on_conflict {
  constraint: trained_in_constraint!
  update_columns: [trained_in_update_column!]!
  where: trained_in_bool_exp
}

"""
ordering options when selecting data from "trained_in"
"""
input trained_in_order_by {
  certificationdate: order_by
  certificationexpires: order_by
  physician: order_by
  physicianByPhysician: physician_order_by
  procedure: procedures_order_by
  treatment: order_by
}

"""
primary key columns input for table: "trained_in"
"""
input trained_in_pk_columns_input {
  physician: bigint!
  treatment: bigint!
}

"""
select columns of table "trained_in"
"""
enum trained_in_select_column {
  """column name"""
  certificationdate

  """column name"""
  certificationexpires

  """column name"""
  physician

  """column name"""
  treatment
}

"""
input type for updating data in table "trained_in"
"""
input trained_in_set_input {
  certificationdate: timestamptz
  certificationexpires: timestamptz
  physician: bigint
  treatment: bigint
}

"""aggregate stddev on columns"""
type trained_in_stddev_fields {
  physician: Float
  treatment: Float
}

"""
order by stddev() on columns of table "trained_in"
"""
input trained_in_stddev_order_by {
  physician: order_by
  treatment: order_by
}

"""aggregate stddev_pop on columns"""
type trained_in_stddev_pop_fields {
  physician: Float
  treatment: Float
}

"""
order by stddev_pop() on columns of table "trained_in"
"""
input trained_in_stddev_pop_order_by {
  physician: order_by
  treatment: order_by
}

"""aggregate stddev_samp on columns"""
type trained_in_stddev_samp_fields {
  physician: Float
  treatment: Float
}

"""
order by stddev_samp() on columns of table "trained_in"
"""
input trained_in_stddev_samp_order_by {
  physician: order_by
  treatment: order_by
}

"""aggregate sum on columns"""
type trained_in_sum_fields {
  physician: bigint
  treatment: bigint
}

"""
order by sum() on columns of table "trained_in"
"""
input trained_in_sum_order_by {
  physician: order_by
  treatment: order_by
}

"""
update columns of table "trained_in"
"""
enum trained_in_update_column {
  """column name"""
  certificationdate

  """column name"""
  certificationexpires

  """column name"""
  physician

  """column name"""
  treatment
}

"""aggregate var_pop on columns"""
type trained_in_var_pop_fields {
  physician: Float
  treatment: Float
}

"""
order by var_pop() on columns of table "trained_in"
"""
input trained_in_var_pop_order_by {
  physician: order_by
  treatment: order_by
}

"""aggregate var_samp on columns"""
type trained_in_var_samp_fields {
  physician: Float
  treatment: Float
}

"""
order by var_samp() on columns of table "trained_in"
"""
input trained_in_var_samp_order_by {
  physician: order_by
  treatment: order_by
}

"""aggregate variance on columns"""
type trained_in_variance_fields {
  physician: Float
  treatment: Float
}

"""
order by variance() on columns of table "trained_in"
"""
input trained_in_variance_order_by {
  physician: order_by
  treatment: order_by
}

"""
columns and relationships of "undergoes"
"""
type undergoes {
  assistingnurse: bigint
  dateundergoes: timestamptz
  patient: bigint

  """An object relationship"""
  patientByPatient: patient
  physician: bigint

  """An object relationship"""
  physicianByPhysician: physician

  """An object relationship"""
  procedure: procedures
  procedures: bigint
  stay: bigint

  """An object relationship"""
  stayByStay: stay
}

"""
aggregated selection of "undergoes"
"""
type undergoes_aggregate {
  aggregate: undergoes_aggregate_fields
  nodes: [undergoes!]!
}

"""
aggregate fields of "undergoes"
"""
type undergoes_aggregate_fields {
  avg: undergoes_avg_fields
  count(columns: [undergoes_select_column!], distinct: Boolean): Int
  max: undergoes_max_fields
  min: undergoes_min_fields
  stddev: undergoes_stddev_fields
  stddev_pop: undergoes_stddev_pop_fields
  stddev_samp: undergoes_stddev_samp_fields
  sum: undergoes_sum_fields
  var_pop: undergoes_var_pop_fields
  var_samp: undergoes_var_samp_fields
  variance: undergoes_variance_fields
}

"""
order by aggregate values of table "undergoes"
"""
input undergoes_aggregate_order_by {
  avg: undergoes_avg_order_by
  count: order_by
  max: undergoes_max_order_by
  min: undergoes_min_order_by
  stddev: undergoes_stddev_order_by
  stddev_pop: undergoes_stddev_pop_order_by
  stddev_samp: undergoes_stddev_samp_order_by
  sum: undergoes_sum_order_by
  var_pop: undergoes_var_pop_order_by
  var_samp: undergoes_var_samp_order_by
  variance: undergoes_variance_order_by
}

"""
input type for inserting array relation for remote table "undergoes"
"""
input undergoes_arr_rel_insert_input {
  data: [undergoes_insert_input!]!
  on_conflict: undergoes_on_conflict
}

"""aggregate avg on columns"""
type undergoes_avg_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by avg() on columns of table "undergoes"
"""
input undergoes_avg_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""
Boolean expression to filter rows from the table "undergoes". All fields are combined with a logical 'AND'.
"""
input undergoes_bool_exp {
  _and: [undergoes_bool_exp]
  _not: undergoes_bool_exp
  _or: [undergoes_bool_exp]
  assistingnurse: bigint_comparison_exp
  dateundergoes: timestamptz_comparison_exp
  patient: bigint_comparison_exp
  patientByPatient: patient_bool_exp
  physician: bigint_comparison_exp
  physicianByPhysician: physician_bool_exp
  procedure: procedures_bool_exp
  procedures: bigint_comparison_exp
  stay: bigint_comparison_exp
  stayByStay: stay_bool_exp
}

"""
unique or primary key constraints on table "undergoes"
"""
enum undergoes_constraint {
  """unique or primary key constraint"""
  idx_17290_sqlite_autoindex_undergoes_1
}

"""
input type for incrementing integer column in table "undergoes"
"""
input undergoes_inc_input {
  assistingnurse: bigint
  patient: bigint
  physician: bigint
  procedures: bigint
  stay: bigint
}

"""
input type for inserting data into table "undergoes"
"""
input undergoes_insert_input {
  assistingnurse: bigint
  dateundergoes: timestamptz
  patient: bigint
  patientByPatient: patient_obj_rel_insert_input
  physician: bigint
  physicianByPhysician: physician_obj_rel_insert_input
  procedure: procedures_obj_rel_insert_input
  procedures: bigint
  stay: bigint
  stayByStay: stay_obj_rel_insert_input
}

"""aggregate max on columns"""
type undergoes_max_fields {
  assistingnurse: bigint
  dateundergoes: timestamptz
  patient: bigint
  physician: bigint
  procedures: bigint
  stay: bigint
}

"""
order by max() on columns of table "undergoes"
"""
input undergoes_max_order_by {
  assistingnurse: order_by
  dateundergoes: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate min on columns"""
type undergoes_min_fields {
  assistingnurse: bigint
  dateundergoes: timestamptz
  patient: bigint
  physician: bigint
  procedures: bigint
  stay: bigint
}

"""
order by min() on columns of table "undergoes"
"""
input undergoes_min_order_by {
  assistingnurse: order_by
  dateundergoes: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""
response of any mutation on the table "undergoes"
"""
type undergoes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [undergoes!]!
}

"""
input type for inserting object relation for remote table "undergoes"
"""
input undergoes_obj_rel_insert_input {
  data: undergoes_insert_input!
  on_conflict: undergoes_on_conflict
}

"""
on conflict condition type for table "undergoes"
"""
input undergoes_on_conflict {
  constraint: undergoes_constraint!
  update_columns: [undergoes_update_column!]!
  where: undergoes_bool_exp
}

"""
ordering options when selecting data from "undergoes"
"""
input undergoes_order_by {
  assistingnurse: order_by
  dateundergoes: order_by
  patient: order_by
  patientByPatient: patient_order_by
  physician: order_by
  physicianByPhysician: physician_order_by
  procedure: procedures_order_by
  procedures: order_by
  stay: order_by
  stayByStay: stay_order_by
}

"""
select columns of table "undergoes"
"""
enum undergoes_select_column {
  """column name"""
  assistingnurse

  """column name"""
  dateundergoes

  """column name"""
  patient

  """column name"""
  physician

  """column name"""
  procedures

  """column name"""
  stay
}

"""
input type for updating data in table "undergoes"
"""
input undergoes_set_input {
  assistingnurse: bigint
  dateundergoes: timestamptz
  patient: bigint
  physician: bigint
  procedures: bigint
  stay: bigint
}

"""aggregate stddev on columns"""
type undergoes_stddev_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by stddev() on columns of table "undergoes"
"""
input undergoes_stddev_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate stddev_pop on columns"""
type undergoes_stddev_pop_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by stddev_pop() on columns of table "undergoes"
"""
input undergoes_stddev_pop_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate stddev_samp on columns"""
type undergoes_stddev_samp_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by stddev_samp() on columns of table "undergoes"
"""
input undergoes_stddev_samp_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate sum on columns"""
type undergoes_sum_fields {
  assistingnurse: bigint
  patient: bigint
  physician: bigint
  procedures: bigint
  stay: bigint
}

"""
order by sum() on columns of table "undergoes"
"""
input undergoes_sum_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""
update columns of table "undergoes"
"""
enum undergoes_update_column {
  """column name"""
  assistingnurse

  """column name"""
  dateundergoes

  """column name"""
  patient

  """column name"""
  physician

  """column name"""
  procedures

  """column name"""
  stay
}

"""aggregate var_pop on columns"""
type undergoes_var_pop_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by var_pop() on columns of table "undergoes"
"""
input undergoes_var_pop_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate var_samp on columns"""
type undergoes_var_samp_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by var_samp() on columns of table "undergoes"
"""
input undergoes_var_samp_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}

"""aggregate variance on columns"""
type undergoes_variance_fields {
  assistingnurse: Float
  patient: Float
  physician: Float
  procedures: Float
  stay: Float
}

"""
order by variance() on columns of table "undergoes"
"""
input undergoes_variance_order_by {
  assistingnurse: order_by
  patient: order_by
  physician: order_by
  procedures: order_by
  stay: order_by
}
