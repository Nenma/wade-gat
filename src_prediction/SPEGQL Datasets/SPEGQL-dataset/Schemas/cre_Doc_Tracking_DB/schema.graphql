schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

"""
columns and relationships of "all_documents"
"""
type all_documents {
  date_stored: timestamptz
  document_description: String
  document_id: bigint!

  """An array relationship"""
  document_locations(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """An aggregated array relationship"""
  document_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!
  document_name: String
  document_type_code: String

  """An array relationship"""
  documents_to_be_destroyeds(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """An aggregated array relationship"""
  documents_to_be_destroyeds_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!
  other_details: String

  """An object relationship"""
  ref_calendar: ref_calendar

  """An object relationship"""
  ref_document_type: ref_document_types
}

"""
aggregated selection of "all_documents"
"""
type all_documents_aggregate {
  aggregate: all_documents_aggregate_fields
  nodes: [all_documents!]!
}

"""
aggregate fields of "all_documents"
"""
type all_documents_aggregate_fields {
  avg: all_documents_avg_fields
  count(columns: [all_documents_select_column!], distinct: Boolean): Int
  max: all_documents_max_fields
  min: all_documents_min_fields
  stddev: all_documents_stddev_fields
  stddev_pop: all_documents_stddev_pop_fields
  stddev_samp: all_documents_stddev_samp_fields
  sum: all_documents_sum_fields
  var_pop: all_documents_var_pop_fields
  var_samp: all_documents_var_samp_fields
  variance: all_documents_variance_fields
}

"""
order by aggregate values of table "all_documents"
"""
input all_documents_aggregate_order_by {
  avg: all_documents_avg_order_by
  count: order_by
  max: all_documents_max_order_by
  min: all_documents_min_order_by
  stddev: all_documents_stddev_order_by
  stddev_pop: all_documents_stddev_pop_order_by
  stddev_samp: all_documents_stddev_samp_order_by
  sum: all_documents_sum_order_by
  var_pop: all_documents_var_pop_order_by
  var_samp: all_documents_var_samp_order_by
  variance: all_documents_variance_order_by
}

"""
input type for inserting array relation for remote table "all_documents"
"""
input all_documents_arr_rel_insert_input {
  data: [all_documents_insert_input!]!
  on_conflict: all_documents_on_conflict
}

"""aggregate avg on columns"""
type all_documents_avg_fields {
  document_id: Float
}

"""
order by avg() on columns of table "all_documents"
"""
input all_documents_avg_order_by {
  document_id: order_by
}

"""
Boolean expression to filter rows from the table "all_documents". All fields are combined with a logical 'AND'.
"""
input all_documents_bool_exp {
  _and: [all_documents_bool_exp]
  _not: all_documents_bool_exp
  _or: [all_documents_bool_exp]
  date_stored: timestamptz_comparison_exp
  document_description: String_comparison_exp
  document_id: bigint_comparison_exp
  document_locations: document_locations_bool_exp
  document_name: String_comparison_exp
  document_type_code: String_comparison_exp
  documents_to_be_destroyeds: documents_to_be_destroyed_bool_exp
  other_details: String_comparison_exp
  ref_calendar: ref_calendar_bool_exp
  ref_document_type: ref_document_types_bool_exp
}

"""
unique or primary key constraints on table "all_documents"
"""
enum all_documents_constraint {
  """unique or primary key constraint"""
  idx_21658_all_documents_pkey
}

"""
input type for incrementing integer column in table "all_documents"
"""
input all_documents_inc_input {
  document_id: bigint
}

"""
input type for inserting data into table "all_documents"
"""
input all_documents_insert_input {
  date_stored: timestamptz
  document_description: String
  document_id: bigint
  document_locations: document_locations_arr_rel_insert_input
  document_name: String
  document_type_code: String
  documents_to_be_destroyeds: documents_to_be_destroyed_arr_rel_insert_input
  other_details: String
  ref_calendar: ref_calendar_obj_rel_insert_input
  ref_document_type: ref_document_types_obj_rel_insert_input
}

"""aggregate max on columns"""
type all_documents_max_fields {
  date_stored: timestamptz
  document_description: String
  document_id: bigint
  document_name: String
  document_type_code: String
  other_details: String
}

"""
order by max() on columns of table "all_documents"
"""
input all_documents_max_order_by {
  date_stored: order_by
  document_description: order_by
  document_id: order_by
  document_name: order_by
  document_type_code: order_by
  other_details: order_by
}

"""aggregate min on columns"""
type all_documents_min_fields {
  date_stored: timestamptz
  document_description: String
  document_id: bigint
  document_name: String
  document_type_code: String
  other_details: String
}

"""
order by min() on columns of table "all_documents"
"""
input all_documents_min_order_by {
  date_stored: order_by
  document_description: order_by
  document_id: order_by
  document_name: order_by
  document_type_code: order_by
  other_details: order_by
}

"""
response of any mutation on the table "all_documents"
"""
type all_documents_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [all_documents!]!
}

"""
input type for inserting object relation for remote table "all_documents"
"""
input all_documents_obj_rel_insert_input {
  data: all_documents_insert_input!
  on_conflict: all_documents_on_conflict
}

"""
on conflict condition type for table "all_documents"
"""
input all_documents_on_conflict {
  constraint: all_documents_constraint!
  update_columns: [all_documents_update_column!]!
  where: all_documents_bool_exp
}

"""
ordering options when selecting data from "all_documents"
"""
input all_documents_order_by {
  date_stored: order_by
  document_description: order_by
  document_id: order_by
  document_locations_aggregate: document_locations_aggregate_order_by
  document_name: order_by
  document_type_code: order_by
  documents_to_be_destroyeds_aggregate: documents_to_be_destroyed_aggregate_order_by
  other_details: order_by
  ref_calendar: ref_calendar_order_by
  ref_document_type: ref_document_types_order_by
}

"""
primary key columns input for table: "all_documents"
"""
input all_documents_pk_columns_input {
  document_id: bigint!
}

"""
select columns of table "all_documents"
"""
enum all_documents_select_column {
  """column name"""
  date_stored

  """column name"""
  document_description

  """column name"""
  document_id

  """column name"""
  document_name

  """column name"""
  document_type_code

  """column name"""
  other_details
}

"""
input type for updating data in table "all_documents"
"""
input all_documents_set_input {
  date_stored: timestamptz
  document_description: String
  document_id: bigint
  document_name: String
  document_type_code: String
  other_details: String
}

"""aggregate stddev on columns"""
type all_documents_stddev_fields {
  document_id: Float
}

"""
order by stddev() on columns of table "all_documents"
"""
input all_documents_stddev_order_by {
  document_id: order_by
}

"""aggregate stddev_pop on columns"""
type all_documents_stddev_pop_fields {
  document_id: Float
}

"""
order by stddev_pop() on columns of table "all_documents"
"""
input all_documents_stddev_pop_order_by {
  document_id: order_by
}

"""aggregate stddev_samp on columns"""
type all_documents_stddev_samp_fields {
  document_id: Float
}

"""
order by stddev_samp() on columns of table "all_documents"
"""
input all_documents_stddev_samp_order_by {
  document_id: order_by
}

"""aggregate sum on columns"""
type all_documents_sum_fields {
  document_id: bigint
}

"""
order by sum() on columns of table "all_documents"
"""
input all_documents_sum_order_by {
  document_id: order_by
}

"""
update columns of table "all_documents"
"""
enum all_documents_update_column {
  """column name"""
  date_stored

  """column name"""
  document_description

  """column name"""
  document_id

  """column name"""
  document_name

  """column name"""
  document_type_code

  """column name"""
  other_details
}

"""aggregate var_pop on columns"""
type all_documents_var_pop_fields {
  document_id: Float
}

"""
order by var_pop() on columns of table "all_documents"
"""
input all_documents_var_pop_order_by {
  document_id: order_by
}

"""aggregate var_samp on columns"""
type all_documents_var_samp_fields {
  document_id: Float
}

"""
order by var_samp() on columns of table "all_documents"
"""
input all_documents_var_samp_order_by {
  document_id: order_by
}

"""aggregate variance on columns"""
type all_documents_variance_fields {
  document_id: Float
}

"""
order by variance() on columns of table "all_documents"
"""
input all_documents_variance_order_by {
  document_id: order_by
}

scalar bigint

"""
expression to compare columns of type bigint. All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "document_locations"
"""
type document_locations {
  """An object relationship"""
  all_document: all_documents
  date_in_location_from: timestamptz
  date_in_locaton_to: timestamptz
  document_id: bigint
  location_code: String

  """An object relationship"""
  refCalendarByDateInLocatonTo: ref_calendar

  """An object relationship"""
  ref_calendar: ref_calendar

  """An object relationship"""
  ref_location: ref_locations
}

"""
aggregated selection of "document_locations"
"""
type document_locations_aggregate {
  aggregate: document_locations_aggregate_fields
  nodes: [document_locations!]!
}

"""
aggregate fields of "document_locations"
"""
type document_locations_aggregate_fields {
  avg: document_locations_avg_fields
  count(columns: [document_locations_select_column!], distinct: Boolean): Int
  max: document_locations_max_fields
  min: document_locations_min_fields
  stddev: document_locations_stddev_fields
  stddev_pop: document_locations_stddev_pop_fields
  stddev_samp: document_locations_stddev_samp_fields
  sum: document_locations_sum_fields
  var_pop: document_locations_var_pop_fields
  var_samp: document_locations_var_samp_fields
  variance: document_locations_variance_fields
}

"""
order by aggregate values of table "document_locations"
"""
input document_locations_aggregate_order_by {
  avg: document_locations_avg_order_by
  count: order_by
  max: document_locations_max_order_by
  min: document_locations_min_order_by
  stddev: document_locations_stddev_order_by
  stddev_pop: document_locations_stddev_pop_order_by
  stddev_samp: document_locations_stddev_samp_order_by
  sum: document_locations_sum_order_by
  var_pop: document_locations_var_pop_order_by
  var_samp: document_locations_var_samp_order_by
  variance: document_locations_variance_order_by
}

"""
input type for inserting array relation for remote table "document_locations"
"""
input document_locations_arr_rel_insert_input {
  data: [document_locations_insert_input!]!
  on_conflict: document_locations_on_conflict
}

"""aggregate avg on columns"""
type document_locations_avg_fields {
  document_id: Float
}

"""
order by avg() on columns of table "document_locations"
"""
input document_locations_avg_order_by {
  document_id: order_by
}

"""
Boolean expression to filter rows from the table "document_locations". All fields are combined with a logical 'AND'.
"""
input document_locations_bool_exp {
  _and: [document_locations_bool_exp]
  _not: document_locations_bool_exp
  _or: [document_locations_bool_exp]
  all_document: all_documents_bool_exp
  date_in_location_from: timestamptz_comparison_exp
  date_in_locaton_to: timestamptz_comparison_exp
  document_id: bigint_comparison_exp
  location_code: String_comparison_exp
  refCalendarByDateInLocatonTo: ref_calendar_bool_exp
  ref_calendar: ref_calendar_bool_exp
  ref_location: ref_locations_bool_exp
}

"""
unique or primary key constraints on table "document_locations"
"""
enum document_locations_constraint {
  """unique or primary key constraint"""
  idx_21670_sqlite_autoindex_document_locations_1
}

"""
input type for incrementing integer column in table "document_locations"
"""
input document_locations_inc_input {
  document_id: bigint
}

"""
input type for inserting data into table "document_locations"
"""
input document_locations_insert_input {
  all_document: all_documents_obj_rel_insert_input
  date_in_location_from: timestamptz
  date_in_locaton_to: timestamptz
  document_id: bigint
  location_code: String
  refCalendarByDateInLocatonTo: ref_calendar_obj_rel_insert_input
  ref_calendar: ref_calendar_obj_rel_insert_input
  ref_location: ref_locations_obj_rel_insert_input
}

"""aggregate max on columns"""
type document_locations_max_fields {
  date_in_location_from: timestamptz
  date_in_locaton_to: timestamptz
  document_id: bigint
  location_code: String
}

"""
order by max() on columns of table "document_locations"
"""
input document_locations_max_order_by {
  date_in_location_from: order_by
  date_in_locaton_to: order_by
  document_id: order_by
  location_code: order_by
}

"""aggregate min on columns"""
type document_locations_min_fields {
  date_in_location_from: timestamptz
  date_in_locaton_to: timestamptz
  document_id: bigint
  location_code: String
}

"""
order by min() on columns of table "document_locations"
"""
input document_locations_min_order_by {
  date_in_location_from: order_by
  date_in_locaton_to: order_by
  document_id: order_by
  location_code: order_by
}

"""
response of any mutation on the table "document_locations"
"""
type document_locations_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [document_locations!]!
}

"""
input type for inserting object relation for remote table "document_locations"
"""
input document_locations_obj_rel_insert_input {
  data: document_locations_insert_input!
  on_conflict: document_locations_on_conflict
}

"""
on conflict condition type for table "document_locations"
"""
input document_locations_on_conflict {
  constraint: document_locations_constraint!
  update_columns: [document_locations_update_column!]!
  where: document_locations_bool_exp
}

"""
ordering options when selecting data from "document_locations"
"""
input document_locations_order_by {
  all_document: all_documents_order_by
  date_in_location_from: order_by
  date_in_locaton_to: order_by
  document_id: order_by
  location_code: order_by
  refCalendarByDateInLocatonTo: ref_calendar_order_by
  ref_calendar: ref_calendar_order_by
  ref_location: ref_locations_order_by
}

"""
select columns of table "document_locations"
"""
enum document_locations_select_column {
  """column name"""
  date_in_location_from

  """column name"""
  date_in_locaton_to

  """column name"""
  document_id

  """column name"""
  location_code
}

"""
input type for updating data in table "document_locations"
"""
input document_locations_set_input {
  date_in_location_from: timestamptz
  date_in_locaton_to: timestamptz
  document_id: bigint
  location_code: String
}

"""aggregate stddev on columns"""
type document_locations_stddev_fields {
  document_id: Float
}

"""
order by stddev() on columns of table "document_locations"
"""
input document_locations_stddev_order_by {
  document_id: order_by
}

"""aggregate stddev_pop on columns"""
type document_locations_stddev_pop_fields {
  document_id: Float
}

"""
order by stddev_pop() on columns of table "document_locations"
"""
input document_locations_stddev_pop_order_by {
  document_id: order_by
}

"""aggregate stddev_samp on columns"""
type document_locations_stddev_samp_fields {
  document_id: Float
}

"""
order by stddev_samp() on columns of table "document_locations"
"""
input document_locations_stddev_samp_order_by {
  document_id: order_by
}

"""aggregate sum on columns"""
type document_locations_sum_fields {
  document_id: bigint
}

"""
order by sum() on columns of table "document_locations"
"""
input document_locations_sum_order_by {
  document_id: order_by
}

"""
update columns of table "document_locations"
"""
enum document_locations_update_column {
  """column name"""
  date_in_location_from

  """column name"""
  date_in_locaton_to

  """column name"""
  document_id

  """column name"""
  location_code
}

"""aggregate var_pop on columns"""
type document_locations_var_pop_fields {
  document_id: Float
}

"""
order by var_pop() on columns of table "document_locations"
"""
input document_locations_var_pop_order_by {
  document_id: order_by
}

"""aggregate var_samp on columns"""
type document_locations_var_samp_fields {
  document_id: Float
}

"""
order by var_samp() on columns of table "document_locations"
"""
input document_locations_var_samp_order_by {
  document_id: order_by
}

"""aggregate variance on columns"""
type document_locations_variance_fields {
  document_id: Float
}

"""
order by variance() on columns of table "document_locations"
"""
input document_locations_variance_order_by {
  document_id: order_by
}

"""
columns and relationships of "documents_to_be_destroyed"
"""
type documents_to_be_destroyed {
  actual_destruction_date: timestamptz

  """An object relationship"""
  all_document: all_documents!
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint!

  """An object relationship"""
  employee: employees

  """An object relationship"""
  employeeByDestructionAuthorisedByEmployeeId: employees
  other_details: String
  planned_destruction_date: timestamptz

  """An object relationship"""
  refCalendarByPlannedDestructionDate: ref_calendar

  """An object relationship"""
  ref_calendar: ref_calendar
}

"""
aggregated selection of "documents_to_be_destroyed"
"""
type documents_to_be_destroyed_aggregate {
  aggregate: documents_to_be_destroyed_aggregate_fields
  nodes: [documents_to_be_destroyed!]!
}

"""
aggregate fields of "documents_to_be_destroyed"
"""
type documents_to_be_destroyed_aggregate_fields {
  avg: documents_to_be_destroyed_avg_fields
  count(columns: [documents_to_be_destroyed_select_column!], distinct: Boolean): Int
  max: documents_to_be_destroyed_max_fields
  min: documents_to_be_destroyed_min_fields
  stddev: documents_to_be_destroyed_stddev_fields
  stddev_pop: documents_to_be_destroyed_stddev_pop_fields
  stddev_samp: documents_to_be_destroyed_stddev_samp_fields
  sum: documents_to_be_destroyed_sum_fields
  var_pop: documents_to_be_destroyed_var_pop_fields
  var_samp: documents_to_be_destroyed_var_samp_fields
  variance: documents_to_be_destroyed_variance_fields
}

"""
order by aggregate values of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_aggregate_order_by {
  avg: documents_to_be_destroyed_avg_order_by
  count: order_by
  max: documents_to_be_destroyed_max_order_by
  min: documents_to_be_destroyed_min_order_by
  stddev: documents_to_be_destroyed_stddev_order_by
  stddev_pop: documents_to_be_destroyed_stddev_pop_order_by
  stddev_samp: documents_to_be_destroyed_stddev_samp_order_by
  sum: documents_to_be_destroyed_sum_order_by
  var_pop: documents_to_be_destroyed_var_pop_order_by
  var_samp: documents_to_be_destroyed_var_samp_order_by
  variance: documents_to_be_destroyed_variance_order_by
}

"""
input type for inserting array relation for remote table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_arr_rel_insert_input {
  data: [documents_to_be_destroyed_insert_input!]!
  on_conflict: documents_to_be_destroyed_on_conflict
}

"""aggregate avg on columns"""
type documents_to_be_destroyed_avg_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by avg() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_avg_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""
Boolean expression to filter rows from the table "documents_to_be_destroyed". All fields are combined with a logical 'AND'.
"""
input documents_to_be_destroyed_bool_exp {
  _and: [documents_to_be_destroyed_bool_exp]
  _not: documents_to_be_destroyed_bool_exp
  _or: [documents_to_be_destroyed_bool_exp]
  actual_destruction_date: timestamptz_comparison_exp
  all_document: all_documents_bool_exp
  destroyed_by_employee_id: bigint_comparison_exp
  destruction_authorised_by_employee_id: bigint_comparison_exp
  document_id: bigint_comparison_exp
  employee: employees_bool_exp
  employeeByDestructionAuthorisedByEmployeeId: employees_bool_exp
  other_details: String_comparison_exp
  planned_destruction_date: timestamptz_comparison_exp
  refCalendarByPlannedDestructionDate: ref_calendar_bool_exp
  ref_calendar: ref_calendar_bool_exp
}

"""
unique or primary key constraints on table "documents_to_be_destroyed"
"""
enum documents_to_be_destroyed_constraint {
  """unique or primary key constraint"""
  idx_21676_documents_to_be_destroyed_pkey
}

"""
input type for incrementing integer column in table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_inc_input {
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
}

"""
input type for inserting data into table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_insert_input {
  actual_destruction_date: timestamptz
  all_document: all_documents_obj_rel_insert_input
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
  employee: employees_obj_rel_insert_input
  employeeByDestructionAuthorisedByEmployeeId: employees_obj_rel_insert_input
  other_details: String
  planned_destruction_date: timestamptz
  refCalendarByPlannedDestructionDate: ref_calendar_obj_rel_insert_input
  ref_calendar: ref_calendar_obj_rel_insert_input
}

"""aggregate max on columns"""
type documents_to_be_destroyed_max_fields {
  actual_destruction_date: timestamptz
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
  other_details: String
  planned_destruction_date: timestamptz
}

"""
order by max() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_max_order_by {
  actual_destruction_date: order_by
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
  other_details: order_by
  planned_destruction_date: order_by
}

"""aggregate min on columns"""
type documents_to_be_destroyed_min_fields {
  actual_destruction_date: timestamptz
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
  other_details: String
  planned_destruction_date: timestamptz
}

"""
order by min() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_min_order_by {
  actual_destruction_date: order_by
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
  other_details: order_by
  planned_destruction_date: order_by
}

"""
response of any mutation on the table "documents_to_be_destroyed"
"""
type documents_to_be_destroyed_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [documents_to_be_destroyed!]!
}

"""
input type for inserting object relation for remote table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_obj_rel_insert_input {
  data: documents_to_be_destroyed_insert_input!
  on_conflict: documents_to_be_destroyed_on_conflict
}

"""
on conflict condition type for table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_on_conflict {
  constraint: documents_to_be_destroyed_constraint!
  update_columns: [documents_to_be_destroyed_update_column!]!
  where: documents_to_be_destroyed_bool_exp
}

"""
ordering options when selecting data from "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_order_by {
  actual_destruction_date: order_by
  all_document: all_documents_order_by
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
  employee: employees_order_by
  employeeByDestructionAuthorisedByEmployeeId: employees_order_by
  other_details: order_by
  planned_destruction_date: order_by
  refCalendarByPlannedDestructionDate: ref_calendar_order_by
  ref_calendar: ref_calendar_order_by
}

"""
primary key columns input for table: "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_pk_columns_input {
  document_id: bigint!
}

"""
select columns of table "documents_to_be_destroyed"
"""
enum documents_to_be_destroyed_select_column {
  """column name"""
  actual_destruction_date

  """column name"""
  destroyed_by_employee_id

  """column name"""
  destruction_authorised_by_employee_id

  """column name"""
  document_id

  """column name"""
  other_details

  """column name"""
  planned_destruction_date
}

"""
input type for updating data in table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_set_input {
  actual_destruction_date: timestamptz
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
  other_details: String
  planned_destruction_date: timestamptz
}

"""aggregate stddev on columns"""
type documents_to_be_destroyed_stddev_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by stddev() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_stddev_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""aggregate stddev_pop on columns"""
type documents_to_be_destroyed_stddev_pop_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by stddev_pop() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_stddev_pop_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""aggregate stddev_samp on columns"""
type documents_to_be_destroyed_stddev_samp_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by stddev_samp() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_stddev_samp_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""aggregate sum on columns"""
type documents_to_be_destroyed_sum_fields {
  destroyed_by_employee_id: bigint
  destruction_authorised_by_employee_id: bigint
  document_id: bigint
}

"""
order by sum() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_sum_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""
update columns of table "documents_to_be_destroyed"
"""
enum documents_to_be_destroyed_update_column {
  """column name"""
  actual_destruction_date

  """column name"""
  destroyed_by_employee_id

  """column name"""
  destruction_authorised_by_employee_id

  """column name"""
  document_id

  """column name"""
  other_details

  """column name"""
  planned_destruction_date
}

"""aggregate var_pop on columns"""
type documents_to_be_destroyed_var_pop_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by var_pop() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_var_pop_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""aggregate var_samp on columns"""
type documents_to_be_destroyed_var_samp_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by var_samp() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_var_samp_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""aggregate variance on columns"""
type documents_to_be_destroyed_variance_fields {
  destroyed_by_employee_id: Float
  destruction_authorised_by_employee_id: Float
  document_id: Float
}

"""
order by variance() on columns of table "documents_to_be_destroyed"
"""
input documents_to_be_destroyed_variance_order_by {
  destroyed_by_employee_id: order_by
  destruction_authorised_by_employee_id: order_by
  document_id: order_by
}

"""
columns and relationships of "employees"
"""
type employees {
  date_of_birth: timestamptz

  """An array relationship"""
  documentsToBeDestroyedsByDestroyedByEmployeeId(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """An aggregated array relationship"""
  documentsToBeDestroyedsByDestroyedByEmployeeId_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!

  """An array relationship"""
  documents_to_be_destroyeds(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """An aggregated array relationship"""
  documents_to_be_destroyeds_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!
  employee_id: bigint!
  employee_name: String
  gender_mfu: String
  other_details: String

  """An object relationship"""
  role: roles
  role_code: String
}

"""
aggregated selection of "employees"
"""
type employees_aggregate {
  aggregate: employees_aggregate_fields
  nodes: [employees!]!
}

"""
aggregate fields of "employees"
"""
type employees_aggregate_fields {
  avg: employees_avg_fields
  count(columns: [employees_select_column!], distinct: Boolean): Int
  max: employees_max_fields
  min: employees_min_fields
  stddev: employees_stddev_fields
  stddev_pop: employees_stddev_pop_fields
  stddev_samp: employees_stddev_samp_fields
  sum: employees_sum_fields
  var_pop: employees_var_pop_fields
  var_samp: employees_var_samp_fields
  variance: employees_variance_fields
}

"""
order by aggregate values of table "employees"
"""
input employees_aggregate_order_by {
  avg: employees_avg_order_by
  count: order_by
  max: employees_max_order_by
  min: employees_min_order_by
  stddev: employees_stddev_order_by
  stddev_pop: employees_stddev_pop_order_by
  stddev_samp: employees_stddev_samp_order_by
  sum: employees_sum_order_by
  var_pop: employees_var_pop_order_by
  var_samp: employees_var_samp_order_by
  variance: employees_variance_order_by
}

"""
input type for inserting array relation for remote table "employees"
"""
input employees_arr_rel_insert_input {
  data: [employees_insert_input!]!
  on_conflict: employees_on_conflict
}

"""aggregate avg on columns"""
type employees_avg_fields {
  employee_id: Float
}

"""
order by avg() on columns of table "employees"
"""
input employees_avg_order_by {
  employee_id: order_by
}

"""
Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'.
"""
input employees_bool_exp {
  _and: [employees_bool_exp]
  _not: employees_bool_exp
  _or: [employees_bool_exp]
  date_of_birth: timestamptz_comparison_exp
  documentsToBeDestroyedsByDestroyedByEmployeeId: documents_to_be_destroyed_bool_exp
  documents_to_be_destroyeds: documents_to_be_destroyed_bool_exp
  employee_id: bigint_comparison_exp
  employee_name: String_comparison_exp
  gender_mfu: String_comparison_exp
  other_details: String_comparison_exp
  role: roles_bool_exp
  role_code: String_comparison_exp
}

"""
unique or primary key constraints on table "employees"
"""
enum employees_constraint {
  """unique or primary key constraint"""
  idx_21664_employees_pkey
}

"""
input type for incrementing integer column in table "employees"
"""
input employees_inc_input {
  employee_id: bigint
}

"""
input type for inserting data into table "employees"
"""
input employees_insert_input {
  date_of_birth: timestamptz
  documentsToBeDestroyedsByDestroyedByEmployeeId: documents_to_be_destroyed_arr_rel_insert_input
  documents_to_be_destroyeds: documents_to_be_destroyed_arr_rel_insert_input
  employee_id: bigint
  employee_name: String
  gender_mfu: String
  other_details: String
  role: roles_obj_rel_insert_input
  role_code: String
}

"""aggregate max on columns"""
type employees_max_fields {
  date_of_birth: timestamptz
  employee_id: bigint
  employee_name: String
  gender_mfu: String
  other_details: String
  role_code: String
}

"""
order by max() on columns of table "employees"
"""
input employees_max_order_by {
  date_of_birth: order_by
  employee_id: order_by
  employee_name: order_by
  gender_mfu: order_by
  other_details: order_by
  role_code: order_by
}

"""aggregate min on columns"""
type employees_min_fields {
  date_of_birth: timestamptz
  employee_id: bigint
  employee_name: String
  gender_mfu: String
  other_details: String
  role_code: String
}

"""
order by min() on columns of table "employees"
"""
input employees_min_order_by {
  date_of_birth: order_by
  employee_id: order_by
  employee_name: order_by
  gender_mfu: order_by
  other_details: order_by
  role_code: order_by
}

"""
response of any mutation on the table "employees"
"""
type employees_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [employees!]!
}

"""
input type for inserting object relation for remote table "employees"
"""
input employees_obj_rel_insert_input {
  data: employees_insert_input!
  on_conflict: employees_on_conflict
}

"""
on conflict condition type for table "employees"
"""
input employees_on_conflict {
  constraint: employees_constraint!
  update_columns: [employees_update_column!]!
  where: employees_bool_exp
}

"""
ordering options when selecting data from "employees"
"""
input employees_order_by {
  date_of_birth: order_by
  documentsToBeDestroyedsByDestroyedByEmployeeId_aggregate: documents_to_be_destroyed_aggregate_order_by
  documents_to_be_destroyeds_aggregate: documents_to_be_destroyed_aggregate_order_by
  employee_id: order_by
  employee_name: order_by
  gender_mfu: order_by
  other_details: order_by
  role: roles_order_by
  role_code: order_by
}

"""
primary key columns input for table: "employees"
"""
input employees_pk_columns_input {
  employee_id: bigint!
}

"""
select columns of table "employees"
"""
enum employees_select_column {
  """column name"""
  date_of_birth

  """column name"""
  employee_id

  """column name"""
  employee_name

  """column name"""
  gender_mfu

  """column name"""
  other_details

  """column name"""
  role_code
}

"""
input type for updating data in table "employees"
"""
input employees_set_input {
  date_of_birth: timestamptz
  employee_id: bigint
  employee_name: String
  gender_mfu: String
  other_details: String
  role_code: String
}

"""aggregate stddev on columns"""
type employees_stddev_fields {
  employee_id: Float
}

"""
order by stddev() on columns of table "employees"
"""
input employees_stddev_order_by {
  employee_id: order_by
}

"""aggregate stddev_pop on columns"""
type employees_stddev_pop_fields {
  employee_id: Float
}

"""
order by stddev_pop() on columns of table "employees"
"""
input employees_stddev_pop_order_by {
  employee_id: order_by
}

"""aggregate stddev_samp on columns"""
type employees_stddev_samp_fields {
  employee_id: Float
}

"""
order by stddev_samp() on columns of table "employees"
"""
input employees_stddev_samp_order_by {
  employee_id: order_by
}

"""aggregate sum on columns"""
type employees_sum_fields {
  employee_id: bigint
}

"""
order by sum() on columns of table "employees"
"""
input employees_sum_order_by {
  employee_id: order_by
}

"""
update columns of table "employees"
"""
enum employees_update_column {
  """column name"""
  date_of_birth

  """column name"""
  employee_id

  """column name"""
  employee_name

  """column name"""
  gender_mfu

  """column name"""
  other_details

  """column name"""
  role_code
}

"""aggregate var_pop on columns"""
type employees_var_pop_fields {
  employee_id: Float
}

"""
order by var_pop() on columns of table "employees"
"""
input employees_var_pop_order_by {
  employee_id: order_by
}

"""aggregate var_samp on columns"""
type employees_var_samp_fields {
  employee_id: Float
}

"""
order by var_samp() on columns of table "employees"
"""
input employees_var_samp_order_by {
  employee_id: order_by
}

"""aggregate variance on columns"""
type employees_variance_fields {
  employee_id: Float
}

"""
order by variance() on columns of table "employees"
"""
input employees_variance_order_by {
  employee_id: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "all_documents"
  """
  delete_all_documents(
    """filter the rows which have to be deleted"""
    where: all_documents_bool_exp!
  ): all_documents_mutation_response

  """
  delete single row from the table: "all_documents"
  """
  delete_all_documents_by_pk(document_id: bigint!): all_documents

  """
  delete data from the table: "document_locations"
  """
  delete_document_locations(
    """filter the rows which have to be deleted"""
    where: document_locations_bool_exp!
  ): document_locations_mutation_response

  """
  delete data from the table: "documents_to_be_destroyed"
  """
  delete_documents_to_be_destroyed(
    """filter the rows which have to be deleted"""
    where: documents_to_be_destroyed_bool_exp!
  ): documents_to_be_destroyed_mutation_response

  """
  delete single row from the table: "documents_to_be_destroyed"
  """
  delete_documents_to_be_destroyed_by_pk(document_id: bigint!): documents_to_be_destroyed

  """
  delete data from the table: "employees"
  """
  delete_employees(
    """filter the rows which have to be deleted"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  delete single row from the table: "employees"
  """
  delete_employees_by_pk(employee_id: bigint!): employees

  """
  delete data from the table: "ref_calendar"
  """
  delete_ref_calendar(
    """filter the rows which have to be deleted"""
    where: ref_calendar_bool_exp!
  ): ref_calendar_mutation_response

  """
  delete data from the table: "ref_document_types"
  """
  delete_ref_document_types(
    """filter the rows which have to be deleted"""
    where: ref_document_types_bool_exp!
  ): ref_document_types_mutation_response

  """
  delete data from the table: "ref_locations"
  """
  delete_ref_locations(
    """filter the rows which have to be deleted"""
    where: ref_locations_bool_exp!
  ): ref_locations_mutation_response

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  insert data into the table: "all_documents"
  """
  insert_all_documents(
    """the rows to be inserted"""
    objects: [all_documents_insert_input!]!

    """on conflict condition"""
    on_conflict: all_documents_on_conflict
  ): all_documents_mutation_response

  """
  insert a single row into the table: "all_documents"
  """
  insert_all_documents_one(
    """the row to be inserted"""
    object: all_documents_insert_input!

    """on conflict condition"""
    on_conflict: all_documents_on_conflict
  ): all_documents

  """
  insert data into the table: "document_locations"
  """
  insert_document_locations(
    """the rows to be inserted"""
    objects: [document_locations_insert_input!]!

    """on conflict condition"""
    on_conflict: document_locations_on_conflict
  ): document_locations_mutation_response

  """
  insert a single row into the table: "document_locations"
  """
  insert_document_locations_one(
    """the row to be inserted"""
    object: document_locations_insert_input!

    """on conflict condition"""
    on_conflict: document_locations_on_conflict
  ): document_locations

  """
  insert data into the table: "documents_to_be_destroyed"
  """
  insert_documents_to_be_destroyed(
    """the rows to be inserted"""
    objects: [documents_to_be_destroyed_insert_input!]!

    """on conflict condition"""
    on_conflict: documents_to_be_destroyed_on_conflict
  ): documents_to_be_destroyed_mutation_response

  """
  insert a single row into the table: "documents_to_be_destroyed"
  """
  insert_documents_to_be_destroyed_one(
    """the row to be inserted"""
    object: documents_to_be_destroyed_insert_input!

    """on conflict condition"""
    on_conflict: documents_to_be_destroyed_on_conflict
  ): documents_to_be_destroyed

  """
  insert data into the table: "employees"
  """
  insert_employees(
    """the rows to be inserted"""
    objects: [employees_insert_input!]!

    """on conflict condition"""
    on_conflict: employees_on_conflict
  ): employees_mutation_response

  """
  insert a single row into the table: "employees"
  """
  insert_employees_one(
    """the row to be inserted"""
    object: employees_insert_input!

    """on conflict condition"""
    on_conflict: employees_on_conflict
  ): employees

  """
  insert data into the table: "ref_calendar"
  """
  insert_ref_calendar(
    """the rows to be inserted"""
    objects: [ref_calendar_insert_input!]!

    """on conflict condition"""
    on_conflict: ref_calendar_on_conflict
  ): ref_calendar_mutation_response

  """
  insert a single row into the table: "ref_calendar"
  """
  insert_ref_calendar_one(
    """the row to be inserted"""
    object: ref_calendar_insert_input!

    """on conflict condition"""
    on_conflict: ref_calendar_on_conflict
  ): ref_calendar

  """
  insert data into the table: "ref_document_types"
  """
  insert_ref_document_types(
    """the rows to be inserted"""
    objects: [ref_document_types_insert_input!]!

    """on conflict condition"""
    on_conflict: ref_document_types_on_conflict
  ): ref_document_types_mutation_response

  """
  insert a single row into the table: "ref_document_types"
  """
  insert_ref_document_types_one(
    """the row to be inserted"""
    object: ref_document_types_insert_input!

    """on conflict condition"""
    on_conflict: ref_document_types_on_conflict
  ): ref_document_types

  """
  insert data into the table: "ref_locations"
  """
  insert_ref_locations(
    """the rows to be inserted"""
    objects: [ref_locations_insert_input!]!

    """on conflict condition"""
    on_conflict: ref_locations_on_conflict
  ): ref_locations_mutation_response

  """
  insert a single row into the table: "ref_locations"
  """
  insert_ref_locations_one(
    """the row to be inserted"""
    object: ref_locations_insert_input!

    """on conflict condition"""
    on_conflict: ref_locations_on_conflict
  ): ref_locations

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  update data of the table: "all_documents"
  """
  update_all_documents(
    """increments the integer columns with given value of the filtered values"""
    _inc: all_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_documents_set_input

    """filter the rows which have to be updated"""
    where: all_documents_bool_exp!
  ): all_documents_mutation_response

  """
  update single row of the table: "all_documents"
  """
  update_all_documents_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: all_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_documents_set_input
    pk_columns: all_documents_pk_columns_input!
  ): all_documents

  """
  update data of the table: "document_locations"
  """
  update_document_locations(
    """increments the integer columns with given value of the filtered values"""
    _inc: document_locations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: document_locations_set_input

    """filter the rows which have to be updated"""
    where: document_locations_bool_exp!
  ): document_locations_mutation_response

  """
  update data of the table: "documents_to_be_destroyed"
  """
  update_documents_to_be_destroyed(
    """increments the integer columns with given value of the filtered values"""
    _inc: documents_to_be_destroyed_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_to_be_destroyed_set_input

    """filter the rows which have to be updated"""
    where: documents_to_be_destroyed_bool_exp!
  ): documents_to_be_destroyed_mutation_response

  """
  update single row of the table: "documents_to_be_destroyed"
  """
  update_documents_to_be_destroyed_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: documents_to_be_destroyed_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_to_be_destroyed_set_input
    pk_columns: documents_to_be_destroyed_pk_columns_input!
  ): documents_to_be_destroyed

  """
  update data of the table: "employees"
  """
  update_employees(
    """increments the integer columns with given value of the filtered values"""
    _inc: employees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input

    """filter the rows which have to be updated"""
    where: employees_bool_exp!
  ): employees_mutation_response

  """
  update single row of the table: "employees"
  """
  update_employees_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: employees_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: employees_set_input
    pk_columns: employees_pk_columns_input!
  ): employees

  """
  update data of the table: "ref_calendar"
  """
  update_ref_calendar(
    """increments the integer columns with given value of the filtered values"""
    _inc: ref_calendar_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ref_calendar_set_input

    """filter the rows which have to be updated"""
    where: ref_calendar_bool_exp!
  ): ref_calendar_mutation_response

  """
  update data of the table: "ref_document_types"
  """
  update_ref_document_types(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_document_types_set_input

    """filter the rows which have to be updated"""
    where: ref_document_types_bool_exp!
  ): ref_document_types_mutation_response

  """
  update data of the table: "ref_locations"
  """
  update_ref_locations(
    """sets the columns of the filtered rows to the given values"""
    _set: ref_locations_set_input

    """filter the rows which have to be updated"""
    where: ref_locations_bool_exp!
  ): ref_locations_mutation_response

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""query root"""
type query_root {
  """
  fetch data from the table: "all_documents"
  """
  all_documents(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): [all_documents!]!

  """
  fetch aggregated fields from the table: "all_documents"
  """
  all_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): all_documents_aggregate!

  """fetch data from the table: "all_documents" using primary key columns"""
  all_documents_by_pk(document_id: bigint!): all_documents

  """
  fetch data from the table: "document_locations"
  """
  document_locations(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """
  fetch aggregated fields from the table: "document_locations"
  """
  document_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!

  """
  fetch data from the table: "documents_to_be_destroyed"
  """
  documents_to_be_destroyed(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """
  fetch aggregated fields from the table: "documents_to_be_destroyed"
  """
  documents_to_be_destroyed_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!

  """
  fetch data from the table: "documents_to_be_destroyed" using primary key columns
  """
  documents_to_be_destroyed_by_pk(document_id: bigint!): documents_to_be_destroyed

  """
  fetch data from the table: "employees"
  """
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch aggregated fields from the table: "employees"
  """
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(employee_id: bigint!): employees

  """
  fetch data from the table: "ref_calendar"
  """
  ref_calendar(
    """distinct select on columns"""
    distinct_on: [ref_calendar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_calendar_order_by!]

    """filter the rows returned"""
    where: ref_calendar_bool_exp
  ): [ref_calendar!]!

  """
  fetch aggregated fields from the table: "ref_calendar"
  """
  ref_calendar_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_calendar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_calendar_order_by!]

    """filter the rows returned"""
    where: ref_calendar_bool_exp
  ): ref_calendar_aggregate!

  """
  fetch data from the table: "ref_document_types"
  """
  ref_document_types(
    """distinct select on columns"""
    distinct_on: [ref_document_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_document_types_order_by!]

    """filter the rows returned"""
    where: ref_document_types_bool_exp
  ): [ref_document_types!]!

  """
  fetch aggregated fields from the table: "ref_document_types"
  """
  ref_document_types_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_document_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_document_types_order_by!]

    """filter the rows returned"""
    where: ref_document_types_bool_exp
  ): ref_document_types_aggregate!

  """
  fetch data from the table: "ref_locations"
  """
  ref_locations(
    """distinct select on columns"""
    distinct_on: [ref_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_locations_order_by!]

    """filter the rows returned"""
    where: ref_locations_bool_exp
  ): [ref_locations!]!

  """
  fetch aggregated fields from the table: "ref_locations"
  """
  ref_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_locations_order_by!]

    """filter the rows returned"""
    where: ref_locations_bool_exp
  ): ref_locations_aggregate!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!
}

"""
columns and relationships of "ref_calendar"
"""
type ref_calendar {
  """An array relationship"""
  all_documents(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): [all_documents!]!

  """An aggregated array relationship"""
  all_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): all_documents_aggregate!
  calendar_date: timestamptz
  day_number: bigint

  """An array relationship"""
  documentLocationsByDateInLocationFrom(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """An aggregated array relationship"""
  documentLocationsByDateInLocationFrom_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!

  """An array relationship"""
  document_locations(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """An aggregated array relationship"""
  document_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!

  """An array relationship"""
  documentsToBeDestroyedsByPlannedDestructionDate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """An aggregated array relationship"""
  documentsToBeDestroyedsByPlannedDestructionDate_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!

  """An array relationship"""
  documents_to_be_destroyeds(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """An aggregated array relationship"""
  documents_to_be_destroyeds_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!
}

"""
aggregated selection of "ref_calendar"
"""
type ref_calendar_aggregate {
  aggregate: ref_calendar_aggregate_fields
  nodes: [ref_calendar!]!
}

"""
aggregate fields of "ref_calendar"
"""
type ref_calendar_aggregate_fields {
  avg: ref_calendar_avg_fields
  count(columns: [ref_calendar_select_column!], distinct: Boolean): Int
  max: ref_calendar_max_fields
  min: ref_calendar_min_fields
  stddev: ref_calendar_stddev_fields
  stddev_pop: ref_calendar_stddev_pop_fields
  stddev_samp: ref_calendar_stddev_samp_fields
  sum: ref_calendar_sum_fields
  var_pop: ref_calendar_var_pop_fields
  var_samp: ref_calendar_var_samp_fields
  variance: ref_calendar_variance_fields
}

"""
order by aggregate values of table "ref_calendar"
"""
input ref_calendar_aggregate_order_by {
  avg: ref_calendar_avg_order_by
  count: order_by
  max: ref_calendar_max_order_by
  min: ref_calendar_min_order_by
  stddev: ref_calendar_stddev_order_by
  stddev_pop: ref_calendar_stddev_pop_order_by
  stddev_samp: ref_calendar_stddev_samp_order_by
  sum: ref_calendar_sum_order_by
  var_pop: ref_calendar_var_pop_order_by
  var_samp: ref_calendar_var_samp_order_by
  variance: ref_calendar_variance_order_by
}

"""
input type for inserting array relation for remote table "ref_calendar"
"""
input ref_calendar_arr_rel_insert_input {
  data: [ref_calendar_insert_input!]!
  on_conflict: ref_calendar_on_conflict
}

"""aggregate avg on columns"""
type ref_calendar_avg_fields {
  day_number: Float
}

"""
order by avg() on columns of table "ref_calendar"
"""
input ref_calendar_avg_order_by {
  day_number: order_by
}

"""
Boolean expression to filter rows from the table "ref_calendar". All fields are combined with a logical 'AND'.
"""
input ref_calendar_bool_exp {
  _and: [ref_calendar_bool_exp]
  _not: ref_calendar_bool_exp
  _or: [ref_calendar_bool_exp]
  all_documents: all_documents_bool_exp
  calendar_date: timestamptz_comparison_exp
  day_number: bigint_comparison_exp
  documentLocationsByDateInLocationFrom: document_locations_bool_exp
  document_locations: document_locations_bool_exp
  documentsToBeDestroyedsByPlannedDestructionDate: documents_to_be_destroyed_bool_exp
  documents_to_be_destroyeds: documents_to_be_destroyed_bool_exp
}

"""
unique or primary key constraints on table "ref_calendar"
"""
enum ref_calendar_constraint {
  """unique or primary key constraint"""
  idx_21643_sqlite_autoindex_ref_calendar_1
}

"""
input type for incrementing integer column in table "ref_calendar"
"""
input ref_calendar_inc_input {
  day_number: bigint
}

"""
input type for inserting data into table "ref_calendar"
"""
input ref_calendar_insert_input {
  all_documents: all_documents_arr_rel_insert_input
  calendar_date: timestamptz
  day_number: bigint
  documentLocationsByDateInLocationFrom: document_locations_arr_rel_insert_input
  document_locations: document_locations_arr_rel_insert_input
  documentsToBeDestroyedsByPlannedDestructionDate: documents_to_be_destroyed_arr_rel_insert_input
  documents_to_be_destroyeds: documents_to_be_destroyed_arr_rel_insert_input
}

"""aggregate max on columns"""
type ref_calendar_max_fields {
  calendar_date: timestamptz
  day_number: bigint
}

"""
order by max() on columns of table "ref_calendar"
"""
input ref_calendar_max_order_by {
  calendar_date: order_by
  day_number: order_by
}

"""aggregate min on columns"""
type ref_calendar_min_fields {
  calendar_date: timestamptz
  day_number: bigint
}

"""
order by min() on columns of table "ref_calendar"
"""
input ref_calendar_min_order_by {
  calendar_date: order_by
  day_number: order_by
}

"""
response of any mutation on the table "ref_calendar"
"""
type ref_calendar_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [ref_calendar!]!
}

"""
input type for inserting object relation for remote table "ref_calendar"
"""
input ref_calendar_obj_rel_insert_input {
  data: ref_calendar_insert_input!
  on_conflict: ref_calendar_on_conflict
}

"""
on conflict condition type for table "ref_calendar"
"""
input ref_calendar_on_conflict {
  constraint: ref_calendar_constraint!
  update_columns: [ref_calendar_update_column!]!
  where: ref_calendar_bool_exp
}

"""
ordering options when selecting data from "ref_calendar"
"""
input ref_calendar_order_by {
  all_documents_aggregate: all_documents_aggregate_order_by
  calendar_date: order_by
  day_number: order_by
  documentLocationsByDateInLocationFrom_aggregate: document_locations_aggregate_order_by
  document_locations_aggregate: document_locations_aggregate_order_by
  documentsToBeDestroyedsByPlannedDestructionDate_aggregate: documents_to_be_destroyed_aggregate_order_by
  documents_to_be_destroyeds_aggregate: documents_to_be_destroyed_aggregate_order_by
}

"""
select columns of table "ref_calendar"
"""
enum ref_calendar_select_column {
  """column name"""
  calendar_date

  """column name"""
  day_number
}

"""
input type for updating data in table "ref_calendar"
"""
input ref_calendar_set_input {
  calendar_date: timestamptz
  day_number: bigint
}

"""aggregate stddev on columns"""
type ref_calendar_stddev_fields {
  day_number: Float
}

"""
order by stddev() on columns of table "ref_calendar"
"""
input ref_calendar_stddev_order_by {
  day_number: order_by
}

"""aggregate stddev_pop on columns"""
type ref_calendar_stddev_pop_fields {
  day_number: Float
}

"""
order by stddev_pop() on columns of table "ref_calendar"
"""
input ref_calendar_stddev_pop_order_by {
  day_number: order_by
}

"""aggregate stddev_samp on columns"""
type ref_calendar_stddev_samp_fields {
  day_number: Float
}

"""
order by stddev_samp() on columns of table "ref_calendar"
"""
input ref_calendar_stddev_samp_order_by {
  day_number: order_by
}

"""aggregate sum on columns"""
type ref_calendar_sum_fields {
  day_number: bigint
}

"""
order by sum() on columns of table "ref_calendar"
"""
input ref_calendar_sum_order_by {
  day_number: order_by
}

"""
update columns of table "ref_calendar"
"""
enum ref_calendar_update_column {
  """column name"""
  calendar_date

  """column name"""
  day_number
}

"""aggregate var_pop on columns"""
type ref_calendar_var_pop_fields {
  day_number: Float
}

"""
order by var_pop() on columns of table "ref_calendar"
"""
input ref_calendar_var_pop_order_by {
  day_number: order_by
}

"""aggregate var_samp on columns"""
type ref_calendar_var_samp_fields {
  day_number: Float
}

"""
order by var_samp() on columns of table "ref_calendar"
"""
input ref_calendar_var_samp_order_by {
  day_number: order_by
}

"""aggregate variance on columns"""
type ref_calendar_variance_fields {
  day_number: Float
}

"""
order by variance() on columns of table "ref_calendar"
"""
input ref_calendar_variance_order_by {
  day_number: order_by
}

"""
columns and relationships of "ref_document_types"
"""
type ref_document_types {
  """An array relationship"""
  all_documents(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): [all_documents!]!

  """An aggregated array relationship"""
  all_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): all_documents_aggregate!
  document_type_code: String
  document_type_description: String
  document_type_name: String
}

"""
aggregated selection of "ref_document_types"
"""
type ref_document_types_aggregate {
  aggregate: ref_document_types_aggregate_fields
  nodes: [ref_document_types!]!
}

"""
aggregate fields of "ref_document_types"
"""
type ref_document_types_aggregate_fields {
  count(columns: [ref_document_types_select_column!], distinct: Boolean): Int
  max: ref_document_types_max_fields
  min: ref_document_types_min_fields
}

"""
order by aggregate values of table "ref_document_types"
"""
input ref_document_types_aggregate_order_by {
  count: order_by
  max: ref_document_types_max_order_by
  min: ref_document_types_min_order_by
}

"""
input type for inserting array relation for remote table "ref_document_types"
"""
input ref_document_types_arr_rel_insert_input {
  data: [ref_document_types_insert_input!]!
  on_conflict: ref_document_types_on_conflict
}

"""
Boolean expression to filter rows from the table "ref_document_types". All fields are combined with a logical 'AND'.
"""
input ref_document_types_bool_exp {
  _and: [ref_document_types_bool_exp]
  _not: ref_document_types_bool_exp
  _or: [ref_document_types_bool_exp]
  all_documents: all_documents_bool_exp
  document_type_code: String_comparison_exp
  document_type_description: String_comparison_exp
  document_type_name: String_comparison_exp
}

"""
unique or primary key constraints on table "ref_document_types"
"""
enum ref_document_types_constraint {
  """unique or primary key constraint"""
  idx_21637_sqlite_autoindex_ref_document_types_1
}

"""
input type for inserting data into table "ref_document_types"
"""
input ref_document_types_insert_input {
  all_documents: all_documents_arr_rel_insert_input
  document_type_code: String
  document_type_description: String
  document_type_name: String
}

"""aggregate max on columns"""
type ref_document_types_max_fields {
  document_type_code: String
  document_type_description: String
  document_type_name: String
}

"""
order by max() on columns of table "ref_document_types"
"""
input ref_document_types_max_order_by {
  document_type_code: order_by
  document_type_description: order_by
  document_type_name: order_by
}

"""aggregate min on columns"""
type ref_document_types_min_fields {
  document_type_code: String
  document_type_description: String
  document_type_name: String
}

"""
order by min() on columns of table "ref_document_types"
"""
input ref_document_types_min_order_by {
  document_type_code: order_by
  document_type_description: order_by
  document_type_name: order_by
}

"""
response of any mutation on the table "ref_document_types"
"""
type ref_document_types_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [ref_document_types!]!
}

"""
input type for inserting object relation for remote table "ref_document_types"
"""
input ref_document_types_obj_rel_insert_input {
  data: ref_document_types_insert_input!
  on_conflict: ref_document_types_on_conflict
}

"""
on conflict condition type for table "ref_document_types"
"""
input ref_document_types_on_conflict {
  constraint: ref_document_types_constraint!
  update_columns: [ref_document_types_update_column!]!
  where: ref_document_types_bool_exp
}

"""
ordering options when selecting data from "ref_document_types"
"""
input ref_document_types_order_by {
  all_documents_aggregate: all_documents_aggregate_order_by
  document_type_code: order_by
  document_type_description: order_by
  document_type_name: order_by
}

"""
select columns of table "ref_document_types"
"""
enum ref_document_types_select_column {
  """column name"""
  document_type_code

  """column name"""
  document_type_description

  """column name"""
  document_type_name
}

"""
input type for updating data in table "ref_document_types"
"""
input ref_document_types_set_input {
  document_type_code: String
  document_type_description: String
  document_type_name: String
}

"""
update columns of table "ref_document_types"
"""
enum ref_document_types_update_column {
  """column name"""
  document_type_code

  """column name"""
  document_type_description

  """column name"""
  document_type_name
}

"""
columns and relationships of "ref_locations"
"""
type ref_locations {
  """An array relationship"""
  document_locations(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """An aggregated array relationship"""
  document_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!
  location_code: String
  location_description: String
  location_name: String
}

"""
aggregated selection of "ref_locations"
"""
type ref_locations_aggregate {
  aggregate: ref_locations_aggregate_fields
  nodes: [ref_locations!]!
}

"""
aggregate fields of "ref_locations"
"""
type ref_locations_aggregate_fields {
  count(columns: [ref_locations_select_column!], distinct: Boolean): Int
  max: ref_locations_max_fields
  min: ref_locations_min_fields
}

"""
order by aggregate values of table "ref_locations"
"""
input ref_locations_aggregate_order_by {
  count: order_by
  max: ref_locations_max_order_by
  min: ref_locations_min_order_by
}

"""
input type for inserting array relation for remote table "ref_locations"
"""
input ref_locations_arr_rel_insert_input {
  data: [ref_locations_insert_input!]!
  on_conflict: ref_locations_on_conflict
}

"""
Boolean expression to filter rows from the table "ref_locations". All fields are combined with a logical 'AND'.
"""
input ref_locations_bool_exp {
  _and: [ref_locations_bool_exp]
  _not: ref_locations_bool_exp
  _or: [ref_locations_bool_exp]
  document_locations: document_locations_bool_exp
  location_code: String_comparison_exp
  location_description: String_comparison_exp
  location_name: String_comparison_exp
}

"""
unique or primary key constraints on table "ref_locations"
"""
enum ref_locations_constraint {
  """unique or primary key constraint"""
  idx_21646_sqlite_autoindex_ref_locations_1
}

"""
input type for inserting data into table "ref_locations"
"""
input ref_locations_insert_input {
  document_locations: document_locations_arr_rel_insert_input
  location_code: String
  location_description: String
  location_name: String
}

"""aggregate max on columns"""
type ref_locations_max_fields {
  location_code: String
  location_description: String
  location_name: String
}

"""
order by max() on columns of table "ref_locations"
"""
input ref_locations_max_order_by {
  location_code: order_by
  location_description: order_by
  location_name: order_by
}

"""aggregate min on columns"""
type ref_locations_min_fields {
  location_code: String
  location_description: String
  location_name: String
}

"""
order by min() on columns of table "ref_locations"
"""
input ref_locations_min_order_by {
  location_code: order_by
  location_description: order_by
  location_name: order_by
}

"""
response of any mutation on the table "ref_locations"
"""
type ref_locations_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [ref_locations!]!
}

"""
input type for inserting object relation for remote table "ref_locations"
"""
input ref_locations_obj_rel_insert_input {
  data: ref_locations_insert_input!
  on_conflict: ref_locations_on_conflict
}

"""
on conflict condition type for table "ref_locations"
"""
input ref_locations_on_conflict {
  constraint: ref_locations_constraint!
  update_columns: [ref_locations_update_column!]!
  where: ref_locations_bool_exp
}

"""
ordering options when selecting data from "ref_locations"
"""
input ref_locations_order_by {
  document_locations_aggregate: document_locations_aggregate_order_by
  location_code: order_by
  location_description: order_by
  location_name: order_by
}

"""
select columns of table "ref_locations"
"""
enum ref_locations_select_column {
  """column name"""
  location_code

  """column name"""
  location_description

  """column name"""
  location_name
}

"""
input type for updating data in table "ref_locations"
"""
input ref_locations_set_input {
  location_code: String
  location_description: String
  location_name: String
}

"""
update columns of table "ref_locations"
"""
enum ref_locations_update_column {
  """column name"""
  location_code

  """column name"""
  location_description

  """column name"""
  location_name
}

"""
columns and relationships of "roles"
"""
type roles {
  """An array relationship"""
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """An aggregated array relationship"""
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!
  role_code: String
  role_description: String
  role_name: String
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int
  max: roles_max_fields
  min: roles_min_fields
}

"""
order by aggregate values of table "roles"
"""
input roles_aggregate_order_by {
  count: order_by
  max: roles_max_order_by
  min: roles_min_order_by
}

"""
input type for inserting array relation for remote table "roles"
"""
input roles_arr_rel_insert_input {
  data: [roles_insert_input!]!
  on_conflict: roles_on_conflict
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp]
  _not: roles_bool_exp
  _or: [roles_bool_exp]
  employees: employees_bool_exp
  role_code: String_comparison_exp
  role_description: String_comparison_exp
  role_name: String_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """unique or primary key constraint"""
  idx_21652_sqlite_autoindex_roles_1
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  employees: employees_arr_rel_insert_input
  role_code: String
  role_description: String
  role_name: String
}

"""aggregate max on columns"""
type roles_max_fields {
  role_code: String
  role_description: String
  role_name: String
}

"""
order by max() on columns of table "roles"
"""
input roles_max_order_by {
  role_code: order_by
  role_description: order_by
  role_name: order_by
}

"""aggregate min on columns"""
type roles_min_fields {
  role_code: String
  role_description: String
  role_name: String
}

"""
order by min() on columns of table "roles"
"""
input roles_min_order_by {
  role_code: order_by
  role_description: order_by
  role_name: order_by
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!
  on_conflict: roles_on_conflict
}

"""
on conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]!
  where: roles_bool_exp
}

"""
ordering options when selecting data from "roles"
"""
input roles_order_by {
  employees_aggregate: employees_aggregate_order_by
  role_code: order_by
  role_description: order_by
  role_name: order_by
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  role_code

  """column name"""
  role_description

  """column name"""
  role_name
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  role_code: String
  role_description: String
  role_name: String
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  role_code

  """column name"""
  role_description

  """column name"""
  role_name
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "all_documents"
  """
  all_documents(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): [all_documents!]!

  """
  fetch aggregated fields from the table: "all_documents"
  """
  all_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [all_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_documents_order_by!]

    """filter the rows returned"""
    where: all_documents_bool_exp
  ): all_documents_aggregate!

  """fetch data from the table: "all_documents" using primary key columns"""
  all_documents_by_pk(document_id: bigint!): all_documents

  """
  fetch data from the table: "document_locations"
  """
  document_locations(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): [document_locations!]!

  """
  fetch aggregated fields from the table: "document_locations"
  """
  document_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [document_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [document_locations_order_by!]

    """filter the rows returned"""
    where: document_locations_bool_exp
  ): document_locations_aggregate!

  """
  fetch data from the table: "documents_to_be_destroyed"
  """
  documents_to_be_destroyed(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): [documents_to_be_destroyed!]!

  """
  fetch aggregated fields from the table: "documents_to_be_destroyed"
  """
  documents_to_be_destroyed_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_to_be_destroyed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_to_be_destroyed_order_by!]

    """filter the rows returned"""
    where: documents_to_be_destroyed_bool_exp
  ): documents_to_be_destroyed_aggregate!

  """
  fetch data from the table: "documents_to_be_destroyed" using primary key columns
  """
  documents_to_be_destroyed_by_pk(document_id: bigint!): documents_to_be_destroyed

  """
  fetch data from the table: "employees"
  """
  employees(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): [employees!]!

  """
  fetch aggregated fields from the table: "employees"
  """
  employees_aggregate(
    """distinct select on columns"""
    distinct_on: [employees_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employees_order_by!]

    """filter the rows returned"""
    where: employees_bool_exp
  ): employees_aggregate!

  """fetch data from the table: "employees" using primary key columns"""
  employees_by_pk(employee_id: bigint!): employees

  """
  fetch data from the table: "ref_calendar"
  """
  ref_calendar(
    """distinct select on columns"""
    distinct_on: [ref_calendar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_calendar_order_by!]

    """filter the rows returned"""
    where: ref_calendar_bool_exp
  ): [ref_calendar!]!

  """
  fetch aggregated fields from the table: "ref_calendar"
  """
  ref_calendar_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_calendar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_calendar_order_by!]

    """filter the rows returned"""
    where: ref_calendar_bool_exp
  ): ref_calendar_aggregate!

  """
  fetch data from the table: "ref_document_types"
  """
  ref_document_types(
    """distinct select on columns"""
    distinct_on: [ref_document_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_document_types_order_by!]

    """filter the rows returned"""
    where: ref_document_types_bool_exp
  ): [ref_document_types!]!

  """
  fetch aggregated fields from the table: "ref_document_types"
  """
  ref_document_types_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_document_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_document_types_order_by!]

    """filter the rows returned"""
    where: ref_document_types_bool_exp
  ): ref_document_types_aggregate!

  """
  fetch data from the table: "ref_locations"
  """
  ref_locations(
    """distinct select on columns"""
    distinct_on: [ref_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_locations_order_by!]

    """filter the rows returned"""
    where: ref_locations_bool_exp
  ): [ref_locations!]!

  """
  fetch aggregated fields from the table: "ref_locations"
  """
  ref_locations_aggregate(
    """distinct select on columns"""
    distinct_on: [ref_locations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ref_locations_order_by!]

    """filter the rows returned"""
    where: ref_locations_bool_exp
  ): ref_locations_aggregate!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
