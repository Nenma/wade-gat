<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>GAT - Scholarly HTML Technical Report</title>
    <link rel="stylesheet" href="https://w3c.github.io/scholarly-html/css/scholarly.min.css">
    <script src="https://w3c.github.io/scholarly-html/js/scholarly.min.js"></script>
  </head>
  <body prefix="schema: http://schema.org">
    <header>
      <h1>GAT - Scholarly HTML Technical Report</h1>
    </header>
    <div role="contentinfo">
      <dl>
        <dt>Authors</dt>
        <dd>
            Roșu Cristian-Mihai & Lupancu Viorica-Camelia, students at FII MLC1
        </dd>
      </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
      <h2>Abstract</h2>
      <p>
        This paper is a technical report describing the preliminary considerations about the internal data structures and models to be used and the external data sources managed by 
        the <a href="#gat">GAT Web application</a>.
      </p>
    </section>
    <section id="introduction" role="doc-introduction">
      <h2>Introduction</h2>
      <p>
        GAT, or the <a href="#graphql">GraphQL API</a> Interactive Tool, is meant to be a tool that uses knowledge models to learn the proper concepts exposed by a public GraphQL API's schema (e.g. resources, their 
        inputs and outputs) to facilitate a proper text- or voice-based interaction.
      </p>
      <p>
        As a preliminary idea, the application will be divided in three main modules, following a service oriented architecture:
        
        <ul>
            <li>Web application UI</li>
            <li>NLP Module</li>
            <li>GraphQL API Explorer Module</li>
        </ul>

        In the following sections, the basic structure and functionality of each of these modules will be described.
      </p>
    </section>
    <section id="structure">
      <h2>Preliminary structure</h2>
      <p>
        The project will be divided in three main modules, each intended to work independently as a service, that will communicate with each other via REST APIs and a database.
      </p>

      <section id="ui">
        <h3>Web application UI</h3>
        <p>
            The main interface through which the text-based interaction between a user and the application will take place is a simple web application. This web interface is intended
            to have a very simple and clean UI that keeps the exchange as minimal and meaningful as possible. The user should not have to register for an account and the only input needed,
            apart from the questions themselves, should be the GraphQL API URL that needs to be explored by the application in order to be ready to answer the respective questions.
        </p>
        <p>
            Upon opening the web application, the user will be greeted by a home page that shortly summarizes the tool's purpose and utility and that will also present the user with an input
            field that expects to receive a valid GraphQL API URL. Only after this has been supplied, the user will be redirected to a new page that will allow for communication with the tool
            in a chat-like manner. From here, a continuous exchange of questions by the user and answers by the tool should follow uninterrupted unless stopped by the user.
        </p>
        <p>
            This communication is mainly handled by the NLP module and is carried out using a REST API.
        </p>
      </section>

        <section id="nlp">
            <h3>NLP Module</h3>
            <p>
                The purpose of this module is to serve as part of the Question Answering System behind the tool's communication logic. As mentioned, a REST API ensures data transmission between user and
                application. For this module, the REST API uses two endpoints:

                <ul>
                    <li><figure typeof="schema:SoftwareSourceCode"><pre>POST /submitURL</pre></figure></li>
                    <li><figure typeof="schema:SoftwareSourceCode"><pre>POST /submitQuestion</pre></figure></li>
                </ul>

                The first endpoint is only meant to be used to receive the URL that was sent in the input field of the home page and later send it to the Explorer module, while the second endpoint
                is exclusively used for user communication. The body of this request carries the user question and as its response it will bring an answer back to the user.
            </p>
            <p>
                <a href="#qas">Question Answering Systems</a> (QAS) try to find answers to natural language questions submitted by users, by looking for answers on a set of available information
                sources, which can be spread on a single machine or all over the Internet. Broadly speaking, QAS have two major components:

                <ol>
                    <li>A search engine which retrieves a set of promising documents from the collection along with a brief description of relevant passages called snippets.</li>
                    <li>An answer extraction module which gets answers from relevant documents and/or snippets.</li>
                </ol>

                In our case, the first component is represented by the Explorer module, while the second component is represented by this one.
            </p>
            <p>
                The trend of QAS is to start by analyzing the query, in order to select an adequate strategy for answering the question. This initial phase is called Query Analysis. There are 
                different approaches to Query Analysis, but in most cases it aims for determining the Expected Answer Type (EAT). At this primary step, the answer is assigned to one of a set of 
                distinct and separate categories, and this categorization constrains and guides the whole answering process. The number of categories vary from approach to approach.
            </p>
            <p>
                This module is meant to follow these steps, but with the difference being that our information source is much more structured than what would otherwise be found using a search engine
                or any normal method, and thus determining the EAT should prove to be a task achievable with a higher degree of certainty. This information source is represented by our database 
                which contains structured information provided by the Explorer module regarding the domain and notions specific to the desired public GraphQL API.
            </p>
        </section>

        <section id="explorer">
            <h3>GraphQL API Explorer Module</h3>
            <p>
                As mentioned in the previous section, this module serves as the first component of the tool's Question Answering System (QAS) which deals with information retrieval. In our case,
                this module's purpose is to infer the internal structure of the queries and types used by the provided public GraphQL API.
            </p>
            <p>
                The URL of this API is obtained through a REST API endpoint, <code>POST /submitEndpoint</code>, that is being called in the NLP module after receiving it from the user.
            </p>
            <p>
                GraphQL <a href="#introspec">introspection</a> makes it possible to query which resources are available in the current API schema. Via this capability, the queries, types, fields, and directives 
                that the API supports can be observed. The introspection system defines <code>__Schema</code>, <code>__Type</code>, <code>__TypeKind</code>, <code>__Field</code>, 
                <code>__InputValue</code>, <code>__EnumValue</code>, and <code>__Directive</code> which are introspective queries. These are preceded by two underscores which are exclusively 
                used by GraphQL’s introspection system.
            </p>
            <p>
                This module will make use of this capability to create custom data types for the objects that will store the API query information that will later be stored in the database for the
                NLP module to use.
            </p>
        </section>
    </section>
    <section id="project-progress">
        <h2>Project progress</h2>
        <p>
            Regarding the initial structure of the project, there have been changes along the way. In the following sections, the final application architecture, the requirements and final result will be presented. 
        </p>

        <section id="final-app-architecture">
            <h2>Final application architecture with respect to the initial goals</h2>
            <p>
                The initial structure of the project involved a Question Answering System as the NLP module. Idea that turned out to be inappropriate to meet the requirements of the project, considering that in 
                order to answer a question, a corpus was needed, when in fact only some GraphQL schemes were provided. Therefore, the NLP component is represented by a Semantic Parser.
                Currently, the project structure contains the following modules:
            </p>
            <ul id="modules">
                <li id="web-app">
                    <h4>Web application</h4>
                    <p>
                        Regarding the user interface, there have also been some changes compared to the preliminary structure. So now all the data that the user must enter (a public GraphQL API URL and 
                        the question/query for that GraphQL API) will be entered exclusively in the interaction page. Also, the tool-user communication does not take place in a chat-box manner, but through some 
                        text input fields and some areas for displaying the results. As originally designed, the communication between the UI and the NLP module is carried out using a REST API.
                    </p>
                </li>
                <!-- <li id="backend"> 
                    <h4>Backend</h4>
                </li> -->
                <li id="nlp-explorer">
                    <h4>Semantic parser and API explorer</h4>
                    <p>
                        In the final version of the application, the NLP component is represented by a semantic parser that converts a natural language question (written in English) into a GraphQL query.
                    </p>
                    <p>
                        It all started with creating an English to GraphQL dataset, a series of GraphQL schemas and a series of {question, schema_name, query} tuples needed to train a model (in this case T5).
                        Due to lack of data, too few valid public GraphQL APIs, we had to use an existing dataset. The only English to GraphQL dataset found is the one created by Andre Carerra for his project 
                        "<a href="#parser-proj">Semantic Parsing English to GraphQL</a>". This cross domain English to GraphQL dataset, allowing for semantic parsing, consists of 160 schemas, 4.353 unique English questions
                        and 2.472 unique GraphQL queries (compared to 8 schemas, 384 questions and queries which we managed to write). This dataset is created by transforming 160 SQL databases into GraphQL schemas.
                    </p>
                    <p>
                        After getting this dataset, we managed to train a T5-small model, which is a NLP model implemented in Transformer library, using Python programming language. 
                        Once we handled to train a model, it was possible to convert a natural language question into a SQL query. The query predicted by the model is an SQL one, because the GraphQL schema that we get 
                        differs in structure from the ones that were used to train the model. In this situation, another step appeared, the transformation of an SQL query into a GraphQL query.
                        This transformation is based on keywords such as SELECT, FROM, WHERE.
                    </p>
                    <p>
                        The GraphQL API Explorer component is part of the same module. This component is meant to retrieve the schema (the internal structure of the queries and types) provided by the public GraphQL API.
                        To get the schema we send a GraphQL introspection query (a HTTP request) to the GraphQL server endpoint asking for the GraphQL schema.
                    </p>
                </li>
            </ul>
        </section>

        <section id="requirements">
            <h2>Requirements</h2>
            <ul>
                <li>
                    Software requirements:
                    <ul>
                        <li>Frontend: HTML, CSS, JavaScript</li>
                        <li>Semantic parser and GraphQL API explorer: Python</li>
                        <li>OpenAPI: Swagger</li>
                    </ul>
                </li>
                <li> User requirements:
                    <ul>
                        <li>The user is able to enter a public GraphQL API URL along with a natural language question written in English and receive the GraphQL response to that question</li>
                        <li>The user is able to enter a public GraphQL API URL along with a query for that GraphQL schema and receive the GraphQL response</li>
                    </ul>
                </li>
                <li> Application requirements:
                    <ul>
                        <li>The application is able to predict an equivalent GraphQL query to a given natural language question written in English</li>
                        <li>The application is able to send a request to a public GraphQL API</li>
                        <li>The application is able to display a result related to the question/query received from the user</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="outcome">
            <h2>Outcome</h2>
            <p>
                The current application is able to read the input from the user, process it and return relevant results. 
            </p>
        </section>
    </section>
    <section id="api">
        <h2>Technical aspects concerning the implemented API</h2>
        <p>
            The data transmission between user and application is ensured by a REST API. This REST API uses four endpoints:
            <ul>
                <li><figure typeof="schema:SoftwareSourceCode"><pre>POST /question</pre></figure></li>
                <li><figure typeof="schema:SoftwareSourceCode"><pre>GET /prediction</pre></figure></li>
                <li><figure typeof="schema:SoftwareSourceCode"><pre>POST /predictedQuery</pre></figure></li>
                <li><figure typeof="schema:SoftwareSourceCode"><pre>GET /response</pre></figure></li>
            </ul>

            The first endpoint is meant to receive the public GraphQL API URL along with the natural language question that were written in the input field of the interaction page and send them to the Semantic parser component.
            The second endpoint is used for sending the predicted GraphQL query to the UI. The third endpoint is meant to receive the predicted query by the Semantic parser and send it to the Explorer component.
            And the fourth endpoint is used to get the answer to the query from the Explorer and send it to the UI. 
        </p>
    </section>
    <section id="conclusion">
      <h2>Conclusion</h2>
      <p>
          The modules presented above work individually, but together they make up the preliminary structure of the text-based interaction of project GAT.
      </p>
      <p>
          As this is a web application, the <a href="#linked-data">linked data principles</a> are upheld since the only structured data being transmitted
          is done through the internal REST APIs via GET requests, only on of which returns response data that more than conforms to these principles.
      </p>
    </section>
    <section id="references">
        <h2>References</h2>
        <ol>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://profs.info.uaic.ro/~busaco/teach/courses/wade/projects/index.html" id="gat">
                <cite property="schema:name">
                    <a href="https://profs.info.uaic.ro/~busaco/teach/courses/wade/projects/index.html">#WADe Project Proposals</a>
                </cite>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://w3c.github.io/scholarly-html/">
                <cite property="schema:name">
                    <a href="https://w3c.github.io/scholarly-html/">Scholarly HTML</a>
                </cite>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://graphql.org/" id="graphql">
                <cite property="schema:name">
                    <a href="https://graphql.org/">graphql.org</a>
                </cite>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://www.researchgate.net/publication/271911238_Genetic_Algorithms_for_syntactic_and_data-driven_Question_Answering_on_the_Web" property="schema:citation" id="qas">
                <cite property="schema:name">
                    <a href="https://www.researchgate.net/publication/271911238_Genetic_Algorithms_for_syntactic_and_data-driven_Question_Answering_on_the_Web">Genetic Algorithm for Syntactic and Data Driven Question Answering on the Web</a>
                </cite>
                , by
                <span property="schema:author" typeof="schema:Person">
                    <span property="schema:givenName">Alejandro</span>
                    <span property="schema:familyName">Figueroa</span>
                </span>
                ; published in
                <time property="schema:datePublished" datatype="xsd:gYear" datetime="2016">2016</time>
                <span property="schema:potentialAction" typeof="schema:ReadAction">
                    <meta property="schema:actionStatus" content="CompletedActionStatus">
                </span>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://graphql.org/learn/introspection/" id="introspec">
                <cite property="schema:name">
                    <a href="https://graphql.org/learn/introspection/">GraphQL Introspection</a>
                </cite>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://blog.lambdo.com/spegql-openai-scholars-final-project/" id="#parser-proj">
                <cite property="schema:name">
                    <a href="https://blog.lambdo.com/spegql-openai-scholars-final-project/">Semantic Parsing English to GraphQL Project</a>
                </cite>
            </li>
            <li typeof="schema:WebPage" role="doc-biblioentry" resource="https://www.w3.org/wiki/LinkedData" id="linked-data">
                <cite property="schema:name">
                    <a href="https://www.w3.org/wiki/LinkedData">LinkedData Principles</a>
                </cite>
            </li>
        </ol>
    </section>
  </body>
</html>